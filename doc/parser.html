<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "gosip/parser"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				
			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
			
			
				
				<dd><a href="#AcceptEncodingParser">type AcceptEncodingParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAcceptEncodingParser">func NewAcceptEncodingParser(acceptEncoding string) *AcceptEncodingParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAcceptEncodingParserFromLexer">func NewAcceptEncodingParserFromLexer(lexer core.Lexer) *AcceptEncodingParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AcceptEncodingParser.Parse">func (this *AcceptEncodingParser) Parse() (sh header.SIPHeader, ParseException error)</a></dd>
				
			
				
				<dd><a href="#AcceptLanguageParser">type AcceptLanguageParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAcceptLanguageParser">func NewAcceptLanguageParser(acceptLanguage string) *AcceptLanguageParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAcceptLanguageParserFromLexer">func NewAcceptLanguageParserFromLexer(lexer core.Lexer) *AcceptLanguageParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AcceptLanguageParser.Parse">func (this *AcceptLanguageParser) Parse() (sh header.SIPHeader, ParseException error)</a></dd>
				
			
				
				<dd><a href="#AddressParametersParser">type AddressParametersParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAddressParametersParser">func NewAddressParametersParser(buffer string) *AddressParametersParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAddressParametersParserFromLexer">func NewAddressParametersParserFromLexer(lexer core.Lexer) *AddressParametersParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AddressParametersParser.Parse">func (this *AddressParametersParser) Parse(addressParametersHeader header.AddressParametersHeader) (ParseException error)</a></dd>
				
			
				
				<dd><a href="#AddressParser">type AddressParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAddressParser">func NewAddressParser(addr string) *AddressParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAddressParserFromLexer">func NewAddressParserFromLexer(lexer core.Lexer) *AddressParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AddressParser.Address">func (this *AddressParser) Address() (retval *address.AddressImpl, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AddressParser.NameAddr">func (this *AddressParser) NameAddr() (addr *address.AddressImpl, ParseException error)</a></dd>
				
			
				
				<dd><a href="#CSeqParser">type CSeqParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCSeqParser">func NewCSeqParser(cseq string) *CSeqParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCSeqParserFromLexer">func NewCSeqParserFromLexer(lexer core.Lexer) *CSeqParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CSeqParser.Parse">func (this *CSeqParser) Parse() (sh header.SIPHeader, ParseException error)</a></dd>
				
			
				
				<dd><a href="#CallIDParser">type CallIDParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCallIDParser">func NewCallIDParser(callId string) *CallIDParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCallIDParserFromLexer">func NewCallIDParserFromLexer(lexer core.Lexer) *CallIDParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CallIDParser.Parse">func (this *CallIDParser) Parse() (sh header.SIPHeader, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ContactParser">type ContactParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewContactParser">func NewContactParser(contact string) *ContactParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewContactParserFromLexer">func NewContactParserFromLexer(lexer core.Lexer) *ContactParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ContactParser.Parse">func (this *ContactParser) Parse() (sh header.SIPHeader, ParseException error)</a></dd>
				
			
				
				<dd><a href="#FromParser">type FromParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFromParser">func NewFromParser(from string) *FromParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFromParserFromLexer">func NewFromParserFromLexer(lexer core.Lexer) *FromParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FromParser.Parse">func (this *FromParser) Parse() (sh header.SIPHeader, ParseException error)</a></dd>
				
			
				
				<dd><a href="#HeaderParser">type HeaderParser</a></dd>
				
				
			
				
				<dd><a href="#HeaderParserImpl">type HeaderParserImpl</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewHeaderParserImpl">func NewHeaderParserImpl(header string) *HeaderParserImpl</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewHeaderParserImplFromLexer">func NewHeaderParserImplFromLexer(lexer core.Lexer) *HeaderParserImpl</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#HeaderParserImpl.HeaderName">func (this *HeaderParserImpl) HeaderName(tok int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#HeaderParserImpl.Parse">func (this *HeaderParserImpl) Parse() (sh header.SIPHeader, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#HeaderParserImpl.Wkday">func (this *HeaderParserImpl) Wkday() (wk int, ParseException error)</a></dd>
				
			
				
				<dd><a href="#LexerImpl">type LexerImpl</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewLexerImpl">func NewLexerImpl(lexerName, buffer string) *LexerImpl</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LexerImpl.GetHeaderName">func (this *LexerImpl) GetHeaderName(line string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LexerImpl.GetHeaderValue">func (this *LexerImpl) GetHeaderValue(line string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LexerImpl.SelectLexer">func (this *LexerImpl) SelectLexer(lexerName string)</a></dd>
				
			
				
				<dd><a href="#MaxForwardsParser">type MaxForwardsParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMaxForwardsParser">func NewMaxForwardsParser(contentLength string) *MaxForwardsParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMaxForwardsParserFromLexer">func NewMaxForwardsParserFromLexer(lexer core.Lexer) *MaxForwardsParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MaxForwardsParser.Parse">func (this *MaxForwardsParser) Parse() (sh header.SIPHeader, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ParametersParser">type ParametersParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewParametersParser">func NewParametersParser(buffer string) *ParametersParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewParametersParserFromLexer">func NewParametersParserFromLexer(lexer core.Lexer) *ParametersParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ParametersParser.Parse">func (this *ParametersParser) Parse(parametersHeader header.ParametersHeader) (ParseException error)</a></dd>
				
			
				
				<dd><a href="#ParserImpl">type ParserImpl</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewParserImpl">func NewParserImpl(buffer string) *ParserImpl</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ParserImpl.CreateParseException">func (this *ParserImpl) CreateParseException(exceptionString string) (ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParserImpl.Method">func (this *ParserImpl) Method() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParserImpl.SipVersion">func (this *ParserImpl) SipVersion() (s string, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ToParser">type ToParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewToParser">func NewToParser(to string) *ToParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewToParserFromLexer">func NewToParserFromLexer(lexer core.Lexer) *ToParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ToParser.Parse">func (this *ToParser) Parse() (sh header.SIPHeader, ParseException error)</a></dd>
				
			
				
				<dd><a href="#URLParser">type URLParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewURLParser">func NewURLParser(url string) *URLParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewURLParserFromLexer">func NewURLParserFromLexer(lexer core.Lexer) *URLParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Base_phone_number">func (this *URLParser) Base_phone_number() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Escaped">func (this *URLParser) Escaped() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Global_phone_number">func (this *URLParser) Global_phone_number() (tn *core.TelephoneNumber, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Hvalue">func (this *URLParser) Hvalue() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.IsEscaped">func (this *URLParser) IsEscaped() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.IsMark">func (this *URLParser) IsMark(next byte) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.IsReserved">func (this *URLParser) IsReserved(next byte) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.IsReservedNoSlash">func (this *URLParser) IsReservedNoSlash(next byte) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.IsUnreserved">func (this *URLParser) IsUnreserved(next byte) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.IsUserUnreserved">func (this *URLParser) IsUserUnreserved(la byte) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Local_number">func (this *URLParser) Local_number() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Local_phone_number">func (this *URLParser) Local_phone_number() (tn *core.TelephoneNumber, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Mark">func (this *URLParser) Mark() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.ParamNameOrValue">func (this *URLParser) ParamNameOrValue() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Parse">func (this *URLParser) Parse() (url address.URI, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.ParseTelephoneNumber">func (this *URLParser) ParseTelephoneNumber() (tn *core.TelephoneNumber, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Password">func (this *URLParser) Password() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.PeekScheme">func (this *URLParser) PeekScheme() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Qheader">func (this *URLParser) Qheader() (nv *core.NameValue, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Reserved">func (this *URLParser) Reserved() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.SipURL">func (this *URLParser) SipURL() (sipurl *address.SipUri, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.TelURL">func (this *URLParser) TelURL() (telUrl *address.TelURLImpl, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Tel_parameters">func (this *URLParser) Tel_parameters() (nvl *core.NameValueList, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Unreserved">func (this *URLParser) Unreserved() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.UriParam">func (this *URLParser) UriParam() (nv *core.NameValue, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.UriReference">func (this *URLParser) UriReference() (url address.URI, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Uric">func (this *URLParser) Uric() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.UricNoSlash">func (this *URLParser) UricNoSlash() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.UricString">func (this *URLParser) UricString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.UrlString">func (this *URLParser) UrlString() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.User">func (this *URLParser) User() (s string, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ViaParser">type ViaParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewViaParser">func NewViaParser(via string) *ViaParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewViaParserFromLexer">func NewViaParserFromLexer(lexer core.Lexer) *ViaParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ViaParser.NameValue">func (this *ViaParser) NameValue() (nv *core.NameValue, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ViaParser.Parse">func (this *ViaParser) Parse() (sh header.SIPHeader, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ViaParser.ParseVia">func (this *ViaParser) ParseVia(v *header.Via) (ParseException error)</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/AcceptEncodingParser.go">AcceptEncodingParser.go</a>
			
				<a href="/target/AcceptLanguageParser.go">AcceptLanguageParser.go</a>
			
				<a href="/target/AddressParametersParser.go">AddressParametersParser.go</a>
			
				<a href="/target/AddressParser.go">AddressParser.go</a>
			
				<a href="/target/CSeqParser.go">CSeqParser.go</a>
			
				<a href="/target/CallIdParser.go">CallIdParser.go</a>
			
				<a href="/target/ContactParser.go">ContactParser.go</a>
			
				<a href="/target/FromParser.go">FromParser.go</a>
			
				<a href="/target/HeaderParser.go">HeaderParser.go</a>
			
				<a href="/target/LexerImpl.go">LexerImpl.go</a>
			
				<a href="/target/MaxForwardsParser.go">MaxForwardsParser.go</a>
			
				<a href="/target/ParametersParser.go">ParametersParser.go</a>
			
				<a href="/target/ParserImpl.go">ParserImpl.go</a>
			
				<a href="/target/ToParser.go">ToParser.go</a>
			
				<a href="/target/URLParser.go">URLParser.go</a>
			
				<a href="/target/ViaParser.go">ViaParser.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const <span id="TokenTypes_ACCEPT">TokenTypes_ACCEPT</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 20</pre>
				
			
				<pre>const <span id="TokenTypes_ACCEPT_ENCODING">TokenTypes_ACCEPT_ENCODING</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 19</pre>
				
			
				<pre>const <span id="TokenTypes_ACCEPT_LANGUAGE">TokenTypes_ACCEPT_LANGUAGE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 47</pre>
				
			
				<pre>const <span id="TokenTypes_ACK">TokenTypes_ACK</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 6</pre>
				
			
				<pre>const <span id="TokenTypes_ALERT_INFO">TokenTypes_ALERT_INFO</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 13</pre>
				
			
				<pre>const <span id="TokenTypes_ALLOW">TokenTypes_ALLOW</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 21</pre>
				
			
				<pre>const <span id="TokenTypes_ALLOW_EVENTS">TokenTypes_ALLOW_EVENTS</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 65</pre>
				
			
				<pre>const <span id="TokenTypes_ALPHA">TokenTypes_ALPHA</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_ALPHA">LexerCore_ALPHA</a></pre>
				
			
				<pre>const <span id="TokenTypes_AND">TokenTypes_AND</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;&amp;&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_AT">TokenTypes_AT</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_AT">LexerCore_AT</a></pre>
				
			
				<pre>const <span id="TokenTypes_AUTHENTICATION_INFO">TokenTypes_AUTHENTICATION_INFO</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 64</pre>
				
			
				<pre>const <span id="TokenTypes_AUTHORIZATION">TokenTypes_AUTHORIZATION</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 23</pre>
				
			
				<pre>const <span id="TokenTypes_BACKSLASH">TokenTypes_BACKSLASH</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_BACKSLASH">LexerCore_BACKSLASH</a></pre>
				
			
				<pre>const <span id="TokenTypes_BACK_QUOTE">TokenTypes_BACK_QUOTE</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_BACK_QUOTE">LexerCore_BACK_QUOTE</a></pre>
				
			
				<pre>const <span id="TokenTypes_BAR">TokenTypes_BAR</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;|&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_BYE">TokenTypes_BYE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 7</pre>
				
			
				<pre>const <span id="TokenTypes_CALL_ID">TokenTypes_CALL_ID</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 40</pre>
				
			
				<pre>const <span id="TokenTypes_CALL_INFO">TokenTypes_CALL_INFO</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 51</pre>
				
			
				<pre>const <span id="TokenTypes_CANCEL">TokenTypes_CANCEL</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 9</pre>
				
			
				<pre>const <span id="TokenTypes_COLON">TokenTypes_COLON</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_COLON">LexerCore_COLON</a></pre>
				
			
				<pre>const <span id="TokenTypes_CONTACT">TokenTypes_CONTACT</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 39</pre>
				
			
				<pre>const <span id="TokenTypes_CONTENT_DISPOSITION">TokenTypes_CONTENT_DISPOSITION</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 52</pre>
				
			
				<pre>const <span id="TokenTypes_CONTENT_ENCODING">TokenTypes_CONTENT_ENCODING</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 35</pre>
				
			
				<pre>const <span id="TokenTypes_CONTENT_LANGUAGE">TokenTypes_CONTENT_LANGUAGE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 27</pre>
				
			
				<pre>const <span id="TokenTypes_CONTENT_LENGTH">TokenTypes_CONTENT_LENGTH</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 36</pre>
				
			
				<pre>const <span id="TokenTypes_CONTENT_TYPE">TokenTypes_CONTENT_TYPE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 38</pre>
				
			
				<pre>const <span id="TokenTypes_CSEQ">TokenTypes_CSEQ</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 46</pre>
				
			
				<pre>const <span id="TokenTypes_DATE">TokenTypes_DATE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 32</pre>
				
			
				<pre>const <span id="TokenTypes_DIGIT">TokenTypes_DIGIT</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_DIGIT">LexerCore_DIGIT</a></pre>
				
			
				<pre>const <span id="TokenTypes_DOLLAR">TokenTypes_DOLLAR</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_DOLLAR">LexerCore_DOLLAR</a></pre>
				
			
				<pre>const <span id="TokenTypes_DOT">TokenTypes_DOT</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;.&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_DOUBLEQUOTE">TokenTypes_DOUBLEQUOTE</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_DOUBLEQUOTE">LexerCore_DOUBLEQUOTE</a></pre>
				
			
				<pre>const <span id="TokenTypes_ENCRYPTION">TokenTypes_ENCRYPTION</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 43</pre>
				
			
				<pre>const <span id="TokenTypes_END">TokenTypes_END</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_END">LexerCore_END</a></pre>
				<p>
Everything under this is reserved
</p>

			
				<pre>const <span id="TokenTypes_EQUALS">TokenTypes_EQUALS</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;=&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_ERROR_INFO">TokenTypes_ERROR_INFO</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 10</pre>
				
			
				<pre>const <span id="TokenTypes_EVENT">TokenTypes_EVENT</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 63</pre>
				
			
				<pre>const <span id="TokenTypes_EXCLAMATION">TokenTypes_EXCLAMATION</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;!&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_EXPIRES">TokenTypes_EXPIRES</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 42</pre>
				
			
				<pre>const <span id="TokenTypes_FROM">TokenTypes_FROM</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 14</pre>
				
			
				<pre>const <span id="TokenTypes_GREATER_THAN">TokenTypes_GREATER_THAN</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;&gt;&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_HAT">TokenTypes_HAT</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;^&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_HIDE">TokenTypes_HIDE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 50</pre>
				
			
				<pre>const <span id="TokenTypes_HT">TokenTypes_HT</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_HT">LexerCore_HT</a></pre>
				
			
				<pre>const <span id="TokenTypes_ID">TokenTypes_ID</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_ID">LexerCore_ID</a></pre>
				
			
				<pre>const <span id="TokenTypes_INVITE">TokenTypes_INVITE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 5</pre>
				
			
				<pre>const <span id="TokenTypes_IN_REPLY_TO">TokenTypes_IN_REPLY_TO</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 11</pre>
				
			
				<pre>const <span id="TokenTypes_LESS_THAN">TokenTypes_LESS_THAN</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;&lt;&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_LPAREN">TokenTypes_LPAREN</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;(&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_L_CURLY">TokenTypes_L_CURLY</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;{&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_L_SQUARE_BRACKET">TokenTypes_L_SQUARE_BRACKET</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;[&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_MAX_FORWARDS">TokenTypes_MAX_FORWARDS</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 31</pre>
				
			
				<pre>const <span id="TokenTypes_MIME_VERSION">TokenTypes_MIME_VERSION</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 12</pre>
				
			
				<pre>const <span id="TokenTypes_MINUS">TokenTypes_MINUS</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_MINUS">LexerCore_MINUS</a></pre>
				
			
				<pre>const <span id="TokenTypes_MIN_EXPIRES">TokenTypes_MIN_EXPIRES</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 62</pre>
				
			
				<pre>const <span id="TokenTypes_NOTIFY">TokenTypes_NOTIFY</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 54</pre>
				
			
				<pre>const <span id="TokenTypes_NULL">TokenTypes_NULL</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_NULL">LexerCore_NULL</a></pre>
				
			
				<pre>const <span id="TokenTypes_OPTIONS">TokenTypes_OPTIONS</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 8</pre>
				
			
				<pre>const <span id="TokenTypes_ORGANIZATION">TokenTypes_ORGANIZATION</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 45</pre>
				
			
				<pre>const <span id="TokenTypes_PERCENT">TokenTypes_PERCENT</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;%&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_PLUS">TokenTypes_PLUS</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_PLUS">LexerCore_PLUS</a></pre>
				
			
				<pre>const <span id="TokenTypes_POUND">TokenTypes_POUND</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_POUND">LexerCore_POUND</a></pre>
				
			
				<pre>const <span id="TokenTypes_PRIORITY">TokenTypes_PRIORITY</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 33</pre>
				
			
				<pre>const <span id="TokenTypes_PROXY_AUTHENTICATE">TokenTypes_PROXY_AUTHENTICATE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 34</pre>
				
			
				<pre>const <span id="TokenTypes_PROXY_AUTHORIZATION">TokenTypes_PROXY_AUTHORIZATION</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 24</pre>
				
			
				<pre>const <span id="TokenTypes_PROXY_REQUIRE">TokenTypes_PROXY_REQUIRE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 26</pre>
				
			
				<pre>const <span id="TokenTypes_QUESTION">TokenTypes_QUESTION</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;?&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_QUOTE">TokenTypes_QUOTE</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_QUOTE">LexerCore_QUOTE</a></pre>
				
			
				<pre>const <span id="TokenTypes_RACK">TokenTypes_RACK</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 61</pre>
				
			
				<pre>const <span id="TokenTypes_REASON">TokenTypes_REASON</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 59</pre>
				
			
				<pre>const <span id="TokenTypes_RECORD_ROUTE">TokenTypes_RECORD_ROUTE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 44</pre>
				
			
				<pre>const <span id="TokenTypes_REFER_TO">TokenTypes_REFER_TO</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 66</pre>
				
			
				<pre>const <span id="TokenTypes_REGISTER">TokenTypes_REGISTER</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 4</pre>
				
			
				<pre>const <span id="TokenTypes_REPLY_TO">TokenTypes_REPLY_TO</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 58</pre>
				
			
				<pre>const <span id="TokenTypes_REQUIRE">TokenTypes_REQUIRE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 41</pre>
				
			
				<pre>const <span id="TokenTypes_RESPONSE_KEY">TokenTypes_RESPONSE_KEY</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 49</pre>
				
			
				<pre>const <span id="TokenTypes_RETRY_AFTER">TokenTypes_RETRY_AFTER</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 25</pre>
				
			
				<pre>const <span id="TokenTypes_ROUTE">TokenTypes_ROUTE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 22</pre>
				
			
				<pre>const <span id="TokenTypes_RPAREN">TokenTypes_RPAREN</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;)&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_RSEQ">TokenTypes_RSEQ</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 60</pre>
				
			
				<pre>const <span id="TokenTypes_R_CURLY">TokenTypes_R_CURLY</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;}&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_R_SQUARE_BRACKET">TokenTypes_R_SQUARE_BRACKET</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;]&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_SEMICOLON">TokenTypes_SEMICOLON</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;;&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_SERVER">TokenTypes_SERVER</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 18</pre>
				
			
				<pre>const <span id="TokenTypes_SIP">TokenTypes_SIP</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 3</pre>
				
			
				<pre>const <span id="TokenTypes_SLASH">TokenTypes_SLASH</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;/&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_SP">TokenTypes_SP</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_SP">LexerCore_SP</a></pre>
				
			
				<pre>const <span id="TokenTypes_STAR">TokenTypes_STAR</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_STAR">LexerCore_STAR</a></pre>
				
			
				<pre>const <span id="TokenTypes_START">TokenTypes_START</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_START">LexerCore_START</a></pre>
				
			
				<pre>const <span id="TokenTypes_SUBJECT">TokenTypes_SUBJECT</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 37</pre>
				
			
				<pre>const <span id="TokenTypes_SUBSCRIBE">TokenTypes_SUBSCRIBE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 53</pre>
				
			
				<pre>const <span id="TokenTypes_SUBSCRIPTION_STATE">TokenTypes_SUBSCRIPTION_STATE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 56</pre>
				
			
				<pre>const <span id="TokenTypes_SUPPORTED">TokenTypes_SUPPORTED</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 20</pre>
				
			
				<pre>const <span id="TokenTypes_TEL">TokenTypes_TEL</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 57</pre>
				
			
				<pre>const <span id="TokenTypes_TILDE">TokenTypes_TILDE</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_TILDE">LexerCore_TILDE</a></pre>
				
			
				<pre>const <span id="TokenTypes_TIMESTAMP">TokenTypes_TIMESTAMP</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 55</pre>
				
			
				<pre>const <span id="TokenTypes_TO">TokenTypes_TO</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 15</pre>
				
			
				<pre>const <span id="TokenTypes_UNDERSCORE">TokenTypes_UNDERSCORE</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;_&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_UNSUPPORTED">TokenTypes_UNSUPPORTED</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 28</pre>
				
			
				<pre>const <span id="TokenTypes_USER_AGENT">TokenTypes_USER_AGENT</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 17</pre>
				
			
				<pre>const <span id="TokenTypes_VIA">TokenTypes_VIA</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 16</pre>
				
			
				<pre>const <span id="TokenTypes_WARNING">TokenTypes_WARNING</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 30</pre>
				
			
				<pre>const <span id="TokenTypes_WHITESPACE">TokenTypes_WHITESPACE</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_WHITESPACE">LexerCore_WHITESPACE</a></pre>
				
			
				<pre>const <span id="TokenTypes_WWW_AUTHENTICATE">TokenTypes_WWW_AUTHENTICATE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 48</pre>
				
			
		
		
		
		
			
			
			<h2 id="AcceptEncodingParser">type <a href="/target/AcceptEncodingParser.go?s=795:851#L24">AcceptEncodingParser</a></h2>
			<pre>type AcceptEncodingParser struct {
    <a href="#HeaderParserImpl">HeaderParserImpl</a>
}</pre>
			<p>
*
* Accept-Encoding SIP (HTTP) Header parser.
*
* &lt;pre&gt;
*
*   The Accept-Encoding request-header field is similar to Accept, but
*   restricts the content-codings (section 3.5) that are acceptable in
*   the response.
*
*
*       Accept-Encoding  = &#34;Accept-Encoding&#34; &#34;:&#34;
*                      ( encoding *( &#34;,&#34; encoding) )
*       encoding         = ( codings *[ &#34;;&#34; &#34;q&#34; &#34;=&#34; qvalue ] )
*       codings          = ( content-coding | &#34;*&#34; )
*
*   Examples of its use are:
*
*       Accept-Encoding: compress, gzip
*       Accept-Encoding:
*       Accept-Encoding: *
*       Accept-Encoding: compress;q=0.5, gzip;q=1.0
*       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
* &lt;/pre&gt;
*
</p>


			

			

			

			
				
				<h3 id="NewAcceptEncodingParser">func <a href="/target/AcceptEncodingParser.go?s=927:1000#L31">NewAcceptEncodingParser</a></h3>
				<pre>func NewAcceptEncodingParser(acceptEncoding <a href="/pkg/builtin/#string">string</a>) *<a href="#AcceptEncodingParser">AcceptEncodingParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param String AcceptEncoding message to parse
</pre>

				
			
				
				<h3 id="NewAcceptEncodingParserFromLexer">func <a href="/target/AcceptEncodingParser.go?s=1155:1232#L40">NewAcceptEncodingParserFromLexer</a></h3>
				<pre>func NewAcceptEncodingParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#AcceptEncodingParser">AcceptEncodingParser</a></pre>
				<p>
* Cosntructor
</p>
<pre>* @param Lexer lexer to set
</pre>

				
			

			
				
				<h3 id="AcceptEncodingParser.Parse">func (*AcceptEncodingParser) <a href="/target/AcceptEncodingParser.go?s=1485:1570#L50">Parse</a></h3>
				<pre>func (this *<a href="#AcceptEncodingParser">AcceptEncodingParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#SIPHeader">SIPHeader</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (AcceptEncoding object)
* @throws ParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="AcceptLanguageParser">type <a href="/target/AcceptLanguageParser.go?s=479:535#L18">AcceptLanguageParser</a></h2>
			<pre>type AcceptLanguageParser struct {
    <a href="#HeaderParserImpl">HeaderParserImpl</a>
}</pre>
			

			

			

			

			
				
				<h3 id="NewAcceptLanguageParser">func <a href="/target/AcceptLanguageParser.go?s=611:684#L25">NewAcceptLanguageParser</a></h3>
				<pre>func NewAcceptLanguageParser(acceptLanguage <a href="/pkg/builtin/#string">string</a>) *<a href="#AcceptLanguageParser">AcceptLanguageParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param String AcceptLanguage message to parse
</pre>

				
			
				
				<h3 id="NewAcceptLanguageParserFromLexer">func <a href="/target/AcceptLanguageParser.go?s=839:916#L34">NewAcceptLanguageParserFromLexer</a></h3>
				<pre>func NewAcceptLanguageParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#AcceptLanguageParser">AcceptLanguageParser</a></pre>
				<p>
* Cosntructor
</p>
<pre>* @param Lexer lexer to set
</pre>

				
			

			
				
				<h3 id="AcceptLanguageParser.Parse">func (*AcceptLanguageParser) <a href="/target/AcceptLanguageParser.go?s=1169:1254#L44">Parse</a></h3>
				<pre>func (this *<a href="#AcceptLanguageParser">AcceptLanguageParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#SIPHeader">SIPHeader</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (AcceptLanguage object)
* @throws ParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="AddressParametersParser">type <a href="/target/AddressParametersParser.go?s=103:162#L1">AddressParametersParser</a></h2>
			<pre>type AddressParametersParser struct {
    <a href="#ParametersParser">ParametersParser</a>
}</pre>
			<p>
* Address parameters parser.
</p>


			

			

			

			
				
				<h3 id="NewAddressParametersParser">func <a href="/target/AddressParametersParser.go?s=364:435#L11">NewAddressParametersParser</a></h3>
				<pre>func NewAddressParametersParser(buffer <a href="/pkg/builtin/#string">string</a>) *<a href="#AddressParametersParser">AddressParametersParser</a></pre>
				
				
			
				
				<h3 id="NewAddressParametersParserFromLexer">func <a href="/target/AddressParametersParser.go?s=167:250#L5">NewAddressParametersParserFromLexer</a></h3>
				<pre>func NewAddressParametersParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#AddressParametersParser">AddressParametersParser</a></pre>
				
				
			

			
				
				<h3 id="AddressParametersParser.Parse">func (*AddressParametersParser) <a href="/target/AddressParametersParser.go?s=776:897#L25">Parse</a></h3>
				<pre>func (this *<a href="#AddressParametersParser">AddressParametersParser</a>) Parse(addressParametersHeader <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#AddressParametersHeader">AddressParametersHeader</a>) (ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="AddressParser">type <a href="/target/AddressParser.go?s=111:154#L2">AddressParser</a></h2>
			<pre>type AddressParser struct {
    <a href="#ParserImpl">ParserImpl</a>
}</pre>
			

			

			

			

			
				
				<h3 id="NewAddressParser">func <a href="/target/AddressParser.go?s=167:216#L9">NewAddressParser</a></h3>
				<pre>func NewAddressParser(addr <a href="/pkg/builtin/#string">string</a>) *<a href="#AddressParser">AddressParser</a></pre>
				
				
			
				
				<h3 id="NewAddressParserFromLexer">func <a href="/target/AddressParser.go?s=378:441#L18">NewAddressParserFromLexer</a></h3>
				<pre>func NewAddressParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#AddressParser">AddressParser</a></pre>
				
				
			

			
				
				<h3 id="AddressParser.Address">func (*AddressParser) <a href="/target/AddressParser.go?s=2336:2424#L86">Address</a></h3>
				<pre>func (this *<a href="#AddressParser">AddressParser</a>) Address() (retval *<a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#AddressImpl">AddressImpl</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="AddressParser.NameAddr">func (*AddressParser) <a href="/target/AddressParser.go?s=884:971#L37">NameAddr</a></h3>
				<pre>func (this *<a href="#AddressParser">AddressParser</a>) NameAddr() (addr *<a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#AddressImpl">AddressImpl</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="CSeqParser">type <a href="/target/CSeqParser.go?s=101:147#L1">CSeqParser</a></h2>
			<pre>type CSeqParser struct {
    <a href="#HeaderParserImpl">HeaderParserImpl</a>
}</pre>
			<p>
* Parser for CSeq headers.
</p>


			

			

			

			
				
				<h3 id="NewCSeqParser">func <a href="/target/CSeqParser.go?s=158:201#L5">NewCSeqParser</a></h3>
				<pre>func NewCSeqParser(cseq <a href="/pkg/builtin/#string">string</a>) *<a href="#CSeqParser">CSeqParser</a></pre>
				
				
			
				
				<h3 id="NewCSeqParserFromLexer">func <a href="/target/CSeqParser.go?s=426:483#L15">NewCSeqParserFromLexer</a></h3>
				<pre>func NewCSeqParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#CSeqParser">CSeqParser</a></pre>
				
				
			

			
				
				<h3 id="CSeqParser.Parse">func (*CSeqParser) <a href="/target/CSeqParser.go?s=586:661#L21">Parse</a></h3>
				<pre>func (this *<a href="#CSeqParser">CSeqParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#SIPHeader">SIPHeader</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="CallIDParser">type <a href="/target/CallIdParser.go?s=113:160#L1">CallIDParser</a></h2>
			<pre>type CallIDParser struct {
    <a href="#HeaderParserImpl">HeaderParserImpl</a>
}</pre>
			<p>
* Parser for CALL ID header.
</p>


			

			

			

			
				
				<h3 id="NewCallIDParser">func <a href="/target/CallIdParser.go?s=262:311#L7">NewCallIDParser</a></h3>
				<pre>func NewCallIDParser(callId <a href="/pkg/builtin/#string">string</a>) *<a href="#CallIDParser">CallIDParser</a></pre>
				<p>
* Creates new CallIDParser
</p>
<pre>* @param String callID message to parse to set
</pre>

				
			
				
				<h3 id="NewCallIDParserFromLexer">func <a href="/target/CallIdParser.go?s=622:683#L22">NewCallIDParserFromLexer</a></h3>
				<pre>func NewCallIDParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#CallIDParser">CallIDParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param Lexer lexer to set
</pre>

				
			

			
				
				<h3 id="CallIDParser.Parse">func (*CallIDParser) <a href="/target/CallIdParser.go?s=1001:1078#L34">Parse</a></h3>
				<pre>func (this *<a href="#CallIDParser">CallIDParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#SIPHeader">SIPHeader</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (CallID object)
* @throws ParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="ContactParser">type <a href="/target/ContactParser.go?s=119:175#L3">ContactParser</a></h2>
			<pre>type ContactParser struct {
    <a href="#AddressParametersParser">AddressParametersParser</a>
}</pre>
			

			

			

			

			
				
				<h3 id="NewContactParser">func <a href="/target/ContactParser.go?s=184:236#L7">NewContactParser</a></h3>
				<pre>func NewContactParser(contact <a href="/pkg/builtin/#string">string</a>) *<a href="#ContactParser">ContactParser</a></pre>
				
				
			
				
				<h3 id="NewContactParserFromLexer">func <a href="/target/ContactParser.go?s=342:405#L13">NewContactParserFromLexer</a></h3>
				<pre>func NewContactParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ContactParser">ContactParser</a></pre>
				
				
			

			
				
				<h3 id="ContactParser.Parse">func (*ContactParser) <a href="/target/ContactParser.go?s=518:596#L19">Parse</a></h3>
				<pre>func (this *<a href="#ContactParser">ContactParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#SIPHeader">SIPHeader</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="FromParser">type <a href="/target/FromParser.go?s=114:167#L2">FromParser</a></h2>
			<pre>type FromParser struct {
    <a href="#AddressParametersParser">AddressParametersParser</a>
}</pre>
			

			

			

			

			
				
				<h3 id="NewFromParser">func <a href="/target/FromParser.go?s=176:219#L6">NewFromParser</a></h3>
				<pre>func NewFromParser(from <a href="/pkg/builtin/#string">string</a>) *<a href="#FromParser">FromParser</a></pre>
				
				
			
				
				<h3 id="NewFromParserFromLexer">func <a href="/target/FromParser.go?s=418:475#L16">NewFromParserFromLexer</a></h3>
				<pre>func NewFromParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#FromParser">FromParser</a></pre>
				
				
			

			
				
				<h3 id="FromParser.Parse">func (*FromParser) <a href="/target/FromParser.go?s=586:661#L22">Parse</a></h3>
				<pre>func (this *<a href="#FromParser">FromParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#SIPHeader">SIPHeader</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="HeaderParser">type <a href="/target/HeaderParser.go?s=77:165#L1">HeaderParser</a></h2>
			<pre>type HeaderParser interface {
    Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#SIPHeader">SIPHeader</a>, ParseException <a href="/pkg/builtin/#error">error</a>)
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="HeaderParserImpl">type <a href="/target/HeaderParser.go?s=356:402#L8">HeaderParserImpl</a></h2>
			<pre>type HeaderParserImpl struct {
    <a href="#ParserImpl">ParserImpl</a>
}</pre>
			

			

			

			

			
				
				<h3 id="NewHeaderParserImpl">func <a href="/target/HeaderParser.go?s=491:548#L15">NewHeaderParserImpl</a></h3>
				<pre>func NewHeaderParserImpl(header <a href="/pkg/builtin/#string">string</a>) *<a href="#HeaderParserImpl">HeaderParserImpl</a></pre>
				<p>
* Creates new HeaderParser
</p>
<pre>* @param String to parse.
</pre>

				
			
				
				<h3 id="NewHeaderParserImplFromLexer">func <a href="/target/HeaderParser.go?s=750:819#L24">NewHeaderParserImplFromLexer</a></h3>
				<pre>func NewHeaderParserImplFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#HeaderParserImpl">HeaderParserImpl</a></pre>
				
				
			

			
				
				<h3 id="HeaderParserImpl.HeaderName">func (*HeaderParserImpl) <a href="/target/HeaderParser.go?s=6392:6441#L170">HeaderName</a></h3>
				<pre>func (this *<a href="#HeaderParserImpl">HeaderParserImpl</a>) HeaderName(tok <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
* Parse the header name until the colon  and chew WS after that.
</p>

				
				
			
				
				<h3 id="HeaderParserImpl.Parse">func (*HeaderParserImpl) <a href="/target/HeaderParser.go?s=5795:5876#L154">Parse</a></h3>
				<pre>func (this *<a href="#HeaderParserImpl">HeaderParserImpl</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#SIPHeader">SIPHeader</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Parse the SIP header from the buffer and return a parsed
</p>
<pre>* structure.
*@throws ParseException if there was an error parsing.
</pre>

				
				
			
				
				<h3 id="HeaderParserImpl.Wkday">func (*HeaderParserImpl) <a href="/target/HeaderParser.go?s=1487:1556#L46">Wkday</a></h3>
				<pre>func (this *<a href="#HeaderParserImpl">HeaderParserImpl</a>) Wkday() (wk <a href="/pkg/builtin/#int">int</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Parse the weekday field
</p>
<pre>* @return an integer with the calendar content for wkday.
</pre>

				
				
			
		
			
			
			<h2 id="LexerImpl">type <a href="/target/LexerImpl.go?s=101:144#L2">LexerImpl</a></h2>
			<pre>type LexerImpl struct {
    <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore">LexerCore</a>
}</pre>
			

			

			

			

			
				
				<h3 id="NewLexerImpl">func <a href="/target/LexerImpl.go?s=152:206#L6">NewLexerImpl</a></h3>
				<pre>func NewLexerImpl(lexerName, buffer <a href="/pkg/builtin/#string">string</a>) *<a href="#LexerImpl">LexerImpl</a></pre>
				
				
			

			
				
				<h3 id="LexerImpl.GetHeaderName">func (*LexerImpl) <a href="/target/LexerImpl.go?s=575:632#L23">GetHeaderName</a></h3>
				<pre>func (this *<a href="#LexerImpl">LexerImpl</a>) GetHeaderName(line <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#string">string</a></pre>
				<p>
* get the header name of the line
</p>
<pre>*  @return String
</pre>

				
				
			
				
				<h3 id="LexerImpl.GetHeaderValue">func (*LexerImpl) <a href="/target/LexerImpl.go?s=1192:1250#L45">GetHeaderValue</a></h3>
				<pre>func (this *<a href="#LexerImpl">LexerImpl</a>) GetHeaderValue(line <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#string">string</a></pre>
				<p>
* get the header value of the line
</p>
<pre>*  @return String
</pre>

				
				
			
				
				<h3 id="LexerImpl.SelectLexer">func (*LexerImpl) <a href="/target/LexerImpl.go?s=1628:1681#L59">SelectLexer</a></h3>
				<pre>func (this *<a href="#LexerImpl">LexerImpl</a>) SelectLexer(lexerName <a href="/pkg/builtin/#string">string</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="MaxForwardsParser">type <a href="/target/MaxForwardsParser.go?s=104:157#L1">MaxForwardsParser</a></h2>
			<pre>type MaxForwardsParser struct {
    <a href="#HeaderParserImpl">HeaderParserImpl</a>
}</pre>
			<p>
* Parser for Max Forwards Header.
</p>


			

			

			

			
				
				<h3 id="NewMaxForwardsParser">func <a href="/target/MaxForwardsParser.go?s=168:234#L3">NewMaxForwardsParser</a></h3>
				<pre>func NewMaxForwardsParser(contentLength <a href="/pkg/builtin/#string">string</a>) *<a href="#MaxForwardsParser">MaxForwardsParser</a></pre>
				
				
			
				
				<h3 id="NewMaxForwardsParserFromLexer">func <a href="/target/MaxForwardsParser.go?s=371:442#L9">NewMaxForwardsParserFromLexer</a></h3>
				<pre>func NewMaxForwardsParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#MaxForwardsParser">MaxForwardsParser</a></pre>
				
				
			

			
				
				<h3 id="MaxForwardsParser.Parse">func (*MaxForwardsParser) <a href="/target/MaxForwardsParser.go?s=675:757#L19">Parse</a></h3>
				<pre>func (this *<a href="#MaxForwardsParser">MaxForwardsParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#SIPHeader">SIPHeader</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="ParametersParser">type <a href="/target/ParametersParser.go?s=102:154#L1">ParametersParser</a></h2>
			<pre>type ParametersParser struct {
    <a href="#HeaderParserImpl">HeaderParserImpl</a>
}</pre>
			<p>
* parameters parser header.
</p>


			

			

			

			
				
				<h3 id="NewParametersParser">func <a href="/target/ParametersParser.go?s=333:390#L11">NewParametersParser</a></h3>
				<pre>func NewParametersParser(buffer <a href="/pkg/builtin/#string">string</a>) *<a href="#ParametersParser">ParametersParser</a></pre>
				
				
			
				
				<h3 id="NewParametersParserFromLexer">func <a href="/target/ParametersParser.go?s=159:228#L5">NewParametersParserFromLexer</a></h3>
				<pre>func NewParametersParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ParametersParser">ParametersParser</a></pre>
				
				
			

			
				
				<h3 id="ParametersParser.Parse">func (*ParametersParser) <a href="/target/ParametersParser.go?s=718:818#L25">Parse</a></h3>
				<pre>func (this *<a href="#ParametersParser">ParametersParser</a>) Parse(parametersHeader <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ParametersHeader">ParametersHeader</a>) (ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="ParserImpl">type <a href="/target/ParserImpl.go?s=6363:6434#L117">ParserImpl</a></h2>
			<pre>type ParserImpl struct {
    <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#ParserCore">ParserCore</a> <span class="comment">//implements TokenTypes {</span>
}</pre>
			

			

			

			

			
				
				<h3 id="NewParserImpl">func <a href="/target/ParserImpl.go?s=6438:6483#L121">NewParserImpl</a></h3>
				<pre>func NewParserImpl(buffer <a href="/pkg/builtin/#string">string</a>) *<a href="#ParserImpl">ParserImpl</a></pre>
				
				
			

			
				
				<h3 id="ParserImpl.CreateParseException">func (*ParserImpl) <a href="/target/ParserImpl.go?s=6786:6877#L136">CreateParseException</a></h3>
				<pre>func (this *<a href="#ParserImpl">ParserImpl</a>) CreateParseException(exceptionString <a href="/pkg/builtin/#string">string</a>) (ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="ParserImpl.Method">func (*ParserImpl) <a href="/target/ParserImpl.go?s=7823:7888#L170">Method</a></h3>
				<pre>func (this *<a href="#ParserImpl">ParserImpl</a>) Method() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parses a method. Consumes if a valid method has been found.
</p>

				
				
			
				
				<h3 id="ParserImpl.SipVersion">func (*ParserImpl) <a href="/target/ParserImpl.go?s=7101:7170#L145">SipVersion</a></h3>
				<pre>func (this *<a href="#ParserImpl">ParserImpl</a>) SipVersion() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="ToParser">type <a href="/target/ToParser.go?s=109:160#L1">ToParser</a></h2>
			<pre>type ToParser struct {
    <a href="#AddressParametersParser">AddressParametersParser</a>
}</pre>
			<p>
To Header parser.
</p>


			

			

			

			
				
				<h3 id="NewToParser">func <a href="/target/ToParser.go?s=240:277#L8">NewToParser</a></h3>
				<pre>func NewToParser(to <a href="/pkg/builtin/#string">string</a>) *<a href="#ToParser">ToParser</a></pre>
				<p>
* Creates new ToParser
</p>
<pre>* @param String to set
</pre>

				
			
				
				<h3 id="NewToParserFromLexer">func <a href="/target/ToParser.go?s=384:437#L14">NewToParserFromLexer</a></h3>
				<pre>func NewToParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ToParser">ToParser</a></pre>
				
				
			

			
				
				<h3 id="ToParser.Parse">func (*ToParser) <a href="/target/ToParser.go?s=551:624#L20">Parse</a></h3>
				<pre>func (this *<a href="#ToParser">ToParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#SIPHeader">SIPHeader</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="URLParser">type <a href="/target/URLParser.go?s=177:215#L3">URLParser</a></h2>
			<pre>type URLParser struct {
    <a href="#ParserImpl">ParserImpl</a>
}</pre>
			<p>
* Parser For SIP and Tel URLs. Other kinds of URL&#39;s are handled by the
</p>


			

			

			

			
				
				<h3 id="NewURLParser">func <a href="/target/URLParser.go?s=225:265#L8">NewURLParser</a></h3>
				<pre>func NewURLParser(url <a href="/pkg/builtin/#string">string</a>) *<a href="#URLParser">URLParser</a></pre>
				
				
			
				
				<h3 id="NewURLParserFromLexer">func <a href="/target/URLParser.go?s=400:455#L14">NewURLParserFromLexer</a></h3>
				<pre>func NewURLParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#URLParser">URLParser</a></pre>
				
				
			

			
				
				<h3 id="URLParser.Base_phone_number">func (*URLParser) <a href="/target/URLParser.go?s=10381:10456#L311">Base_phone_number</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Base_phone_number() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Parser for the base phone number.
</p>

				
				
			
				
				<h3 id="URLParser.Escaped">func (*URLParser) <a href="/target/URLParser.go?s=4908:4973#L156">Escaped</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Escaped() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.Global_phone_number">func (*URLParser) <a href="/target/URLParser.go?s=13135:13228#L394">Global_phone_number</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Global_phone_number() (tn *<a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#TelephoneNumber">TelephoneNumber</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.Hvalue">func (*URLParser) <a href="/target/URLParser.go?s=19932:19996#L578">Hvalue</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Hvalue() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.IsEscaped">func (*URLParser) <a href="/target/URLParser.go?s=4480:4519#L145">IsEscaped</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) IsEscaped() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="URLParser.IsMark">func (*URLParser) <a href="/target/URLParser.go?s=790:835#L24">IsMark</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) IsMark(next <a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="URLParser.IsReserved">func (*URLParser) <a href="/target/URLParser.go?s=3773:3822#L120">IsReserved</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) IsReserved(next <a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="URLParser.IsReservedNoSlash">func (*URLParser) <a href="/target/URLParser.go?s=1242:1298#L41">IsReservedNoSlash</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) IsReservedNoSlash(next <a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="URLParser.IsUnreserved">func (*URLParser) <a href="/target/URLParser.go?s=1072:1123#L36">IsUnreserved</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) IsUnreserved(next <a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="URLParser.IsUserUnreserved">func (*URLParser) <a href="/target/URLParser.go?s=1638:1691#L54">IsUserUnreserved</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) IsUserUnreserved(la <a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Missing &#39;=&#39; bug in character set - discovered by interop testing
at SIPIT 13 by Bob Johnson and Scott Holben.
</p>

				
				
			
				
				<h3 id="URLParser.Local_number">func (*URLParser) <a href="/target/URLParser.go?s=11287:11357#L338">Local_number</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Local_number() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Parser for the local phone #.
</p>

				
				
			
				
				<h3 id="URLParser.Local_phone_number">func (*URLParser) <a href="/target/URLParser.go?s=13958:14049#L417">Local_phone_number</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Local_phone_number() (tn *<a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#TelephoneNumber">TelephoneNumber</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.Mark">func (*URLParser) <a href="/target/URLParser.go?s=5769:5831#L179">Mark</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Mark() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.ParamNameOrValue">func (*URLParser) <a href="/target/URLParser.go?s=2372:2446#L81">ParamNameOrValue</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) ParamNameOrValue() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Name or value of a parameter.
</p>

				
				
			
				
				<h3 id="URLParser.Parse">func (*URLParser) <a href="/target/URLParser.go?s=23343:23413#L671">Parse</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Parse() (url <a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#URI">URI</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.ParseTelephoneNumber">func (*URLParser) <a href="/target/URLParser.go?s=12270:12364#L370">ParseTelephoneNumber</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) ParseTelephoneNumber() (tn *<a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#TelephoneNumber">TelephoneNumber</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Parser for telephone subscriber.
</p>
<pre>*
*@return the parsed telephone number.
</pre>

				
				
			
				
				<h3 id="URLParser.Password">func (*URLParser) <a href="/target/URLParser.go?s=22581:22648#L649">Password</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Password() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.PeekScheme">func (*URLParser) <a href="/target/URLParser.go?s=19307:19375#L558">PeekScheme</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) PeekScheme() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.Qheader">func (*URLParser) <a href="/target/URLParser.go?s=19655:19730#L570">Qheader</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Qheader() (nv *<a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#NameValue">NameValue</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Get a name value for a given query header (ie one that comes
</p>
<pre>* after the ?).
</pre>

				
				
			
				
				<h3 id="URLParser.Reserved">func (*URLParser) <a href="/target/URLParser.go?s=4062:4128#L133">Reserved</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Reserved() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.SipURL">func (*URLParser) <a href="/target/URLParser.go?s=16011:16089#L483">SipURL</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) SipURL() (sipurl *<a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#SipUri">SipUri</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.TelURL">func (*URLParser) <a href="/target/URLParser.go?s=15508:15590#L468">TelURL</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) TelURL() (telUrl *<a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#TelURLImpl">TelURLImpl</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Parse and return a structure for a Tel URL.
</p>
<pre>*@return a parsed tel url structure.
</pre>

				
				
			
				
				<h3 id="URLParser.Tel_parameters">func (*URLParser) <a href="/target/URLParser.go?s=14939:15026#L446">Tel_parameters</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Tel_parameters() (nvl *<a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#NameValueList">NameValueList</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.Unreserved">func (*URLParser) <a href="/target/URLParser.go?s=1898:1966#L66">Unreserved</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Unreserved() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.UriParam">func (*URLParser) <a href="/target/URLParser.go?s=3152:3228#L102">UriParam</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) UriParam() (nv *<a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#NameValue">NameValue</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.UriReference">func (*URLParser) <a href="/target/URLParser.go?s=8826:8903#L269">UriReference</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) UriReference() (url <a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#URI">URI</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Parse and return a structure for a generic URL.
</p>
<pre>* Note that non SIP URLs are just stored as a string (not parsed).
*@return URI is a URL structure for a SIP url.
*@throws ParsException if there was a problem parsing.
</pre>

				
				
			
				
				<h3 id="URLParser.Uric">func (*URLParser) <a href="/target/URLParser.go?s=6350:6386#L196">Uric</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Uric() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
			
				
				<h3 id="URLParser.UricNoSlash">func (*URLParser) <a href="/target/URLParser.go?s=7298:7341#L223">UricNoSlash</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) UricNoSlash() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
			
				
				<h3 id="URLParser.UricString">func (*URLParser) <a href="/target/URLParser.go?s=8280:8322#L250">UricString</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) UricString() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
			
				
				<h3 id="URLParser.UrlString">func (*URLParser) <a href="/target/URLParser.go?s=21092:21159#L605">UrlString</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) UrlString() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Scan forward until you hit a terminating character for a URL.
</p>
<pre>* We do not handle non sip urls in this implementation.
*@return the string that takes us to the end of this URL (i.e. to
* the next delimiter).
</pre>

				
				
			
				
				<h3 id="URLParser.User">func (*URLParser) <a href="/target/URLParser.go?s=21731:21793#L623">User</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) User() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="ViaParser">type <a href="/target/ViaParser.go?s=121:166#L2">ViaParser</a></h2>
			<pre>type ViaParser struct {
    <a href="#HeaderParserImpl">HeaderParserImpl</a>
}</pre>
			<p>
* Parser for via headers.
</p>


			

			

			

			
				
				<h3 id="NewViaParser">func <a href="/target/ViaParser.go?s=170:210#L6">NewViaParser</a></h3>
				<pre>func NewViaParser(via <a href="/pkg/builtin/#string">string</a>) *<a href="#ViaParser">ViaParser</a></pre>
				
				
			
				
				<h3 id="NewViaParserFromLexer">func <a href="/target/ViaParser.go?s=291:346#L12">NewViaParserFromLexer</a></h3>
				<pre>func NewViaParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ViaParser">ViaParser</a></pre>
				
				
			

			
				
				<h3 id="ViaParser.NameValue">func (*ViaParser) <a href="/target/ViaParser.go?s=2613:2690#L109">NameValue</a></h3>
				<pre>func (this *<a href="#ViaParser">ViaParser</a>) NameValue() (nv *<a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#NameValue">NameValue</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="ViaParser.Parse">func (*ViaParser) <a href="/target/ViaParser.go?s=3818:3892#L159">Parse</a></h3>
				<pre>func (this *<a href="#ViaParser">ViaParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#SIPHeader">SIPHeader</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="ViaParser.ParseVia">func (*ViaParser) <a href="/target/ViaParser.go?s=500:569#L20">ParseVia</a></h3>
				<pre>func (this *<a href="#ViaParser">ViaParser</a>) ParseVia(v *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Via">Via</a>) (ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
*  a parser for the essential part of the via header.
</p>

				
				
			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		<tr>
		<td><a href="..">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="test/">test</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
	</table>
	

