<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "gosip/parser"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				
			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
			
			
				
				<dd><a href="#AcceptEncodingParser">type AcceptEncodingParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAcceptEncodingParser">func NewAcceptEncodingParser(acceptEncoding string) *AcceptEncodingParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAcceptEncodingParserFromLexer">func NewAcceptEncodingParserFromLexer(lexer core.Lexer) *AcceptEncodingParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AcceptEncodingParser.Parse">func (this *AcceptEncodingParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#AcceptLanguageParser">type AcceptLanguageParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAcceptLanguageParser">func NewAcceptLanguageParser(acceptLanguage string) *AcceptLanguageParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAcceptLanguageParserFromLexer">func NewAcceptLanguageParserFromLexer(lexer core.Lexer) *AcceptLanguageParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AcceptLanguageParser.Parse">func (this *AcceptLanguageParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#AcceptParser">type AcceptParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAcceptParser">func NewAcceptParser(accept string) *AcceptParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAcceptParserFromLexer">func NewAcceptParserFromLexer(lexer core.Lexer) *AcceptParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AcceptParser.Parse">func (this *AcceptParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#AddressParametersParser">type AddressParametersParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAddressParametersParser">func NewAddressParametersParser(buffer string) *AddressParametersParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAddressParametersParserFromLexer">func NewAddressParametersParserFromLexer(lexer core.Lexer) *AddressParametersParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AddressParametersParser.Parse">func (this *AddressParametersParser) Parse(addressParametersHeader header.AddressParametersHeader) (ParseException error)</a></dd>
				
			
				
				<dd><a href="#AddressParser">type AddressParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAddressParser">func NewAddressParser(addr string) *AddressParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAddressParserFromLexer">func NewAddressParserFromLexer(lexer core.Lexer) *AddressParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AddressParser.Address">func (this *AddressParser) Address() (retval *address.AddressImpl, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AddressParser.NameAddr">func (this *AddressParser) NameAddr() (addr *address.AddressImpl, ParseException error)</a></dd>
				
			
				
				<dd><a href="#AlertInfoParser">type AlertInfoParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAlertInfoParser">func NewAlertInfoParser(alertInfo string) *AlertInfoParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAlertInfoParserFromLexer">func NewAlertInfoParserFromLexer(lexer core.Lexer) *AlertInfoParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AlertInfoParser.Parse">func (this *AlertInfoParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#AllowEventsParser">type AllowEventsParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAllowEventsParser">func NewAllowEventsParser(allowEvents string) *AllowEventsParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAllowEventsParserFromLexer">func NewAllowEventsParserFromLexer(lexer core.Lexer) *AllowEventsParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AllowEventsParser.Parse">func (this *AllowEventsParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#AllowParser">type AllowParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAllowParser">func NewAllowParser(allow string) *AllowParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAllowParserFromLexer">func NewAllowParserFromLexer(lexer core.Lexer) *AllowParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AllowParser.Parse">func (this *AllowParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#AuthenticationInfoParser">type AuthenticationInfoParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAuthenticationInfoParser">func NewAuthenticationInfoParser(authenticationInfo string) *AuthenticationInfoParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAuthenticationInfoParserFromLexer">func NewAuthenticationInfoParserFromLexer(lexer core.Lexer) *AuthenticationInfoParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AuthenticationInfoParser.Parse">func (this *AuthenticationInfoParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#AuthorizationParser">type AuthorizationParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAuthorizationParser">func NewAuthorizationParser(authorization string) *AuthorizationParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAuthorizationParserFromLexer">func NewAuthorizationParserFromLexer(lexer core.Lexer) *AuthorizationParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AuthorizationParser.Parse">func (this *AuthorizationParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#CSeqParser">type CSeqParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCSeqParser">func NewCSeqParser(cseq string) *CSeqParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCSeqParserFromLexer">func NewCSeqParserFromLexer(lexer core.Lexer) *CSeqParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CSeqParser.Parse">func (this *CSeqParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#CallIDParser">type CallIDParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCallIDParser">func NewCallIDParser(callId string) *CallIDParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCallIDParserFromLexer">func NewCallIDParserFromLexer(lexer core.Lexer) *CallIDParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CallIDParser.Parse">func (this *CallIDParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#CallInfoParser">type CallInfoParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCallInfoParser">func NewCallInfoParser(callInfo string) *CallInfoParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCallInfoParserFromLexer">func NewCallInfoParserFromLexer(lexer core.Lexer) *CallInfoParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CallInfoParser.Parse">func (this *CallInfoParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ChallengeParser">type ChallengeParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewChallengeParser">func NewChallengeParser(challenge string) *ChallengeParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewChallengeParserFromLexer">func NewChallengeParserFromLexer(lexer core.Lexer) *ChallengeParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ChallengeParser.Parse">func (this *ChallengeParser) Parse(h header.AuthorizationHeader) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ChallengeParser.ParseParameter">func (this *ChallengeParser) ParseParameter(h header.AuthorizationHeader)</a></dd>
				
			
				
				<dd><a href="#ContactParser">type ContactParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewContactParser">func NewContactParser(contact string) *ContactParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewContactParserFromLexer">func NewContactParserFromLexer(lexer core.Lexer) *ContactParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ContactParser.Parse">func (this *ContactParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ContentDispositionParser">type ContentDispositionParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewContentDispositionParser">func NewContentDispositionParser(contentDisposition string) *ContentDispositionParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewContentDispositionParserFromLexer">func NewContentDispositionParserFromLexer(lexer core.Lexer) *ContentDispositionParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ContentDispositionParser.Parse">func (this *ContentDispositionParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ContentEncodingParser">type ContentEncodingParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewContentEncodingParser">func NewContentEncodingParser(contentEncoding string) *ContentEncodingParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewContentEncodingParserFromLexer">func NewContentEncodingParserFromLexer(lexer core.Lexer) *ContentEncodingParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ContentEncodingParser.Parse">func (this *ContentEncodingParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ContentLanguageParser">type ContentLanguageParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewContentLanguageParser">func NewContentLanguageParser(contentLanguage string) *ContentLanguageParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewContentLanguageParserFromLexer">func NewContentLanguageParserFromLexer(lexer core.Lexer) *ContentLanguageParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ContentLanguageParser.Parse">func (this *ContentLanguageParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ContentLengthParser">type ContentLengthParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewContentLengthParser">func NewContentLengthParser(contentLength string) *ContentLengthParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewContentLengthParserFromLexer">func NewContentLengthParserFromLexer(lexer core.Lexer) *ContentLengthParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ContentLengthParser.Parse">func (this *ContentLengthParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ContentTypeParser">type ContentTypeParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewContentTypeParser">func NewContentTypeParser(contentType string) *ContentTypeParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewContentTypeParserFromLexer">func NewContentTypeParserFromLexer(lexer core.Lexer) *ContentTypeParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ContentTypeParser.Parse">func (this *ContentTypeParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#DateParser">type DateParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewDateParser">func NewDateParser(date string) *DateParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewDateParserFromLexer">func NewDateParserFromLexer(lexer core.Lexer) *DateParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DateParser.Parse">func (this *DateParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ErrorInfoParser">type ErrorInfoParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewErrorInfoParser">func NewErrorInfoParser(errorInfo string) *ErrorInfoParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewErrorInfoParserFromLexer">func NewErrorInfoParserFromLexer(lexer core.Lexer) *ErrorInfoParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ErrorInfoParser.Parse">func (this *ErrorInfoParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#EventParser">type EventParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewEventParser">func NewEventParser(event string) *EventParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewEventParserFromLexer">func NewEventParserFromLexer(lexer core.Lexer) *EventParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EventParser.Parse">func (this *EventParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ExpiresParser">type ExpiresParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewExpiresParser">func NewExpiresParser(text string) *ExpiresParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewExpiresParserFromLexer">func NewExpiresParserFromLexer(lexer core.Lexer) *ExpiresParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ExpiresParser.Parse">func (this *ExpiresParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#FromParser">type FromParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFromParser">func NewFromParser(from string) *FromParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFromParserFromLexer">func NewFromParserFromLexer(lexer core.Lexer) *FromParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FromParser.Parse">func (this *FromParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#HeaderParser">type HeaderParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewHeaderParser">func NewHeaderParser(header string) *HeaderParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewHeaderParserFromLexer">func NewHeaderParserFromLexer(lexer core.Lexer) *HeaderParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#HeaderParser.HeaderName">func (this *HeaderParser) HeaderName(tok int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#HeaderParser.Parse">func (this *HeaderParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#IHeaderParser">type IHeaderParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CreateParser">func CreateParser(line string) IHeaderParser</a></dd>
				
				
			
				
				<dd><a href="#InReplyToParser">type InReplyToParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewInReplyToParser">func NewInReplyToParser(inReplyTo string) *InReplyToParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewInReplyToParserFromLexer">func NewInReplyToParserFromLexer(lexer core.Lexer) *InReplyToParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#InReplyToParser.Parse">func (this *InReplyToParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#Lexer">type Lexer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewLexer">func NewLexer(lexerName, buffer string) *Lexer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Lexer.GetHeaderName">func (this *Lexer) GetHeaderName(line string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Lexer.GetHeaderValue">func (this *Lexer) GetHeaderValue(line string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Lexer.SelectLexer">func (this *Lexer) SelectLexer(lexerName string)</a></dd>
				
			
				
				<dd><a href="#MaxForwardsParser">type MaxForwardsParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMaxForwardsParser">func NewMaxForwardsParser(contentLength string) *MaxForwardsParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMaxForwardsParserFromLexer">func NewMaxForwardsParserFromLexer(lexer core.Lexer) *MaxForwardsParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MaxForwardsParser.Parse">func (this *MaxForwardsParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#MimeVersionParser">type MimeVersionParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMimeVersionParser">func NewMimeVersionParser(mimeVersion string) *MimeVersionParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMimeVersionParserFromLexer">func NewMimeVersionParserFromLexer(lexer core.Lexer) *MimeVersionParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MimeVersionParser.Parse">func (this *MimeVersionParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#MinExpiresParser">type MinExpiresParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMinExpiresParser">func NewMinExpiresParser(minExpires string) *MinExpiresParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMinExpiresParserFromLexer">func NewMinExpiresParserFromLexer(lexer core.Lexer) *MinExpiresParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MinExpiresParser.Parse">func (this *MinExpiresParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#OrganizationParser">type OrganizationParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewOrganizationParser">func NewOrganizationParser(organization string) *OrganizationParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewOrganizationParserFromLexer">func NewOrganizationParserFromLexer(lexer core.Lexer) *OrganizationParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#OrganizationParser.Parse">func (this *OrganizationParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ParametersParser">type ParametersParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewParametersParser">func NewParametersParser(buffer string) *ParametersParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewParametersParserFromLexer">func NewParametersParserFromLexer(lexer core.Lexer) *ParametersParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ParametersParser.Parse">func (this *ParametersParser) Parse(parametersHeader header.ParametersHeader) (ParseException error)</a></dd>
				
			
				
				<dd><a href="#Parser">type Parser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewParser">func NewParser(buffer string) *Parser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Parser.CreateParseException">func (this *Parser) CreateParseException(exceptionString string) (ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Parser.Method">func (this *Parser) Method() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Parser.SipVersion">func (this *Parser) SipVersion() (s string, ParseException error)</a></dd>
				
			
				
				<dd><a href="#PriorityParser">type PriorityParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewPriorityParser">func NewPriorityParser(priority string) *PriorityParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewPriorityParserFromLexer">func NewPriorityParserFromLexer(lexer core.Lexer) *PriorityParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PriorityParser.Parse">func (this *PriorityParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ProxyAuthenticateParser">type ProxyAuthenticateParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewProxyAuthenticateParser">func NewProxyAuthenticateParser(proxyAuthenticate string) *ProxyAuthenticateParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewProxyAuthenticateParserFromLexer">func NewProxyAuthenticateParserFromLexer(lexer core.Lexer) *ProxyAuthenticateParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ProxyAuthenticateParser.Parse">func (this *ProxyAuthenticateParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ProxyAuthorizationParser">type ProxyAuthorizationParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewProxyAuthorizationParser">func NewProxyAuthorizationParser(proxyAuthorization string) *ProxyAuthorizationParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewProxyAuthorizationParserFromLexer">func NewProxyAuthorizationParserFromLexer(lexer core.Lexer) *ProxyAuthorizationParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ProxyAuthorizationParser.Parse">func (this *ProxyAuthorizationParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ProxyRequireParser">type ProxyRequireParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewProxyRequireParser">func NewProxyRequireParser(require string) *ProxyRequireParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewProxyRequireParserFromLexer">func NewProxyRequireParserFromLexer(lexer core.Lexer) *ProxyRequireParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ProxyRequireParser.Parse">func (this *ProxyRequireParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#RAckParser">type RAckParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRAckParser">func NewRAckParser(rack string) *RAckParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRAckParserFromLexer">func NewRAckParserFromLexer(lexer core.Lexer) *RAckParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RAckParser.Parse">func (this *RAckParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#RSeqParser">type RSeqParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRSeqParser">func NewRSeqParser(rseq string) *RSeqParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRSeqParserFromLexer">func NewRSeqParserFromLexer(lexer core.Lexer) *RSeqParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RSeqParser.Parse">func (this *RSeqParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ReasonParser">type ReasonParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReasonParser">func NewReasonParser(reason string) *ReasonParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReasonParserFromLexer">func NewReasonParserFromLexer(lexer core.Lexer) *ReasonParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ReasonParser.Parse">func (this *ReasonParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#RecordRouteParser">type RecordRouteParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRecordRouteParser">func NewRecordRouteParser(recordRoute string) *RecordRouteParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRecordRouteParserFromLexer">func NewRecordRouteParserFromLexer(lexer core.Lexer) *RecordRouteParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RecordRouteParser.Parse">func (this *RecordRouteParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ReferToParser">type ReferToParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReferToParser">func NewReferToParser(referTo string) *ReferToParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReferToParserFromLexer">func NewReferToParserFromLexer(lexer core.Lexer) *ReferToParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ReferToParser.Parse">func (this *ReferToParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ReplyToParser">type ReplyToParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReplyToParser">func NewReplyToParser(replyTo string) *ReplyToParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReplyToParserFromLexer">func NewReplyToParserFromLexer(lexer core.Lexer) *ReplyToParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ReplyToParser.Parse">func (this *ReplyToParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#RequestLineParser">type RequestLineParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRequestLineParser">func NewRequestLineParser(requestLine string) *RequestLineParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRequestLineParserFromLexer">func NewRequestLineParserFromLexer(lexer core.Lexer) *RequestLineParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RequestLineParser.Parse">func (this *RequestLineParser) Parse() (rl *header.RequestLine, ParseException error)</a></dd>
				
			
				
				<dd><a href="#RequireParser">type RequireParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRequireParser">func NewRequireParser(require string) *RequireParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRequireParserFromLexer">func NewRequireParserFromLexer(lexer core.Lexer) *RequireParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RequireParser.Parse">func (this *RequireParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#RetryAfterParser">type RetryAfterParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRetryAfterParser">func NewRetryAfterParser(retryAfter string) *RetryAfterParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRetryAfterParserFromLexer">func NewRetryAfterParserFromLexer(lexer core.Lexer) *RetryAfterParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RetryAfterParser.Parse">func (this *RetryAfterParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#RouteParser">type RouteParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRouteParser">func NewRouteParser(route string) *RouteParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRouteParserFromLexer">func NewRouteParserFromLexer(lexer core.Lexer) *RouteParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RouteParser.Parse">func (this *RouteParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ServerParser">type ServerParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewServerParser">func NewServerParser(server string) *ServerParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewServerParserFromLexer">func NewServerParserFromLexer(lexer core.Lexer) *ServerParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ServerParser.Parse">func (this *ServerParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#StatusLineParser">type StatusLineParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewStatusLineParser">func NewStatusLineParser(statusLine string) *StatusLineParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewStatusLineParserFromLexer">func NewStatusLineParserFromLexer(lexer core.Lexer) *StatusLineParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#StatusLineParser.Parse">func (this *StatusLineParser) Parse() (sl *header.StatusLine, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StatusLineParser.ReasonPhrase">func (this *StatusLineParser) ReasonPhrase() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StatusLineParser.StatusCode">func (this *StatusLineParser) StatusCode() (scode int, ParseException error)</a></dd>
				
			
				
				<dd><a href="#StringMsgParser">type StringMsgParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewStringMsgParser">func NewStringMsgParser() *StringMsgParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.GetBodyAsBytes">func (this *StringMsgParser) GetBodyAsBytes() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.GetCurrentHeader">func (this *StringMsgParser) GetCurrentHeader() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.GetCurrentLineNumber">func (this *StringMsgParser) GetCurrentLineNumber() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.GetMessageBody">func (this *StringMsgParser) GetMessageBody() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.IsBodyString">func (this *StringMsgParser) IsBodyString() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.ParSetelephoneNumber">func (this *StringMsgParser) ParSetelephoneNumber(telephone_number string) (*core.TelephoneNumber, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.ParseAddress">func (this *StringMsgParser) ParseAddress(address string) (*address.AddressImpl, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.ParseHost">func (this *StringMsgParser) ParseHost(host string) (*core.Host, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.ParseHostPort">func (this *StringMsgParser) ParseHostPort(hostport string) (*core.HostPort, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.ParseMessage">func (this *StringMsgParser) ParseMessage(currentMessage string) (message.Message, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.ParseSIPHeader">func (this *StringMsgParser) ParseSIPHeader(h string) (*header.SIPHeader, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.ParseSIPMessage">func (this *StringMsgParser) ParseSIPMessage(sipMessage string) (message.Message, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.ParseSIPMessageFromByte">func (this *StringMsgParser) ParseSIPMessageFromByte(msgBuffer []byte) (message.Message, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.ParseSIPRequestLine">func (this *StringMsgParser) ParseSIPRequestLine(requestLine string) (*header.RequestLine, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.ParseSIPStatusLine">func (this *StringMsgParser) ParseSIPStatusLine(statusLine string) (*header.StatusLine, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.ParseSIPUrl">func (this *StringMsgParser) ParseSIPUrl(url string) (*address.SipUri, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.ParseUrl">func (this *StringMsgParser) ParseUrl(url string) (*address.GenericURI, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.ReadBytesToEnd">func (this *StringMsgParser) ReadBytesToEnd() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringMsgParser.ReadToEnd">func (this *StringMsgParser) ReadToEnd() string</a></dd>
				
			
				
				<dd><a href="#SubjectParser">type SubjectParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSubjectParser">func NewSubjectParser(subject string) *SubjectParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSubjectParserFromLexer">func NewSubjectParserFromLexer(lexer core.Lexer) *SubjectParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SubjectParser.Parse">func (this *SubjectParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#SubscriptionStateParser">type SubscriptionStateParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSubscriptionStateParser">func NewSubscriptionStateParser(subscriptionState string) *SubscriptionStateParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSubscriptionStateParserFromLexer">func NewSubscriptionStateParserFromLexer(lexer core.Lexer) *SubscriptionStateParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SubscriptionStateParser.Parse">func (this *SubscriptionStateParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#SupportedParser">type SupportedParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSupportedParser">func NewSupportedParser(supported string) *SupportedParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSupportedParserFromLexer">func NewSupportedParserFromLexer(lexer core.Lexer) *SupportedParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SupportedParser.Parse">func (this *SupportedParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#TimeStampParser">type TimeStampParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewTimeStampParser">func NewTimeStampParser(timeStamp string) *TimeStampParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewTimeStampParserFromLexer">func NewTimeStampParserFromLexer(lexer core.Lexer) *TimeStampParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TimeStampParser.Parse">func (this *TimeStampParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ToParser">type ToParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewToParser">func NewToParser(to string) *ToParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewToParserFromLexer">func NewToParserFromLexer(lexer core.Lexer) *ToParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ToParser.Parse">func (this *ToParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#URLParser">type URLParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewURLParser">func NewURLParser(url string) *URLParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewURLParserFromLexer">func NewURLParserFromLexer(lexer core.Lexer) *URLParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Base_phone_number">func (this *URLParser) Base_phone_number() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Escaped">func (this *URLParser) Escaped() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Global_phone_number">func (this *URLParser) Global_phone_number() (tn *core.TelephoneNumber, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Hvalue">func (this *URLParser) Hvalue() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.IsEscaped">func (this *URLParser) IsEscaped() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.IsMark">func (this *URLParser) IsMark(next byte) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.IsReserved">func (this *URLParser) IsReserved(next byte) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.IsReservedNoSlash">func (this *URLParser) IsReservedNoSlash(next byte) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.IsUnreserved">func (this *URLParser) IsUnreserved(next byte) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.IsUserUnreserved">func (this *URLParser) IsUserUnreserved(la byte) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Local_number">func (this *URLParser) Local_number() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Local_phone_number">func (this *URLParser) Local_phone_number() (tn *core.TelephoneNumber, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Mark">func (this *URLParser) Mark() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.ParamNameOrValue">func (this *URLParser) ParamNameOrValue() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Parse">func (this *URLParser) Parse() (url address.URI, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.ParseTelephoneNumber">func (this *URLParser) ParseTelephoneNumber() (tn *core.TelephoneNumber, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Password">func (this *URLParser) Password() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.PeekScheme">func (this *URLParser) PeekScheme() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Qheader">func (this *URLParser) Qheader() (nv *core.NameValue, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Reserved">func (this *URLParser) Reserved() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.SipURL">func (this *URLParser) SipURL() (sipurl *address.SipUri, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.TelURL">func (this *URLParser) TelURL() (telUrl *address.TelURLImpl, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Tel_parameters">func (this *URLParser) Tel_parameters() (nvl *core.NameValueList, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Unreserved">func (this *URLParser) Unreserved() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.UriParam">func (this *URLParser) UriParam() (nv *core.NameValue, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.UriReference">func (this *URLParser) UriReference() (url address.URI, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.Uric">func (this *URLParser) Uric() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.UricNoSlash">func (this *URLParser) UricNoSlash() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.UricString">func (this *URLParser) UricString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.UrlString">func (this *URLParser) UrlString() (s string, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#URLParser.User">func (this *URLParser) User() (s string, ParseException error)</a></dd>
				
			
				
				<dd><a href="#UnsupportedParser">type UnsupportedParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewUnsupportedParser">func NewUnsupportedParser(unsupported string) *UnsupportedParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewUnsupportedParserFromLexer">func NewUnsupportedParserFromLexer(lexer core.Lexer) *UnsupportedParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnsupportedParser.Parse">func (this *UnsupportedParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#UserAgentParser">type UserAgentParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewUserAgentParser">func NewUserAgentParser(userAgent string) *UserAgentParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewUserAgentParserFromLexer">func NewUserAgentParserFromLexer(lexer core.Lexer) *UserAgentParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UserAgentParser.Parse">func (this *UserAgentParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#ViaParser">type ViaParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewViaParser">func NewViaParser(via string) *ViaParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewViaParserFromLexer">func NewViaParserFromLexer(lexer core.Lexer) *ViaParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ViaParser.NameValue">func (this *ViaParser) NameValue() (nv *core.NameValue, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ViaParser.Parse">func (this *ViaParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ViaParser.ParseVia">func (this *ViaParser) ParseVia(v *header.Via) (ParseException error)</a></dd>
				
			
				
				<dd><a href="#WWWAuthenticateParser">type WWWAuthenticateParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewWWWAuthenticateParser">func NewWWWAuthenticateParser(wwwAuthenticate string) *WWWAuthenticateParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewWWWAuthenticateParserFromLexer">func NewWWWAuthenticateParserFromLexer(lexer core.Lexer) *WWWAuthenticateParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#WWWAuthenticateParser.Parse">func (this *WWWAuthenticateParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
				
				<dd><a href="#WarningParser">type WarningParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewWarningParser">func NewWarningParser(warning string) *WarningParser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewWarningParserFromLexer">func NewWarningParserFromLexer(lexer core.Lexer) *WarningParser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#WarningParser.Parse">func (this *WarningParser) Parse() (sh header.Header, ParseException error)</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/AcceptEncodingParser.go">AcceptEncodingParser.go</a>
			
				<a href="/target/AcceptLanguageParser.go">AcceptLanguageParser.go</a>
			
				<a href="/target/AcceptParser.go">AcceptParser.go</a>
			
				<a href="/target/AddressParametersParser.go">AddressParametersParser.go</a>
			
				<a href="/target/AddressParser.go">AddressParser.go</a>
			
				<a href="/target/AlertInfoParser.go">AlertInfoParser.go</a>
			
				<a href="/target/AllowEventsParser.go">AllowEventsParser.go</a>
			
				<a href="/target/AllowParser.go">AllowParser.go</a>
			
				<a href="/target/AuthenticationInfoParser.go">AuthenticationInfoParser.go</a>
			
				<a href="/target/AuthorizationParser.go">AuthorizationParser.go</a>
			
				<a href="/target/CSeqParser.go">CSeqParser.go</a>
			
				<a href="/target/CallIdParser.go">CallIdParser.go</a>
			
				<a href="/target/CallInfoParser.go">CallInfoParser.go</a>
			
				<a href="/target/ChallengeParser.go">ChallengeParser.go</a>
			
				<a href="/target/ContactParser.go">ContactParser.go</a>
			
				<a href="/target/ContentDispositionParser.go">ContentDispositionParser.go</a>
			
				<a href="/target/ContentEncodingParser.go">ContentEncodingParser.go</a>
			
				<a href="/target/ContentLanguageParser.go">ContentLanguageParser.go</a>
			
				<a href="/target/ContentLengthParser.go">ContentLengthParser.go</a>
			
				<a href="/target/ContentTypeParser.go">ContentTypeParser.go</a>
			
				<a href="/target/DateParser.go">DateParser.go</a>
			
				<a href="/target/ErrorInfoParser.go">ErrorInfoParser.go</a>
			
				<a href="/target/EventParser.go">EventParser.go</a>
			
				<a href="/target/ExpiresParser.go">ExpiresParser.go</a>
			
				<a href="/target/FromParser.go">FromParser.go</a>
			
				<a href="/target/HeaderParser.go">HeaderParser.go</a>
			
				<a href="/target/InReplyToParser.go">InReplyToParser.go</a>
			
				<a href="/target/Lexer.go">Lexer.go</a>
			
				<a href="/target/MaxForwardsParser.go">MaxForwardsParser.go</a>
			
				<a href="/target/MimeVersionParser.go">MimeVersionParser.go</a>
			
				<a href="/target/MinExpiresParser.go">MinExpiresParser.go</a>
			
				<a href="/target/OrganizationParser.go">OrganizationParser.go</a>
			
				<a href="/target/ParametersParser.go">ParametersParser.go</a>
			
				<a href="/target/Parser.go">Parser.go</a>
			
				<a href="/target/ParserFactory.go">ParserFactory.go</a>
			
				<a href="/target/PriorityParser.go">PriorityParser.go</a>
			
				<a href="/target/ProxyAuthenticateParser.go">ProxyAuthenticateParser.go</a>
			
				<a href="/target/ProxyAuthorizationParser.go">ProxyAuthorizationParser.go</a>
			
				<a href="/target/ProxyRequireParser.go">ProxyRequireParser.go</a>
			
				<a href="/target/RAckParser.go">RAckParser.go</a>
			
				<a href="/target/RSeqParser.go">RSeqParser.go</a>
			
				<a href="/target/ReasonParser.go">ReasonParser.go</a>
			
				<a href="/target/RecordRouteParser.go">RecordRouteParser.go</a>
			
				<a href="/target/ReferToParser.go">ReferToParser.go</a>
			
				<a href="/target/ReplyToParser.go">ReplyToParser.go</a>
			
				<a href="/target/RequestLineParser.go">RequestLineParser.go</a>
			
				<a href="/target/RequireParser.go">RequireParser.go</a>
			
				<a href="/target/RetryAfterParser.go">RetryAfterParser.go</a>
			
				<a href="/target/RouteParser.go">RouteParser.go</a>
			
				<a href="/target/ServerParser.go">ServerParser.go</a>
			
				<a href="/target/StatusLineParser.go">StatusLineParser.go</a>
			
				<a href="/target/StringMsgParser.go">StringMsgParser.go</a>
			
				<a href="/target/SubjectParser.go">SubjectParser.go</a>
			
				<a href="/target/SubscriptionStateParser.go">SubscriptionStateParser.go</a>
			
				<a href="/target/SupportedParser.go">SupportedParser.go</a>
			
				<a href="/target/TimeStampParser.go">TimeStampParser.go</a>
			
				<a href="/target/ToParser.go">ToParser.go</a>
			
				<a href="/target/URLParser.go">URLParser.go</a>
			
				<a href="/target/UnsupportedParser.go">UnsupportedParser.go</a>
			
				<a href="/target/UserAgentParser.go">UserAgentParser.go</a>
			
				<a href="/target/ViaParser.go">ViaParser.go</a>
			
				<a href="/target/WWWAuthenticateParser.go">WWWAuthenticateParser.go</a>
			
				<a href="/target/WarningParser.go">WarningParser.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const <span id="TokenTypes_ACCEPT">TokenTypes_ACCEPT</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 20</pre>
				
			
				<pre>const <span id="TokenTypes_ACCEPT_ENCODING">TokenTypes_ACCEPT_ENCODING</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 19</pre>
				
			
				<pre>const <span id="TokenTypes_ACCEPT_LANGUAGE">TokenTypes_ACCEPT_LANGUAGE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 47</pre>
				
			
				<pre>const <span id="TokenTypes_ACK">TokenTypes_ACK</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 6</pre>
				
			
				<pre>const <span id="TokenTypes_ALERT_INFO">TokenTypes_ALERT_INFO</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 13</pre>
				
			
				<pre>const <span id="TokenTypes_ALLOW">TokenTypes_ALLOW</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 21</pre>
				
			
				<pre>const <span id="TokenTypes_ALLOW_EVENTS">TokenTypes_ALLOW_EVENTS</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 65</pre>
				
			
				<pre>const <span id="TokenTypes_ALPHA">TokenTypes_ALPHA</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_ALPHA">LexerCore_ALPHA</a></pre>
				
			
				<pre>const <span id="TokenTypes_AND">TokenTypes_AND</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;&amp;&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_AT">TokenTypes_AT</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_AT">LexerCore_AT</a></pre>
				
			
				<pre>const <span id="TokenTypes_AUTHENTICATION_INFO">TokenTypes_AUTHENTICATION_INFO</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 64</pre>
				
			
				<pre>const <span id="TokenTypes_AUTHORIZATION">TokenTypes_AUTHORIZATION</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 23</pre>
				
			
				<pre>const <span id="TokenTypes_BACKSLASH">TokenTypes_BACKSLASH</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_BACKSLASH">LexerCore_BACKSLASH</a></pre>
				
			
				<pre>const <span id="TokenTypes_BACK_QUOTE">TokenTypes_BACK_QUOTE</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_BACK_QUOTE">LexerCore_BACK_QUOTE</a></pre>
				
			
				<pre>const <span id="TokenTypes_BAR">TokenTypes_BAR</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;|&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_BYE">TokenTypes_BYE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 7</pre>
				
			
				<pre>const <span id="TokenTypes_CALL_ID">TokenTypes_CALL_ID</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 40</pre>
				
			
				<pre>const <span id="TokenTypes_CALL_INFO">TokenTypes_CALL_INFO</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 51</pre>
				
			
				<pre>const <span id="TokenTypes_CANCEL">TokenTypes_CANCEL</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 9</pre>
				
			
				<pre>const <span id="TokenTypes_COLON">TokenTypes_COLON</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_COLON">LexerCore_COLON</a></pre>
				
			
				<pre>const <span id="TokenTypes_CONTACT">TokenTypes_CONTACT</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 39</pre>
				
			
				<pre>const <span id="TokenTypes_CONTENT_DISPOSITION">TokenTypes_CONTENT_DISPOSITION</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 52</pre>
				
			
				<pre>const <span id="TokenTypes_CONTENT_ENCODING">TokenTypes_CONTENT_ENCODING</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 35</pre>
				
			
				<pre>const <span id="TokenTypes_CONTENT_LANGUAGE">TokenTypes_CONTENT_LANGUAGE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 27</pre>
				
			
				<pre>const <span id="TokenTypes_CONTENT_LENGTH">TokenTypes_CONTENT_LENGTH</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 36</pre>
				
			
				<pre>const <span id="TokenTypes_CONTENT_TYPE">TokenTypes_CONTENT_TYPE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 38</pre>
				
			
				<pre>const <span id="TokenTypes_CSEQ">TokenTypes_CSEQ</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 46</pre>
				
			
				<pre>const <span id="TokenTypes_DATE">TokenTypes_DATE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 32</pre>
				
			
				<pre>const <span id="TokenTypes_DIGIT">TokenTypes_DIGIT</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_DIGIT">LexerCore_DIGIT</a></pre>
				
			
				<pre>const <span id="TokenTypes_DOLLAR">TokenTypes_DOLLAR</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_DOLLAR">LexerCore_DOLLAR</a></pre>
				
			
				<pre>const <span id="TokenTypes_DOT">TokenTypes_DOT</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;.&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_DOUBLEQUOTE">TokenTypes_DOUBLEQUOTE</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_DOUBLEQUOTE">LexerCore_DOUBLEQUOTE</a></pre>
				
			
				<pre>const <span id="TokenTypes_ENCRYPTION">TokenTypes_ENCRYPTION</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 43</pre>
				
			
				<pre>const <span id="TokenTypes_END">TokenTypes_END</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_END">LexerCore_END</a></pre>
				<p>
Everything under this is reserved
</p>

			
				<pre>const <span id="TokenTypes_EQUALS">TokenTypes_EQUALS</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;=&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_ERROR_INFO">TokenTypes_ERROR_INFO</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 10</pre>
				
			
				<pre>const <span id="TokenTypes_EVENT">TokenTypes_EVENT</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 63</pre>
				
			
				<pre>const <span id="TokenTypes_EXCLAMATION">TokenTypes_EXCLAMATION</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;!&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_EXPIRES">TokenTypes_EXPIRES</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 42</pre>
				
			
				<pre>const <span id="TokenTypes_FROM">TokenTypes_FROM</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 14</pre>
				
			
				<pre>const <span id="TokenTypes_GREATER_THAN">TokenTypes_GREATER_THAN</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;&gt;&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_HAT">TokenTypes_HAT</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;^&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_HIDE">TokenTypes_HIDE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 50</pre>
				
			
				<pre>const <span id="TokenTypes_HT">TokenTypes_HT</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_HT">LexerCore_HT</a></pre>
				
			
				<pre>const <span id="TokenTypes_ID">TokenTypes_ID</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_ID">LexerCore_ID</a></pre>
				
			
				<pre>const <span id="TokenTypes_INVITE">TokenTypes_INVITE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 5</pre>
				
			
				<pre>const <span id="TokenTypes_IN_REPLY_TO">TokenTypes_IN_REPLY_TO</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 11</pre>
				
			
				<pre>const <span id="TokenTypes_LESS_THAN">TokenTypes_LESS_THAN</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;&lt;&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_LPAREN">TokenTypes_LPAREN</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;(&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_L_CURLY">TokenTypes_L_CURLY</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;{&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_L_SQUARE_BRACKET">TokenTypes_L_SQUARE_BRACKET</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;[&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_MAX_FORWARDS">TokenTypes_MAX_FORWARDS</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 31</pre>
				
			
				<pre>const <span id="TokenTypes_MIME_VERSION">TokenTypes_MIME_VERSION</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 12</pre>
				
			
				<pre>const <span id="TokenTypes_MINUS">TokenTypes_MINUS</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_MINUS">LexerCore_MINUS</a></pre>
				
			
				<pre>const <span id="TokenTypes_MIN_EXPIRES">TokenTypes_MIN_EXPIRES</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 62</pre>
				
			
				<pre>const <span id="TokenTypes_NOTIFY">TokenTypes_NOTIFY</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 54</pre>
				
			
				<pre>const <span id="TokenTypes_NULL">TokenTypes_NULL</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_NULL">LexerCore_NULL</a></pre>
				
			
				<pre>const <span id="TokenTypes_OPTIONS">TokenTypes_OPTIONS</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 8</pre>
				
			
				<pre>const <span id="TokenTypes_ORGANIZATION">TokenTypes_ORGANIZATION</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 45</pre>
				
			
				<pre>const <span id="TokenTypes_PERCENT">TokenTypes_PERCENT</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;%&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_PLUS">TokenTypes_PLUS</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_PLUS">LexerCore_PLUS</a></pre>
				
			
				<pre>const <span id="TokenTypes_POUND">TokenTypes_POUND</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_POUND">LexerCore_POUND</a></pre>
				
			
				<pre>const <span id="TokenTypes_PRIORITY">TokenTypes_PRIORITY</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 33</pre>
				
			
				<pre>const <span id="TokenTypes_PROXY_AUTHENTICATE">TokenTypes_PROXY_AUTHENTICATE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 34</pre>
				
			
				<pre>const <span id="TokenTypes_PROXY_AUTHORIZATION">TokenTypes_PROXY_AUTHORIZATION</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 24</pre>
				
			
				<pre>const <span id="TokenTypes_PROXY_REQUIRE">TokenTypes_PROXY_REQUIRE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 26</pre>
				
			
				<pre>const <span id="TokenTypes_QUESTION">TokenTypes_QUESTION</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;?&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_QUOTE">TokenTypes_QUOTE</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_QUOTE">LexerCore_QUOTE</a></pre>
				
			
				<pre>const <span id="TokenTypes_RACK">TokenTypes_RACK</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 61</pre>
				
			
				<pre>const <span id="TokenTypes_REASON">TokenTypes_REASON</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 59</pre>
				
			
				<pre>const <span id="TokenTypes_RECORD_ROUTE">TokenTypes_RECORD_ROUTE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 44</pre>
				
			
				<pre>const <span id="TokenTypes_REFER_TO">TokenTypes_REFER_TO</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 66</pre>
				
			
				<pre>const <span id="TokenTypes_REGISTER">TokenTypes_REGISTER</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 4</pre>
				
			
				<pre>const <span id="TokenTypes_REPLY_TO">TokenTypes_REPLY_TO</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 58</pre>
				
			
				<pre>const <span id="TokenTypes_REQUIRE">TokenTypes_REQUIRE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 41</pre>
				
			
				<pre>const <span id="TokenTypes_RESPONSE_KEY">TokenTypes_RESPONSE_KEY</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 49</pre>
				
			
				<pre>const <span id="TokenTypes_RETRY_AFTER">TokenTypes_RETRY_AFTER</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 25</pre>
				
			
				<pre>const <span id="TokenTypes_ROUTE">TokenTypes_ROUTE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 22</pre>
				
			
				<pre>const <span id="TokenTypes_RPAREN">TokenTypes_RPAREN</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;)&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_RSEQ">TokenTypes_RSEQ</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 60</pre>
				
			
				<pre>const <span id="TokenTypes_R_CURLY">TokenTypes_R_CURLY</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;}&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_R_SQUARE_BRACKET">TokenTypes_R_SQUARE_BRACKET</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;]&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_SEMICOLON">TokenTypes_SEMICOLON</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;;&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_SERVER">TokenTypes_SERVER</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 18</pre>
				
			
				<pre>const <span id="TokenTypes_SIP">TokenTypes_SIP</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 3</pre>
				
			
				<pre>const <span id="TokenTypes_SLASH">TokenTypes_SLASH</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;/&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_SP">TokenTypes_SP</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_SP">LexerCore_SP</a></pre>
				
			
				<pre>const <span id="TokenTypes_STAR">TokenTypes_STAR</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_STAR">LexerCore_STAR</a></pre>
				
			
				<pre>const <span id="TokenTypes_START">TokenTypes_START</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_START">LexerCore_START</a></pre>
				
			
				<pre>const <span id="TokenTypes_SUBJECT">TokenTypes_SUBJECT</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 37</pre>
				
			
				<pre>const <span id="TokenTypes_SUBSCRIBE">TokenTypes_SUBSCRIBE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 53</pre>
				
			
				<pre>const <span id="TokenTypes_SUBSCRIPTION_STATE">TokenTypes_SUBSCRIPTION_STATE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 56</pre>
				
			
				<pre>const <span id="TokenTypes_SUPPORTED">TokenTypes_SUPPORTED</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 20</pre>
				
			
				<pre>const <span id="TokenTypes_TEL">TokenTypes_TEL</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 57</pre>
				
			
				<pre>const <span id="TokenTypes_TILDE">TokenTypes_TILDE</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_TILDE">LexerCore_TILDE</a></pre>
				
			
				<pre>const <span id="TokenTypes_TIMESTAMP">TokenTypes_TIMESTAMP</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 55</pre>
				
			
				<pre>const <span id="TokenTypes_TO">TokenTypes_TO</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 15</pre>
				
			
				<pre>const <span id="TokenTypes_UNDERSCORE">TokenTypes_UNDERSCORE</span> = (<a href="/pkg/builtin/#int">int</a>)(&#39;_&#39;)</pre>
				
			
				<pre>const <span id="TokenTypes_UNSUPPORTED">TokenTypes_UNSUPPORTED</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 28</pre>
				
			
				<pre>const <span id="TokenTypes_USER_AGENT">TokenTypes_USER_AGENT</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 17</pre>
				
			
				<pre>const <span id="TokenTypes_VIA">TokenTypes_VIA</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 16</pre>
				
			
				<pre>const <span id="TokenTypes_WARNING">TokenTypes_WARNING</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 30</pre>
				
			
				<pre>const <span id="TokenTypes_WHITESPACE">TokenTypes_WHITESPACE</span> = <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore_WHITESPACE">LexerCore_WHITESPACE</a></pre>
				
			
				<pre>const <span id="TokenTypes_WWW_AUTHENTICATE">TokenTypes_WWW_AUTHENTICATE</span> = <a href="#TokenTypes_START">TokenTypes_START</a> + 48</pre>
				
			
		
		
		
		
			
			
			<h2 id="AcceptEncodingParser">type <a href="/target/AcceptEncodingParser.go?s=795:847#L24">AcceptEncodingParser</a></h2>
			<pre>type AcceptEncodingParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
*
* Accept-Encoding SIP (HTTP) Header parser.
*
* &lt;pre&gt;
*
*   The Accept-Encoding request-header field is similar to Accept, but
*   restricts the content-codings (section 3.5) that are acceptable in
*   the response.
*
*
*       Accept-Encoding  = &#34;Accept-Encoding&#34; &#34;:&#34;
*                      ( encoding *( &#34;,&#34; encoding) )
*       encoding         = ( codings *[ &#34;;&#34; &#34;q&#34; &#34;=&#34; qvalue ] )
*       codings          = ( content-coding | &#34;*&#34; )
*
*   Examples of its use are:
*
*       Accept-Encoding: compress, gzip
*       Accept-Encoding:
*       Accept-Encoding: *
*       Accept-Encoding: compress;q=0.5, gzip;q=1.0
*       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
* &lt;/pre&gt;
*
</p>


			

			

			

			
				
				<h3 id="NewAcceptEncodingParser">func <a href="/target/AcceptEncodingParser.go?s=923:996#L31">NewAcceptEncodingParser</a></h3>
				<pre>func NewAcceptEncodingParser(acceptEncoding <a href="/pkg/builtin/#string">string</a>) *<a href="#AcceptEncodingParser">AcceptEncodingParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param String AcceptEncoding message to parse
</pre>

				
			
				
				<h3 id="NewAcceptEncodingParserFromLexer">func <a href="/target/AcceptEncodingParser.go?s=1147:1224#L40">NewAcceptEncodingParserFromLexer</a></h3>
				<pre>func NewAcceptEncodingParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#AcceptEncodingParser">AcceptEncodingParser</a></pre>
				<p>
* Cosntructor
</p>
<pre>* @param Lexer lexer to set
</pre>

				
			

			
				
				<h3 id="AcceptEncodingParser.Parse">func (*AcceptEncodingParser) <a href="/target/AcceptEncodingParser.go?s=1470:1552#L50">Parse</a></h3>
				<pre>func (this *<a href="#AcceptEncodingParser">AcceptEncodingParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return Header (AcceptEncoding object)
* @throws ParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="AcceptLanguageParser">type <a href="/target/AcceptLanguageParser.go?s=479:531#L18">AcceptLanguageParser</a></h2>
			<pre>type AcceptLanguageParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			

			

			

			

			
				
				<h3 id="NewAcceptLanguageParser">func <a href="/target/AcceptLanguageParser.go?s=607:680#L25">NewAcceptLanguageParser</a></h3>
				<pre>func NewAcceptLanguageParser(acceptLanguage <a href="/pkg/builtin/#string">string</a>) *<a href="#AcceptLanguageParser">AcceptLanguageParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param String AcceptLanguage message to parse
</pre>

				
			
				
				<h3 id="NewAcceptLanguageParserFromLexer">func <a href="/target/AcceptLanguageParser.go?s=831:908#L34">NewAcceptLanguageParserFromLexer</a></h3>
				<pre>func NewAcceptLanguageParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#AcceptLanguageParser">AcceptLanguageParser</a></pre>
				<p>
* Cosntructor
</p>
<pre>* @param Lexer lexer to set
</pre>

				
			

			
				
				<h3 id="AcceptLanguageParser.Parse">func (*AcceptLanguageParser) <a href="/target/AcceptLanguageParser.go?s=1154:1236#L44">Parse</a></h3>
				<pre>func (this *<a href="#AcceptLanguageParser">AcceptLanguageParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return Header (AcceptLanguage object)
* @throws ParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="AcceptParser">type <a href="/target/AcceptParser.go?s=186:234#L3">AcceptParser</a></h2>
			<pre>type AcceptParser struct {
    <a href="#ParametersParser">ParametersParser</a>
}</pre>
			<p>
* Parser for Accept header.
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
</p>


			

			

			

			
				
				<h3 id="NewAcceptParser">func <a href="/target/AcceptParser.go?s=331:380#L11">NewAcceptParser</a></h3>
				<pre>func NewAcceptParser(accept <a href="/pkg/builtin/#string">string</a>) *<a href="#AcceptParser">AcceptParser</a></pre>
				<p>
*
</p>
<pre>* Creates a new instance of Accept Parser
* @param accept  the header to parse
</pre>

				
			
				
				<h3 id="NewAcceptParserFromLexer">func <a href="/target/AcceptParser.go?s=543:604#L20">NewAcceptParserFromLexer</a></h3>
				<pre>func NewAcceptParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#AcceptParser">AcceptParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="AcceptParser.Parse">func (*AcceptParser) <a href="/target/AcceptParser.go?s=1059:1133#L38">Parse</a></h3>
				<pre>func (this *<a href="#AcceptParser">AcceptParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the Accept  String header
</p>
<pre>* @return Header (AcceptList  object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="AddressParametersParser">type <a href="/target/AddressParametersParser.go?s=102:161#L1">AddressParametersParser</a></h2>
			<pre>type AddressParametersParser struct {
    <a href="#ParametersParser">ParametersParser</a>
}</pre>
			<p>
* Address parameters parser.
</p>


			

			

			

			
				
				<h3 id="NewAddressParametersParser">func <a href="/target/AddressParametersParser.go?s=354:425#L10">NewAddressParametersParser</a></h3>
				<pre>func NewAddressParametersParser(buffer <a href="/pkg/builtin/#string">string</a>) *<a href="#AddressParametersParser">AddressParametersParser</a></pre>
				
				
			
				
				<h3 id="NewAddressParametersParserFromLexer">func <a href="/target/AddressParametersParser.go?s=165:248#L4">NewAddressParametersParserFromLexer</a></h3>
				<pre>func NewAddressParametersParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#AddressParametersParser">AddressParametersParser</a></pre>
				
				
			

			
				
				<h3 id="AddressParametersParser.Parse">func (*AddressParametersParser) <a href="/target/AddressParametersParser.go?s=751:872#L24">Parse</a></h3>
				<pre>func (this *<a href="#AddressParametersParser">AddressParametersParser</a>) Parse(addressParametersHeader <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#AddressParametersHeader">AddressParametersHeader</a>) (ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="AddressParser">type <a href="/target/AddressParser.go?s=112:151#L2">AddressParser</a></h2>
			<pre>type AddressParser struct {
    <a href="#Parser">Parser</a>
}</pre>
			

			

			

			

			
				
				<h3 id="NewAddressParser">func <a href="/target/AddressParser.go?s=155:204#L6">NewAddressParser</a></h3>
				<pre>func NewAddressParser(addr <a href="/pkg/builtin/#string">string</a>) *<a href="#AddressParser">AddressParser</a></pre>
				
				
			
				
				<h3 id="NewAddressParserFromLexer">func <a href="/target/AddressParser.go?s=335:398#L15">NewAddressParserFromLexer</a></h3>
				<pre>func NewAddressParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#AddressParser">AddressParser</a></pre>
				
				
			

			
				
				<h3 id="AddressParser.Address">func (*AddressParser) <a href="/target/AddressParser.go?s=2033:2121#L82">Address</a></h3>
				<pre>func (this *<a href="#AddressParser">AddressParser</a>) Address() (retval *<a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#AddressImpl">AddressImpl</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="AddressParser.NameAddr">func (*AddressParser) <a href="/target/AddressParser.go?s=783:870#L34">NameAddr</a></h3>
				<pre>func (this *<a href="#AddressParser">AddressParser</a>) NameAddr() (addr *<a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#AddressImpl">AddressImpl</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="AlertInfoParser">type <a href="/target/AlertInfoParser.go?s=123:174#L2">AlertInfoParser</a></h2>
			<pre>type AlertInfoParser struct {
    <a href="#ParametersParser">ParametersParser</a>
}</pre>
			<p>
* Parser for AlertInfo header.
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewAlertInfoParser">func <a href="/target/AlertInfoParser.go?s=277:335#L10">NewAlertInfoParser</a></h3>
				<pre>func NewAlertInfoParser(alertInfo <a href="/pkg/builtin/#string">string</a>) *<a href="#AlertInfoParser">AlertInfoParser</a></pre>
				<p>
*
</p>
<pre>* Creates a new instance of AlertInfo Parser
* @param alertInfo  the header to parse
</pre>

				
			
				
				<h3 id="NewAlertInfoParserFromLexer">func <a href="/target/AlertInfoParser.go?s=504:571#L19">NewAlertInfoParserFromLexer</a></h3>
				<pre>func NewAlertInfoParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#AlertInfoParser">AlertInfoParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="AlertInfoParser.Parse">func (*AlertInfoParser) <a href="/target/AlertInfoParser.go?s=1041:1118#L37">Parse</a></h3>
				<pre>func (this *<a href="#AlertInfoParser">AlertInfoParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the AlertInfo  String header
</p>
<pre>* @return Header (AlertInfoList  object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="AllowEventsParser">type <a href="/target/AllowEventsParser.go?s=325:374#L8">AllowEventsParser</a></h2>
			<pre>type AllowEventsParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for AllowEvents header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewAllowEventsParser">func <a href="/target/AllowEventsParser.go?s=479:543#L16">NewAllowEventsParser</a></h3>
				<pre>func NewAllowEventsParser(allowEvents <a href="/pkg/builtin/#string">string</a>) *<a href="#AllowEventsParser">AllowEventsParser</a></pre>
				<p>
*
</p>
<pre>* Creates a new instance of AllowEventsParser
* @param allowEvents the header to parse
</pre>

				
			
				
				<h3 id="NewAllowEventsParserFromLexer">func <a href="/target/AllowEventsParser.go?s=712:783#L25">NewAllowEventsParserFromLexer</a></h3>
				<pre>func NewAllowEventsParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#AllowEventsParser">AllowEventsParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="AllowEventsParser.Parse">func (*AllowEventsParser) <a href="/target/AllowEventsParser.go?s=1041:1120#L35">Parse</a></h3>
				<pre>func (this *<a href="#AllowEventsParser">AllowEventsParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the AllowEvents String header
</p>
<pre>* @return Header (AllowEventsList object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="AllowParser">type <a href="/target/AllowParser.go?s=100:143#L1">AllowParser</a></h2>
			<pre>type AllowParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for Allow header.
</p>


			

			

			

			
				
				<h3 id="NewAllowParser">func <a href="/target/AllowParser.go?s=236:282#L8">NewAllowParser</a></h3>
				<pre>func NewAllowParser(allow <a href="/pkg/builtin/#string">string</a>) *<a href="#AllowParser">AllowParser</a></pre>
				<p>
*
</p>
<pre>* Creates a new instance of AllowParser
* @param allow the header to parse
</pre>

				
			
				
				<h3 id="NewAllowParserFromLexer">func <a href="/target/AllowParser.go?s=439:498#L17">NewAllowParserFromLexer</a></h3>
				<pre>func NewAllowParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#AllowParser">AllowParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="AllowParser.Parse">func (*AllowParser) <a href="/target/AllowParser.go?s=738:811#L27">Parse</a></h3>
				<pre>func (this *<a href="#AllowParser">AllowParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the Allow String header
</p>
<pre>* @return Header (AllowList object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="AuthenticationInfoParser">type <a href="/target/AuthenticationInfoParser.go?s=114:174#L1">AuthenticationInfoParser</a></h2>
			<pre>type AuthenticationInfoParser struct {
    <a href="#ParametersParser">ParametersParser</a>
}</pre>
			<p>
* Parser for Authentication-Info header.
</p>


			

			

			

			
				
				<h3 id="NewAuthenticationInfoParser">func <a href="/target/AuthenticationInfoParser.go?s=293:378#L8">NewAuthenticationInfoParser</a></h3>
				<pre>func NewAuthenticationInfoParser(authenticationInfo <a href="/pkg/builtin/#string">string</a>) *<a href="#AuthenticationInfoParser">AuthenticationInfoParser</a></pre>
				<p>
*
</p>
<pre>* Creates a new instance of AuthenticationInfoParser
* @param authenticationInfo the header to parse
</pre>

				
			
				
				<h3 id="NewAuthenticationInfoParserFromLexer">func <a href="/target/AuthenticationInfoParser.go?s=565:650#L17">NewAuthenticationInfoParserFromLexer</a></h3>
				<pre>func NewAuthenticationInfoParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#AuthenticationInfoParser">AuthenticationInfoParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="AuthenticationInfoParser.Parse">func (*AuthenticationInfoParser) <a href="/target/AuthenticationInfoParser.go?s=935:1021#L28">Parse</a></h3>
				<pre>func (this *<a href="#AuthenticationInfoParser">AuthenticationInfoParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the AuthenticationInfo String header
</p>
<pre>* @return Header (AuthenticationInfoList object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="AuthorizationParser">type <a href="/target/AuthorizationParser.go?s=109:163#L1">AuthorizationParser</a></h2>
			<pre>type AuthorizationParser struct {
    <a href="#ChallengeParser">ChallengeParser</a>
}</pre>
			<p>
* Parser for authorization headers.
</p>


			

			

			

			
				
				<h3 id="NewAuthorizationParser">func <a href="/target/AuthorizationParser.go?s=238:308#L7">NewAuthorizationParser</a></h3>
				<pre>func NewAuthorizationParser(authorization <a href="/pkg/builtin/#string">string</a>) *<a href="#AuthorizationParser">AuthorizationParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param String Authorization message to parse
</pre>

				
			
				
				<h3 id="NewAuthorizationParserFromLexer">func <a href="/target/AuthorizationParser.go?s=460:535#L16">NewAuthorizationParserFromLexer</a></h3>
				<pre>func NewAuthorizationParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#AuthorizationParser">AuthorizationParser</a></pre>
				<p>
* Cosntructor
</p>
<pre>* @param Lexer lexer to set
</pre>

				
			

			
				
				<h3 id="AuthorizationParser.Parse">func (*AuthorizationParser) <a href="/target/AuthorizationParser.go?s=785:866#L26">Parse</a></h3>
				<pre>func (this *<a href="#AuthorizationParser">AuthorizationParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return Header (Authorization object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="CSeqParser">type <a href="/target/CSeqParser.go?s=100:142#L1">CSeqParser</a></h2>
			<pre>type CSeqParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for CSeq headers.
</p>


			

			

			

			
				
				<h3 id="NewCSeqParser">func <a href="/target/CSeqParser.go?s=146:189#L4">NewCSeqParser</a></h3>
				<pre>func NewCSeqParser(cseq <a href="/pkg/builtin/#string">string</a>) *<a href="#CSeqParser">CSeqParser</a></pre>
				
				
			
				
				<h3 id="NewCSeqParserFromLexer">func <a href="/target/CSeqParser.go?s=351:408#L14">NewCSeqParserFromLexer</a></h3>
				<pre>func NewCSeqParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#CSeqParser">CSeqParser</a></pre>
				
				
			

			
				
				<h3 id="CSeqParser.Parse">func (*CSeqParser) <a href="/target/CSeqParser.go?s=497:569#L20">Parse</a></h3>
				<pre>func (this *<a href="#CSeqParser">CSeqParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="CallIDParser">type <a href="/target/CallIdParser.go?s=114:158#L1">CallIDParser</a></h2>
			<pre>type CallIDParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for CALL ID header.
</p>


			

			

			

			
				
				<h3 id="NewCallIDParser">func <a href="/target/CallIdParser.go?s=246:295#L8">NewCallIDParser</a></h3>
				<pre>func NewCallIDParser(callId <a href="/pkg/builtin/#string">string</a>) *<a href="#CallIDParser">CallIDParser</a></pre>
				<p>
* Creates new CallIDParser
</p>
<pre>* @param String callID message to parse to set
</pre>

				
			
				
				<h3 id="NewCallIDParserFromLexer">func <a href="/target/CallIdParser.go?s=523:584#L23">NewCallIDParserFromLexer</a></h3>
				<pre>func NewCallIDParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#CallIDParser">CallIDParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param Lexer lexer to set
</pre>

				
			

			
				
				<h3 id="CallIDParser.Parse">func (*CallIDParser) <a href="/target/CallIdParser.go?s=818:892#L35">Parse</a></h3>
				<pre>func (this *<a href="#CallIDParser">CallIDParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return Header (CallID object)
* @throws ParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="CallInfoParser">type <a href="/target/CallInfoParser.go?s=322:372#L8">CallInfoParser</a></h2>
			<pre>type CallInfoParser struct {
    <a href="#ParametersParser">ParametersParser</a>
}</pre>
			<p>
* Parser for CallInfo header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewCallInfoParser">func <a href="/target/CallInfoParser.go?s=471:526#L16">NewCallInfoParser</a></h3>
				<pre>func NewCallInfoParser(callInfo <a href="/pkg/builtin/#string">string</a>) *<a href="#CallInfoParser">CallInfoParser</a></pre>
				<p>
*
</p>
<pre>* Creates a new instance of CallInfoParser
* @param callInfo the header to parse
</pre>

				
			
				
				<h3 id="NewCallInfoParserFromLexer">func <a href="/target/CallInfoParser.go?s=693:758#L25">NewCallInfoParserFromLexer</a></h3>
				<pre>func NewCallInfoParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#CallInfoParser">CallInfoParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="CallInfoParser.Parse">func (*CallInfoParser) <a href="/target/CallInfoParser.go?s=1011:1087#L35">Parse</a></h3>
				<pre>func (this *<a href="#CallInfoParser">CallInfoParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the CallInfo String header
</p>
<pre>* @return Header (CallInfoList object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="ChallengeParser">type <a href="/target/ChallengeParser.go?s=335:382#L9">ChallengeParser</a></h2>
			<pre>type ChallengeParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			

			

			

			

			
				
				<h3 id="NewChallengeParser">func <a href="/target/ChallengeParser.go?s=461:519#L16">NewChallengeParser</a></h3>
				<pre>func NewChallengeParser(challenge <a href="/pkg/builtin/#string">string</a>) *<a href="#ChallengeParser">ChallengeParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param String challenge  message to parse to set
</pre>

				
			
				
				<h3 id="NewChallengeParserFromLexer">func <a href="/target/ChallengeParser.go?s=683:750#L25">NewChallengeParserFromLexer</a></h3>
				<pre>func NewChallengeParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ChallengeParser">ChallengeParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param String challenge  message to parse to set
</pre>

				
			

			
				
				<h3 id="ChallengeParser.Parse">func (*ChallengeParser) <a href="/target/ChallengeParser.go?s=1579:1649#L56">Parse</a></h3>
				<pre>func (this *<a href="#ChallengeParser">ChallengeParser</a>) Parse(h <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#AuthorizationHeader">AuthorizationHeader</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
* parser the String message
</p>
<pre>* @return Challenge object
* @throws ParseException if the message does not respect the spec.
</pre>

				
				
			
				
				<h3 id="ChallengeParser.ParseParameter">func (*ChallengeParser) <a href="/target/ChallengeParser.go?s=1147:1220#L42">ParseParameter</a></h3>
				<pre>func (this *<a href="#ChallengeParser">ChallengeParser</a>) ParseParameter(h <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#AuthorizationHeader">AuthorizationHeader</a>)</pre>
				<p>
* Get the parameter of the challenge string
</p>
<pre>* @return NameValue containing the parameter
</pre>

				
				
			
		
			
			
			<h2 id="ContactParser">type <a href="/target/ContactParser.go?s=117:173#L2">ContactParser</a></h2>
			<pre>type ContactParser struct {
    <a href="#AddressParametersParser">AddressParametersParser</a>
}</pre>
			

			

			

			

			
				
				<h3 id="NewContactParser">func <a href="/target/ContactParser.go?s=177:229#L6">NewContactParser</a></h3>
				<pre>func NewContactParser(contact <a href="/pkg/builtin/#string">string</a>) *<a href="#ContactParser">ContactParser</a></pre>
				
				
			
				
				<h3 id="NewContactParserFromLexer">func <a href="/target/ContactParser.go?s=325:388#L12">NewContactParserFromLexer</a></h3>
				<pre>func NewContactParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ContactParser">ContactParser</a></pre>
				
				
			

			
				
				<h3 id="ContactParser.Parse">func (*ContactParser) <a href="/target/ContactParser.go?s=491:566#L18">Parse</a></h3>
				<pre>func (this *<a href="#ContactParser">ContactParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="ContentDispositionParser">type <a href="/target/ContentDispositionParser.go?s=346:406#L9">ContentDispositionParser</a></h2>
			<pre>type ContentDispositionParser struct {
    <a href="#ParametersParser">ParametersParser</a>
}</pre>
			<p>
* Parser for ContentLanguage header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewContentDispositionParser">func <a href="/target/ContentDispositionParser.go?s=525:610#L17">NewContentDispositionParser</a></h3>
				<pre>func NewContentDispositionParser(contentDisposition <a href="/pkg/builtin/#string">string</a>) *<a href="#ContentDispositionParser">ContentDispositionParser</a></pre>
				<p>
*
</p>
<pre>* Creates a new instance of ContentDispositionParser
* @param contentDisposition the header to parse
</pre>

				
			
				
				<h3 id="NewContentDispositionParserFromLexer">func <a href="/target/ContentDispositionParser.go?s=797:882#L26">NewContentDispositionParserFromLexer</a></h3>
				<pre>func NewContentDispositionParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ContentDispositionParser">ContentDispositionParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="ContentDispositionParser.Parse">func (*ContentDispositionParser) <a href="/target/ContentDispositionParser.go?s=1171:1257#L36">Parse</a></h3>
				<pre>func (this *<a href="#ContentDispositionParser">ContentDispositionParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the ContentDispositionHeader String header
</p>
<pre>* @return Header (ContentDispositionList object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="ContentEncodingParser">type <a href="/target/ContentEncodingParser.go?s=346:399#L9">ContentEncodingParser</a></h2>
			<pre>type ContentEncodingParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for ContentLanguage header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewContentEncodingParser">func <a href="/target/ContentEncodingParser.go?s=512:588#L17">NewContentEncodingParser</a></h3>
				<pre>func NewContentEncodingParser(contentEncoding <a href="/pkg/builtin/#string">string</a>) *<a href="#ContentEncodingParser">ContentEncodingParser</a></pre>
				<p>
*
</p>
<pre>* Creates a new instance of ContentEncodingParser
* @param contentEncoding the header to parse
</pre>

				
			
				
				<h3 id="NewContentEncodingParserFromLexer">func <a href="/target/ContentEncodingParser.go?s=765:844#L26">NewContentEncodingParserFromLexer</a></h3>
				<pre>func NewContentEncodingParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ContentEncodingParser">ContentEncodingParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="ContentEncodingParser.Parse">func (*ContentEncodingParser) <a href="/target/ContentEncodingParser.go?s=1120:1203#L36">Parse</a></h3>
				<pre>func (this *<a href="#ContentEncodingParser">ContentEncodingParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the ContentEncodingHeader String header
</p>
<pre>* @return Header (ContentEncodingList object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="ContentLanguageParser">type <a href="/target/ContentLanguageParser.go?s=346:399#L9">ContentLanguageParser</a></h2>
			<pre>type ContentLanguageParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for ContentLanguage header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewContentLanguageParser">func <a href="/target/ContentLanguageParser.go?s=512:588#L17">NewContentLanguageParser</a></h3>
				<pre>func NewContentLanguageParser(contentLanguage <a href="/pkg/builtin/#string">string</a>) *<a href="#ContentLanguageParser">ContentLanguageParser</a></pre>
				<p>
*
</p>
<pre>* Creates a new instance of ContentLanguageParser
* @param contentLanguage the header to parse
</pre>

				
			
				
				<h3 id="NewContentLanguageParserFromLexer">func <a href="/target/ContentLanguageParser.go?s=765:844#L26">NewContentLanguageParserFromLexer</a></h3>
				<pre>func NewContentLanguageParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ContentLanguageParser">ContentLanguageParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="ContentLanguageParser.Parse">func (*ContentLanguageParser) <a href="/target/ContentLanguageParser.go?s=1120:1203#L36">Parse</a></h3>
				<pre>func (this *<a href="#ContentLanguageParser">ContentLanguageParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the ContentLanguageHeader String header
</p>
<pre>* @return Header (ContentLanguageList object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="ContentLengthParser">type <a href="/target/ContentLengthParser.go?s=306:357#L7">ContentLengthParser</a></h2>
			<pre>type ContentLengthParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for Content-Length Header.
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
</p>


			

			

			

			
				
				<h3 id="NewContentLengthParser">func <a href="/target/ContentLengthParser.go?s=361:431#L11">NewContentLengthParser</a></h3>
				<pre>func NewContentLengthParser(contentLength <a href="/pkg/builtin/#string">string</a>) *<a href="#ContentLengthParser">ContentLengthParser</a></pre>
				
				
			
				
				<h3 id="NewContentLengthParserFromLexer">func <a href="/target/ContentLengthParser.go?s=528:603#L17">NewContentLengthParserFromLexer</a></h3>
				<pre>func NewContentLengthParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ContentLengthParser">ContentLengthParser</a></pre>
				
				
			

			
				
				<h3 id="ContentLengthParser.Parse">func (*ContentLengthParser) <a href="/target/ContentLengthParser.go?s=701:782#L23">Parse</a></h3>
				<pre>func (this *<a href="#ContentLengthParser">ContentLengthParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="ContentTypeParser">type <a href="/target/ContentTypeParser.go?s=273:326#L7">ContentTypeParser</a></h2>
			<pre>type ContentTypeParser struct {
    <a href="#ParametersParser">ParametersParser</a>
}</pre>
			<p>
* Parser for content type header.
*
*@version  JAIN-SIP-1.1
*
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
</p>


			

			

			

			
				
				<h3 id="NewContentTypeParser">func <a href="/target/ContentTypeParser.go?s=330:394#L11">NewContentTypeParser</a></h3>
				<pre>func NewContentTypeParser(contentType <a href="/pkg/builtin/#string">string</a>) *<a href="#ContentTypeParser">ContentTypeParser</a></pre>
				
				
			
				
				<h3 id="NewContentTypeParserFromLexer">func <a href="/target/ContentTypeParser.go?s=491:562#L17">NewContentTypeParserFromLexer</a></h3>
				<pre>func NewContentTypeParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ContentTypeParser">ContentTypeParser</a></pre>
				
				
			

			
				
				<h3 id="ContentTypeParser.Parse">func (*ContentTypeParser) <a href="/target/ContentTypeParser.go?s=662:741#L23">Parse</a></h3>
				<pre>func (this *<a href="#ContentTypeParser">ContentTypeParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="DateParser">type <a href="/target/DateParser.go?s=185:227#L3">DateParser</a></h2>
			<pre>type DateParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for SIP Date field. Converts from SIP Date to the
</p>
<pre>* internal storage (Calendar)
</pre>


			

			

			

			
				
				<h3 id="NewDateParser">func <a href="/target/DateParser.go?s=301:344#L10">NewDateParser</a></h3>
				<pre>func NewDateParser(date <a href="/pkg/builtin/#string">string</a>) *<a href="#DateParser">DateParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param String route message to parse to set
</pre>

				
			
				
				<h3 id="NewDateParserFromLexer">func <a href="/target/DateParser.go?s=423:480#L16">NewDateParserFromLexer</a></h3>
				<pre>func NewDateParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#DateParser">DateParser</a></pre>
				
				
			

			
				
				<h3 id="DateParser.Parse">func (*DateParser) <a href="/target/DateParser.go?s=657:729#L26">Parse</a></h3>
				<pre>func (this *<a href="#DateParser">DateParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Parse method.
</p>
<pre>* @throws ParseException
* @return  the parsed Date header/
</pre>

				
				
			
		
			
			
			<h2 id="ErrorInfoParser">type <a href="/target/ErrorInfoParser.go?s=340:391#L9">ErrorInfoParser</a></h2>
			<pre>type ErrorInfoParser struct {
    <a href="#ParametersParser">ParametersParser</a>
}</pre>
			<p>
* Parser for ErrorInfo header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewErrorInfoParser">func <a href="/target/ErrorInfoParser.go?s=492:550#L17">NewErrorInfoParser</a></h3>
				<pre>func NewErrorInfoParser(errorInfo <a href="/pkg/builtin/#string">string</a>) *<a href="#ErrorInfoParser">ErrorInfoParser</a></pre>
				<p>
*
</p>
<pre>* Creates a new instance of ErrorInfoParser
* @param errorInfo the header to parse
</pre>

				
			
				
				<h3 id="NewErrorInfoParserFromLexer">func <a href="/target/ErrorInfoParser.go?s=721:788#L27">NewErrorInfoParserFromLexer</a></h3>
				<pre>func NewErrorInfoParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ErrorInfoParser">ErrorInfoParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="ErrorInfoParser.Parse">func (*ErrorInfoParser) <a href="/target/ErrorInfoParser.go?s=1046:1123#L38">Parse</a></h3>
				<pre>func (this *<a href="#ErrorInfoParser">ErrorInfoParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the ErrorInfo String header
</p>
<pre>* @return Header (ErrorInfoList object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="EventParser">type <a href="/target/EventParser.go?s=336:383#L9">EventParser</a></h2>
			<pre>type EventParser struct {
    <a href="#ParametersParser">ParametersParser</a>
}</pre>
			<p>
* Parser for Event header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewEventParser">func <a href="/target/EventParser.go?s=476:522#L17">NewEventParser</a></h3>
				<pre>func NewEventParser(event <a href="/pkg/builtin/#string">string</a>) *<a href="#EventParser">EventParser</a></pre>
				<p>
*
</p>
<pre>* Creates a new instance of EventParser
* @param event the header to parse
</pre>

				
			
				
				<h3 id="NewEventParserFromLexer">func <a href="/target/EventParser.go?s=683:742#L26">NewEventParserFromLexer</a></h3>
				<pre>func NewEventParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#EventParser">EventParser</a></pre>
				<p>
* Cosntructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="EventParser.Parse">func (*EventParser) <a href="/target/EventParser.go?s=977:1050#L36">Parse</a></h3>
				<pre>func (this *<a href="#EventParser">EventParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return Header (Event object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="ExpiresParser">type <a href="/target/ExpiresParser.go?s=346:391#L9">ExpiresParser</a></h2>
			<pre>type ExpiresParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for SIP Expires Parser. Converts from SIP Date to the
* internal storage (Calendar).
*
*@version  JAIN-SIP-1.1
*
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
</p>


			

			

			

			
				
				<h3 id="NewExpiresParser">func <a href="/target/ExpiresParser.go?s=478:527#L16">NewExpiresParser</a></h3>
				<pre>func NewExpiresParser(text <a href="/pkg/builtin/#string">string</a>) *<a href="#ExpiresParser">ExpiresParser</a></pre>
				<p>
* protected constructor.
</p>
<pre>*@param text is the text of the header to parse
</pre>

				
			
				
				<h3 id="NewExpiresParserFromLexer">func <a href="/target/ExpiresParser.go?s=698:761#L25">NewExpiresParserFromLexer</a></h3>
				<pre>func NewExpiresParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ExpiresParser">ExpiresParser</a></pre>
				<p>
* constructor.
</p>
<pre>*@param lexer is the lexer passed in from the enclosing parser.
</pre>

				
			

			
				
				<h3 id="ExpiresParser.Parse">func (*ExpiresParser) <a href="/target/ExpiresParser.go?s=881:956#L33">Parse</a></h3>
				<pre>func (this *<a href="#ExpiresParser">ExpiresParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Parse the header.
</p>

				
				
			
		
			
			
			<h2 id="FromParser">type <a href="/target/FromParser.go?s=115:168#L2">FromParser</a></h2>
			<pre>type FromParser struct {
    <a href="#AddressParametersParser">AddressParametersParser</a>
}</pre>
			

			

			

			

			
				
				<h3 id="NewFromParser">func <a href="/target/FromParser.go?s=172:215#L6">NewFromParser</a></h3>
				<pre>func NewFromParser(from <a href="/pkg/builtin/#string">string</a>) *<a href="#FromParser">FromParser</a></pre>
				
				
			
				
				<h3 id="NewFromParserFromLexer">func <a href="/target/FromParser.go?s=399:456#L16">NewFromParserFromLexer</a></h3>
				<pre>func NewFromParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#FromParser">FromParser</a></pre>
				
				
			

			
				
				<h3 id="FromParser.Parse">func (*FromParser) <a href="/target/FromParser.go?s=556:628#L22">Parse</a></h3>
				<pre>func (this *<a href="#FromParser">FromParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="HeaderParser">type <a href="/target/HeaderParser.go?s=353:391#L8">HeaderParser</a></h2>
			<pre>type HeaderParser struct {
    <a href="#Parser">Parser</a>
}</pre>
			

			

			

			

			
				
				<h3 id="NewHeaderParser">func <a href="/target/HeaderParser.go?s=458:507#L15">NewHeaderParser</a></h3>
				<pre>func NewHeaderParser(header <a href="/pkg/builtin/#string">string</a>) *<a href="#HeaderParser">HeaderParser</a></pre>
				<p>
* Creates new HeaderParser
</p>
<pre>* @param String to parse.
</pre>

				
			
				
				<h3 id="NewHeaderParserFromLexer">func <a href="/target/HeaderParser.go?s=650:711#L24">NewHeaderParserFromLexer</a></h3>
				<pre>func NewHeaderParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#HeaderParser">HeaderParser</a></pre>
				
				
			

			
				
				<h3 id="HeaderParser.HeaderName">func (*HeaderParser) <a href="/target/HeaderParser.go?s=1726:1771#L63">HeaderName</a></h3>
				<pre>func (this *<a href="#HeaderParser">HeaderParser</a>) HeaderName(tok <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
* Parse the header name until the colon  and chew WS after that.
</p>

				
				
			
				
				<h3 id="HeaderParser.Parse">func (*HeaderParser) <a href="/target/HeaderParser.go?s=1292:1366#L47">Parse</a></h3>
				<pre>func (this *<a href="#HeaderParser">HeaderParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Parse the SIP header from the buffer and return a parsed
</p>
<pre>* structure.
*@throws ParseException if there was an error parsing.
</pre>

				
				
			
		
			
			
			<h2 id="IHeaderParser">type <a href="/target/HeaderParser.go?s=77:161#L1">IHeaderParser</a></h2>
			<pre>type IHeaderParser interface {
    Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)
}</pre>
			

			

			

			

			
				
				<h3 id="CreateParser">func <a href="/target/ParserFactory.go?s=527:571#L15">CreateParser</a></h3>
				<pre>func CreateParser(line <a href="/pkg/builtin/#string">string</a>) <a href="#IHeaderParser">IHeaderParser</a></pre>
				<pre>}
</pre>
<p>
* create a parser for a header. This is the parser factory.
</p>

				
			

			
		
			
			
			<h2 id="InReplyToParser">type <a href="/target/InReplyToParser.go?s=340:387#L9">InReplyToParser</a></h2>
			<pre>type InReplyToParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for InReplyTo header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewInReplyToParser">func <a href="/target/InReplyToParser.go?s=484:542#L16">NewInReplyToParser</a></h3>
				<pre>func NewInReplyToParser(inReplyTo <a href="/pkg/builtin/#string">string</a>) *<a href="#InReplyToParser">InReplyToParser</a></pre>
				<p>
* Creates a new instance of InReplyToParser
</p>
<pre>* @param inReplyTo the header to parse
</pre>

				
			
				
				<h3 id="NewInReplyToParserFromLexer">func <a href="/target/InReplyToParser.go?s=707:774#L25">NewInReplyToParserFromLexer</a></h3>
				<pre>func NewInReplyToParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#InReplyToParser">InReplyToParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="InReplyToParser.Parse">func (*InReplyToParser) <a href="/target/InReplyToParser.go?s=1017:1094#L35">Parse</a></h3>
				<pre>func (this *<a href="#InReplyToParser">InReplyToParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return Header (InReplyToList object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="Lexer">type <a href="/target/Lexer.go?s=100:139#L1">Lexer</a></h2>
			<pre>type Lexer struct {
    <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#LexerCore">LexerCore</a>
}</pre>
			

			

			

			

			
				
				<h3 id="NewLexer">func <a href="/target/Lexer.go?s=143:189#L5">NewLexer</a></h3>
				<pre>func NewLexer(lexerName, buffer <a href="/pkg/builtin/#string">string</a>) *<a href="#Lexer">Lexer</a></pre>
				
				
			

			
				
				<h3 id="Lexer.GetHeaderName">func (*Lexer) <a href="/target/Lexer.go?s=498:550#L21">GetHeaderName</a></h3>
				<pre>func (this *<a href="#Lexer">Lexer</a>) GetHeaderName(line <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#string">string</a></pre>
				<p>
* get the header name of the line
</p>
<pre>*  @return String
</pre>

				
				
			
				
				<h3 id="Lexer.GetHeaderValue">func (*Lexer) <a href="/target/Lexer.go?s=894:947#L42">GetHeaderValue</a></h3>
				<pre>func (this *<a href="#Lexer">Lexer</a>) GetHeaderValue(line <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#string">string</a></pre>
				<p>
* get the header value of the line
</p>
<pre>*  @return String
</pre>

				
				
			
				
				<h3 id="Lexer.SelectLexer">func (*Lexer) <a href="/target/Lexer.go?s=1186:1234#L56">SelectLexer</a></h3>
				<pre>func (this *<a href="#Lexer">Lexer</a>) SelectLexer(lexerName <a href="/pkg/builtin/#string">string</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="MaxForwardsParser">type <a href="/target/MaxForwardsParser.go?s=104:153#L1">MaxForwardsParser</a></h2>
			<pre>type MaxForwardsParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for Max Forwards Header.
</p>


			

			

			

			
				
				<h3 id="NewMaxForwardsParser">func <a href="/target/MaxForwardsParser.go?s=157:223#L3">NewMaxForwardsParser</a></h3>
				<pre>func NewMaxForwardsParser(contentLength <a href="/pkg/builtin/#string">string</a>) *<a href="#MaxForwardsParser">MaxForwardsParser</a></pre>
				
				
			
				
				<h3 id="NewMaxForwardsParserFromLexer">func <a href="/target/MaxForwardsParser.go?s=318:389#L9">NewMaxForwardsParserFromLexer</a></h3>
				<pre>func NewMaxForwardsParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#MaxForwardsParser">MaxForwardsParser</a></pre>
				
				
			

			
				
				<h3 id="MaxForwardsParser.Parse">func (*MaxForwardsParser) <a href="/target/MaxForwardsParser.go?s=577:656#L19">Parse</a></h3>
				<pre>func (this *<a href="#MaxForwardsParser">MaxForwardsParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="MimeVersionParser">type <a href="/target/MimeVersionParser.go?s=342:391#L9">MimeVersionParser</a></h2>
			<pre>type MimeVersionParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for MimeVersion header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewMimeVersionParser">func <a href="/target/MimeVersionParser.go?s=492:556#L16">NewMimeVersionParser</a></h3>
				<pre>func NewMimeVersionParser(mimeVersion <a href="/pkg/builtin/#string">string</a>) *<a href="#MimeVersionParser">MimeVersionParser</a></pre>
				<p>
* Creates a new instance of MimeVersionParser
</p>
<pre>* @param mimeVersion the header to parse
</pre>

				
			
				
				<h3 id="NewMimeVersionParserFromLexer">func <a href="/target/MimeVersionParser.go?s=725:796#L25">NewMimeVersionParserFromLexer</a></h3>
				<pre>func NewMimeVersionParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#MimeVersionParser">MimeVersionParser</a></pre>
				<p>
* Cosntructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="MimeVersionParser.Parse">func (*MimeVersionParser) <a href="/target/MimeVersionParser.go?s=1039:1118#L35">Parse</a></h3>
				<pre>func (this *<a href="#MimeVersionParser">MimeVersionParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return Header (MimeVersion object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="MinExpiresParser">type <a href="/target/MinExpiresParser.go?s=341:389#L9">MinExpiresParser</a></h2>
			<pre>type MinExpiresParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for MinExpires header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewMinExpiresParser">func <a href="/target/MinExpiresParser.go?s=476:537#L16">NewMinExpiresParser</a></h3>
				<pre>func NewMinExpiresParser(minExpires <a href="/pkg/builtin/#string">string</a>) *<a href="#MinExpiresParser">MinExpiresParser</a></pre>
				<p>
* protected constructor.
</p>
<pre>*@param text is the text of the header to parse
</pre>

				
			
				
				<h3 id="NewMinExpiresParserFromLexer">func <a href="/target/MinExpiresParser.go?s=717:786#L25">NewMinExpiresParserFromLexer</a></h3>
				<pre>func NewMinExpiresParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#MinExpiresParser">MinExpiresParser</a></pre>
				<p>
* constructor.
</p>
<pre>*@param lexer is the lexer passed in from the enclosing parser.
</pre>

				
			

			
				
				<h3 id="MinExpiresParser.Parse">func (*MinExpiresParser) <a href="/target/MinExpiresParser.go?s=1026:1104#L35">Parse</a></h3>
				<pre>func (this *<a href="#MinExpiresParser">MinExpiresParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return Header (MinExpiresParser)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="OrganizationParser">type <a href="/target/OrganizationParser.go?s=355:405#L10">OrganizationParser</a></h2>
			<pre>type OrganizationParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for Organization header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewOrganizationParser">func <a href="/target/OrganizationParser.go?s=509:576#L17">NewOrganizationParser</a></h3>
				<pre>func NewOrganizationParser(organization <a href="/pkg/builtin/#string">string</a>) *<a href="#OrganizationParser">OrganizationParser</a></pre>
				<p>
*  Creates a new instance of OrganizationParser
</p>
<pre>* @param organization the header to parse
</pre>

				
			
				
				<h3 id="NewOrganizationParserFromLexer">func <a href="/target/OrganizationParser.go?s=747:820#L26">NewOrganizationParserFromLexer</a></h3>
				<pre>func NewOrganizationParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#OrganizationParser">OrganizationParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="OrganizationParser.Parse">func (*OrganizationParser) <a href="/target/OrganizationParser.go?s=1064:1144#L36">Parse</a></h3>
				<pre>func (this *<a href="#OrganizationParser">OrganizationParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String header
</p>
<pre>* @return Header (Organization object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="ParametersParser">type <a href="/target/ParametersParser.go?s=101:149#L1">ParametersParser</a></h2>
			<pre>type ParametersParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* parameters parser header.
</p>


			

			

			

			
				
				<h3 id="NewParametersParser">func <a href="/target/ParametersParser.go?s=317:374#L10">NewParametersParser</a></h3>
				<pre>func NewParametersParser(buffer <a href="/pkg/builtin/#string">string</a>) *<a href="#ParametersParser">ParametersParser</a></pre>
				
				
			
				
				<h3 id="NewParametersParserFromLexer">func <a href="/target/ParametersParser.go?s=153:222#L4">NewParametersParserFromLexer</a></h3>
				<pre>func NewParametersParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ParametersParser">ParametersParser</a></pre>
				
				
			

			
				
				<h3 id="ParametersParser.Parse">func (*ParametersParser) <a href="/target/ParametersParser.go?s=667:767#L24">Parse</a></h3>
				<pre>func (this *<a href="#ParametersParser">ParametersParser</a>) Parse(parametersHeader <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ParametersHeader">ParametersHeader</a>) (ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="Parser">type <a href="/target/Parser.go?s=5402:5469#L118">Parser</a></h2>
			<pre>type Parser struct {
    <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#ParserCore">ParserCore</a> <span class="comment">//implements TokenTypes {</span>
}</pre>
			

			

			

			

			
				
				<h3 id="NewParser">func <a href="/target/Parser.go?s=5473:5510#L122">NewParser</a></h3>
				<pre>func NewParser(buffer <a href="/pkg/builtin/#string">string</a>) *<a href="#Parser">Parser</a></pre>
				
				
			

			
				
				<h3 id="Parser.CreateParseException">func (*Parser) <a href="/target/Parser.go?s=5786:5873#L136">CreateParseException</a></h3>
				<pre>func (this *<a href="#Parser">Parser</a>) CreateParseException(exceptionString <a href="/pkg/builtin/#string">string</a>) (ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="Parser.Method">func (*Parser) <a href="/target/Parser.go?s=6757:6818#L169">Method</a></h3>
				<pre>func (this *<a href="#Parser">Parser</a>) Method() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parses a method. Consumes if a valid method has been found.
</p>

				
				
			
				
				<h3 id="Parser.SipVersion">func (*Parser) <a href="/target/Parser.go?s=6083:6148#L144">SipVersion</a></h3>
				<pre>func (this *<a href="#Parser">Parser</a>) SipVersion() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="PriorityParser">type <a href="/target/PriorityParser.go?s=339:385#L9">PriorityParser</a></h2>
			<pre>type PriorityParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for Priority header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewPriorityParser">func <a href="/target/PriorityParser.go?s=480:535#L16">NewPriorityParser</a></h3>
				<pre>func NewPriorityParser(priority <a href="/pkg/builtin/#string">string</a>) *<a href="#PriorityParser">PriorityParser</a></pre>
				<p>
* Creates a new instance of PriorityParser
</p>
<pre>* @param priority the header to parse
</pre>

				
			
				
				<h3 id="NewPriorityParserFromLexer">func <a href="/target/PriorityParser.go?s=698:763#L25">NewPriorityParserFromLexer</a></h3>
				<pre>func NewPriorityParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#PriorityParser">PriorityParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="PriorityParser.Parse">func (*PriorityParser) <a href="/target/PriorityParser.go?s=1002:1078#L35">Parse</a></h3>
				<pre>func (this *<a href="#PriorityParser">PriorityParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String header
</p>
<pre>* @return SIPHeader (Priority object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="ProxyAuthenticateParser">type <a href="/target/ProxyAuthenticateParser.go?s=279:337#L7">ProxyAuthenticateParser</a></h2>
			<pre>type ProxyAuthenticateParser struct {
    <a href="#ChallengeParser">ChallengeParser</a>
}</pre>
			<p>
* Parser for ProxyAuthenticate headers.
*
*@version  JAIN-SIP-1.1
*
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
</p>


			

			

			

			
				
				<h3 id="NewProxyAuthenticateParser">func <a href="/target/ProxyAuthenticateParser.go?s=413:495#L14">NewProxyAuthenticateParser</a></h3>
				<pre>func NewProxyAuthenticateParser(proxyAuthenticate <a href="/pkg/builtin/#string">string</a>) *<a href="#ProxyAuthenticateParser">ProxyAuthenticateParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param String paAuthenticate message to parse
</pre>

				
			
				
				<h3 id="NewProxyAuthenticateParserFromLexer">func <a href="/target/ProxyAuthenticateParser.go?s=655:738#L23">NewProxyAuthenticateParserFromLexer</a></h3>
				<pre>func NewProxyAuthenticateParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ProxyAuthenticateParser">ProxyAuthenticateParser</a></pre>
				<p>
* Cosntructor
</p>
<pre>* @param Lexer lexer to set
</pre>

				
			

			
				
				<h3 id="ProxyAuthenticateParser.Parse">func (*ProxyAuthenticateParser) <a href="/target/ProxyAuthenticateParser.go?s=996:1081#L33">Parse</a></h3>
				<pre>func (this *<a href="#ProxyAuthenticateParser">ProxyAuthenticateParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (ProxyAuthenticate object)
* @throws ParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="ProxyAuthorizationParser">type <a href="/target/ProxyAuthorizationParser.go?s=280:339#L7">ProxyAuthorizationParser</a></h2>
			<pre>type ProxyAuthorizationParser struct {
    <a href="#ChallengeParser">ChallengeParser</a>
}</pre>
			<p>
* Parser for ProxyAuthorization headers.
*
*@version  JAIN-SIP-1.1
*
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
</p>


			

			

			

			
				
				<h3 id="NewProxyAuthorizationParser">func <a href="/target/ProxyAuthorizationParser.go?s=415:500#L14">NewProxyAuthorizationParser</a></h3>
				<pre>func NewProxyAuthorizationParser(proxyAuthorization <a href="/pkg/builtin/#string">string</a>) *<a href="#ProxyAuthorizationParser">ProxyAuthorizationParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param proxyAuthorization --  header to parse
</pre>

				
			
				
				<h3 id="NewProxyAuthorizationParserFromLexer">func <a href="/target/ProxyAuthorizationParser.go?s=662:747#L23">NewProxyAuthorizationParserFromLexer</a></h3>
				<pre>func NewProxyAuthorizationParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ProxyAuthorizationParser">ProxyAuthorizationParser</a></pre>
				<p>
* Cosntructor
</p>
<pre>* @param Lexer lexer to set
</pre>

				
			

			
				
				<h3 id="ProxyAuthorizationParser.Parse">func (*ProxyAuthorizationParser) <a href="/target/ProxyAuthorizationParser.go?s=1006:1092#L33">Parse</a></h3>
				<pre>func (this *<a href="#ProxyAuthorizationParser">ProxyAuthorizationParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (ProxyAuthenticate object)
* @throws ParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="ProxyRequireParser">type <a href="/target/ProxyRequireParser.go?s=343:393#L9">ProxyRequireParser</a></h2>
			<pre>type ProxyRequireParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for ProxyRequire header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewProxyRequireParser">func <a href="/target/ProxyRequireParser.go?s=490:552#L16">NewProxyRequireParser</a></h3>
				<pre>func NewProxyRequireParser(require <a href="/pkg/builtin/#string">string</a>) *<a href="#ProxyRequireParser">ProxyRequireParser</a></pre>
				<p>
* Creates a new instance of ProxyRequireParser
</p>
<pre>*@param require the header to parse
</pre>

				
			
				
				<h3 id="NewProxyRequireParserFromLexer">func <a href="/target/ProxyRequireParser.go?s=718:791#L25">NewProxyRequireParserFromLexer</a></h3>
				<pre>func NewProxyRequireParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ProxyRequireParser">ProxyRequireParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="ProxyRequireParser.Parse">func (*ProxyRequireParser) <a href="/target/ProxyRequireParser.go?s=1043:1123#L35">Parse</a></h3>
				<pre>func (this *<a href="#ProxyRequireParser">ProxyRequireParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (ProxyRequireList object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="RAckParser">type <a href="/target/RAckParser.go?s=335:377#L9">RAckParser</a></h2>
			<pre>type RAckParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for RAck header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewRAckParser">func <a href="/target/RAckParser.go?s=463:506#L16">NewRAckParser</a></h3>
				<pre>func NewRAckParser(rack <a href="/pkg/builtin/#string">string</a>) *<a href="#RAckParser">RAckParser</a></pre>
				<p>
* Creates a new instance of RAckParser
</p>
<pre>*@param rack the header to parse
</pre>

				
			
				
				<h3 id="NewRAckParserFromLexer">func <a href="/target/RAckParser.go?s=661:718#L25">NewRAckParserFromLexer</a></h3>
				<pre>func NewRAckParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#RAckParser">RAckParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="RAckParser.Parse">func (*RAckParser) <a href="/target/RAckParser.go?s=950:1022#L35">Parse</a></h3>
				<pre>func (this *<a href="#RAckParser">RAckParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (RAck object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="RSeqParser">type <a href="/target/RSeqParser.go?s=335:377#L9">RSeqParser</a></h2>
			<pre>type RSeqParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for RSeq header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewRSeqParser">func <a href="/target/RSeqParser.go?s=463:506#L16">NewRSeqParser</a></h3>
				<pre>func NewRSeqParser(rseq <a href="/pkg/builtin/#string">string</a>) *<a href="#RSeqParser">RSeqParser</a></pre>
				<p>
* Creates a new instance of RSeqParser
</p>
<pre>*@param rseq the header to parse
</pre>

				
			
				
				<h3 id="NewRSeqParserFromLexer">func <a href="/target/RSeqParser.go?s=660:717#L25">NewRSeqParserFromLexer</a></h3>
				<pre>func NewRSeqParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#RSeqParser">RSeqParser</a></pre>
				<p>
* Constructor
</p>
<pre>* param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="RSeqParser.Parse">func (*RSeqParser) <a href="/target/RSeqParser.go?s=950:1022#L35">Parse</a></h3>
				<pre>func (this *<a href="#RSeqParser">RSeqParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader ( RSeq object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="ReasonParser">type <a href="/target/ReasonParser.go?s=337:385#L9">ReasonParser</a></h2>
			<pre>type ReasonParser struct {
    <a href="#ParametersParser">ParametersParser</a>
}</pre>
			<p>
* Parser for Reason header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewReasonParser">func <a href="/target/ReasonParser.go?s=476:525#L16">NewReasonParser</a></h3>
				<pre>func NewReasonParser(reason <a href="/pkg/builtin/#string">string</a>) *<a href="#ReasonParser">ReasonParser</a></pre>
				<p>
* Creates a new instance of ReasonParser
</p>
<pre>* @param reason the header to parse
</pre>

				
			
				
				<h3 id="NewReasonParserFromLexer">func <a href="/target/ReasonParser.go?s=688:749#L25">NewReasonParserFromLexer</a></h3>
				<pre>func NewReasonParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ReasonParser">ReasonParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="ReasonParser.Parse">func (*ReasonParser) <a href="/target/ReasonParser.go?s=999:1073#L35">Parse</a></h3>
				<pre>func (this *<a href="#ReasonParser">ReasonParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (ReasonParserList object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="RecordRouteParser">type <a href="/target/RecordRouteParser.go?s=343:403#L8">RecordRouteParser</a></h2>
			<pre>type RecordRouteParser struct {
    <a href="#AddressParametersParser">AddressParametersParser</a>
}</pre>
			<p>
* Parser for a list of route headers.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
*@version 1.0
</p>


			

			

			

			
				
				<h3 id="NewRecordRouteParser">func <a href="/target/RecordRouteParser.go?s=483:547#L15">NewRecordRouteParser</a></h3>
				<pre>func NewRecordRouteParser(recordRoute <a href="/pkg/builtin/#string">string</a>) *<a href="#RecordRouteParser">RecordRouteParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param String recordRoute message to parse to set
</pre>

				
			
				
				<h3 id="NewRecordRouteParserFromLexer">func <a href="/target/RecordRouteParser.go?s=651:722#L21">NewRecordRouteParserFromLexer</a></h3>
				<pre>func NewRecordRouteParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#RecordRouteParser">RecordRouteParser</a></pre>
				
				
			

			
				
				<h3 id="RecordRouteParser.Parse">func (*RecordRouteParser) <a href="/target/RecordRouteParser.go?s=1017:1096#L31">Parse</a></h3>
				<pre>func (this *<a href="#RecordRouteParser">RecordRouteParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message and generate the RecordRoute List Object
</p>
<pre>* @return SIPHeader the RecordRoute List object
* @throws ParseException if errors occur during the parsing
</pre>

				
				
			
		
			
			
			<h2 id="ReferToParser">type <a href="/target/ReferToParser.go?s=263:319#L7">ReferToParser</a></h2>
			<pre>type ReferToParser struct {
    <a href="#AddressParametersParser">AddressParametersParser</a>
}</pre>
			<p>
* To Header parser.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
</p>


			

			

			

			
				
				<h3 id="NewReferToParser">func <a href="/target/ReferToParser.go?s=379:431#L14">NewReferToParser</a></h3>
				<pre>func NewReferToParser(referTo <a href="/pkg/builtin/#string">string</a>) *<a href="#ReferToParser">ReferToParser</a></pre>
				<p>
* Creates new ToParser
</p>
<pre>* @param String to set
</pre>

				
			
				
				<h3 id="NewReferToParserFromLexer">func <a href="/target/ReferToParser.go?s=527:590#L20">NewReferToParserFromLexer</a></h3>
				<pre>func NewReferToParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ReferToParser">ReferToParser</a></pre>
				
				
			

			
				
				<h3 id="ReferToParser.Parse">func (*ReferToParser) <a href="/target/ReferToParser.go?s=693:768#L26">Parse</a></h3>
				<pre>func (this *<a href="#ReferToParser">ReferToParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="ReplyToParser">type <a href="/target/ReplyToParser.go?s=347:403#L9">ReplyToParser</a></h2>
			<pre>type ReplyToParser struct {
    <a href="#AddressParametersParser">AddressParametersParser</a>
}</pre>
			

			

			

			

			
				
				<h3 id="NewReplyToParser">func <a href="/target/ReplyToParser.go?s=496:548#L16">NewReplyToParser</a></h3>
				<pre>func NewReplyToParser(replyTo <a href="/pkg/builtin/#string">string</a>) *<a href="#ReplyToParser">ReplyToParser</a></pre>
				<p>
* Creates a new instance of ReplyToParser
</p>
<pre>* @param replyTo the header to parse
</pre>

				
			
				
				<h3 id="NewReplyToParserFromLexer">func <a href="/target/ReplyToParser.go?s=719:782#L25">NewReplyToParserFromLexer</a></h3>
				<pre>func NewReplyToParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ReplyToParser">ReplyToParser</a></pre>
				<p>
* Cosntructor
</p>
<pre>* param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="ReplyToParser.Parse">func (*ReplyToParser) <a href="/target/ReplyToParser.go?s=1068:1143#L35">Parse</a></h3>
				<pre>func (this *<a href="#ReplyToParser">ReplyToParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message and generate the ReplyTo List Object
</p>
<pre>* @return SIPHeader the ReplyTo List object
* @throws SIPParseException if errors occur during the parsing
</pre>

				
				
			
		
			
			
			<h2 id="RequestLineParser">type <a href="/target/RequestLineParser.go?s=273:316#L7">RequestLineParser</a></h2>
			<pre>type RequestLineParser struct {
    <a href="#Parser">Parser</a>
}</pre>
			

			

			

			

			
				
				<h3 id="NewRequestLineParser">func <a href="/target/RequestLineParser.go?s=320:384#L11">NewRequestLineParser</a></h3>
				<pre>func NewRequestLineParser(requestLine <a href="/pkg/builtin/#string">string</a>) *<a href="#RequestLineParser">RequestLineParser</a></pre>
				
				
			
				
				<h3 id="NewRequestLineParserFromLexer">func <a href="/target/RequestLineParser.go?s=535:606#L17">NewRequestLineParserFromLexer</a></h3>
				<pre>func NewRequestLineParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#RequestLineParser">RequestLineParser</a></pre>
				
				
			

			
				
				<h3 id="RequestLineParser.Parse">func (*RequestLineParser) <a href="/target/RequestLineParser.go?s=736:821#L24">Parse</a></h3>
				<pre>func (this *<a href="#RequestLineParser">RequestLineParser</a>) Parse() (rl *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#RequestLine">RequestLine</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="RequireParser">type <a href="/target/RequireParser.go?s=331:376#L9">RequireParser</a></h2>
			<pre>type RequireParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for Require header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewRequireParser">func <a href="/target/RequireParser.go?s=469:521#L16">NewRequireParser</a></h3>
				<pre>func NewRequireParser(require <a href="/pkg/builtin/#string">string</a>) *<a href="#RequireParser">RequireParser</a></pre>
				<p>
* Creates a new instance of RequireParser
</p>
<pre>* @param require the header to parse
</pre>

				
			
				
				<h3 id="NewRequireParserFromLexer">func <a href="/target/RequireParser.go?s=682:745#L25">NewRequireParserFromLexer</a></h3>
				<pre>func NewRequireParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#RequireParser">RequireParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="RequireParser.Parse">func (*RequireParser) <a href="/target/RequireParser.go?s=987:1062#L35">Parse</a></h3>
				<pre>func (this *<a href="#RequireParser">RequireParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (RequireList object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="RetryAfterParser">type <a href="/target/RetryAfterParser.go?s=324:372#L8">RetryAfterParser</a></h2>
			<pre>type RetryAfterParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for RetryAfter header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewRetryAfterParser">func <a href="/target/RetryAfterParser.go?s=471:532#L15">NewRetryAfterParser</a></h3>
				<pre>func NewRetryAfterParser(retryAfter <a href="/pkg/builtin/#string">string</a>) *<a href="#RetryAfterParser">RetryAfterParser</a></pre>
				<p>
* Creates a new instance of RetryAfterParser
</p>
<pre>* @param retryAfter the header to parse
</pre>

				
			
				
				<h3 id="NewRetryAfterParserFromLexer">func <a href="/target/RetryAfterParser.go?s=699:768#L24">NewRetryAfterParserFromLexer</a></h3>
				<pre>func NewRetryAfterParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#RetryAfterParser">RetryAfterParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="RetryAfterParser.Parse">func (*RetryAfterParser) <a href="/target/RetryAfterParser.go?s=1012:1090#L34">Parse</a></h3>
				<pre>func (this *<a href="#RetryAfterParser">RetryAfterParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (RetryAfter object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="RouteParser">type <a href="/target/RouteParser.go?s=345:399#L9">RouteParser</a></h2>
			<pre>type RouteParser struct {
    <a href="#AddressParametersParser">AddressParametersParser</a>
}</pre>
			

			

			

			

			
				
				<h3 id="NewRouteParser">func <a href="/target/RouteParser.go?s=473:519#L16">NewRouteParser</a></h3>
				<pre>func NewRouteParser(route <a href="/pkg/builtin/#string">string</a>) *<a href="#RouteParser">RouteParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param String route message to parse to set
</pre>

				
			
				
				<h3 id="NewRouteParserFromLexer">func <a href="/target/RouteParser.go?s=611:670#L22">NewRouteParserFromLexer</a></h3>
				<pre>func NewRouteParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#RouteParser">RouteParser</a></pre>
				
				
			

			
				
				<h3 id="RouteParser.Parse">func (*RouteParser) <a href="/target/RouteParser.go?s=950:1023#L32">Parse</a></h3>
				<pre>func (this *<a href="#RouteParser">RouteParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message and generate the Route List Object
</p>
<pre>* @return SIPHeader the Route List object
* @throws SIPParseException if errors occur during the parsing
</pre>

				
				
			
		
			
			
			<h2 id="ServerParser">type <a href="/target/ServerParser.go?s=360:404#L11">ServerParser</a></h2>
			<pre>type ServerParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for Server header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewServerParser">func <a href="/target/ServerParser.go?s=495:544#L18">NewServerParser</a></h3>
				<pre>func NewServerParser(server <a href="/pkg/builtin/#string">string</a>) *<a href="#ServerParser">ServerParser</a></pre>
				<p>
* Creates a new instance of ServerParser
</p>
<pre>* @param server the header to parse
</pre>

				
			
				
				<h3 id="NewServerParserFromLexer">func <a href="/target/ServerParser.go?s=703:764#L27">NewServerParserFromLexer</a></h3>
				<pre>func NewServerParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ServerParser">ServerParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="ServerParser.Parse">func (*ServerParser) <a href="/target/ServerParser.go?s=999:1073#L37">Parse</a></h3>
				<pre>func (this *<a href="#ServerParser">ServerParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String server
</p>
<pre>* @return SIPHeader (Server object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="StatusLineParser">type <a href="/target/StatusLineParser.go?s=287:329#L9">StatusLineParser</a></h2>
			<pre>type StatusLineParser struct {
    <a href="#Parser">Parser</a>
}</pre>
			

			

			

			

			
				
				<h3 id="NewStatusLineParser">func <a href="/target/StatusLineParser.go?s=333:394#L13">NewStatusLineParser</a></h3>
				<pre>func NewStatusLineParser(statusLine <a href="/pkg/builtin/#string">string</a>) *<a href="#StatusLineParser">StatusLineParser</a></pre>
				
				
			
				
				<h3 id="NewStatusLineParserFromLexer">func <a href="/target/StatusLineParser.go?s=541:610#L20">NewStatusLineParserFromLexer</a></h3>
				<pre>func NewStatusLineParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#StatusLineParser">StatusLineParser</a></pre>
				
				
			

			
				
				<h3 id="StatusLineParser.Parse">func (*StatusLineParser) <a href="/target/StatusLineParser.go?s=1358:1441#L46">Parse</a></h3>
				<pre>func (this *<a href="#StatusLineParser">StatusLineParser</a>) Parse() (sl *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#StatusLine">StatusLine</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="StatusLineParser.ReasonPhrase">func (*StatusLineParser) <a href="/target/StatusLineParser.go?s=1206:1257#L42">ReasonPhrase</a></h3>
				<pre>func (this *<a href="#StatusLineParser">StatusLineParser</a>) ReasonPhrase() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
			
				
				<h3 id="StatusLineParser.StatusCode">func (*StatusLineParser) <a href="/target/StatusLineParser.go?s=736:812#L27">StatusCode</a></h3>
				<pre>func (this *<a href="#StatusLineParser">StatusLineParser</a>) StatusCode() (scode <a href="/pkg/builtin/#int">int</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="StringMsgParser">type <a href="/target/StringMsgParser.go?s=1245:1798#L31">StringMsgParser</a></h2>
			<pre>type StringMsgParser struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			
				
				<h3 id="NewStringMsgParser">func <a href="/target/StringMsgParser.go?s=1827:1869#L62">NewStringMsgParser</a></h3>
				<pre>func NewStringMsgParser() *<a href="#StringMsgParser">StringMsgParser</a></pre>
				<p>
*
</p>
<pre>*@since v0.9
</pre>

				
			

			
				
				<h3 id="StringMsgParser.GetBodyAsBytes">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=2983:3035#L107">GetBodyAsBytes</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) GetBodyAsBytes() []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>
* Get the message body as a byte array.
</p>

				
				
			
				
				<h3 id="StringMsgParser.GetCurrentHeader">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=24413:24467#L735">GetCurrentHeader</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) GetCurrentHeader() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
*
</p>
<pre>* Get the current header.
</pre>

				
				
			
				
				<h3 id="StringMsgParser.GetCurrentLineNumber">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=24547:24602#L742">GetCurrentLineNumber</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) GetCurrentLineNumber() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
*
</p>
<pre>* Get the current line number.
</pre>

				
				
			
				
				<h3 id="StringMsgParser.GetMessageBody">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=2365:2417#L84">GetMessageBody</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) GetMessageBody() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
* Get the message body.
</p>

				
				
			
				
				<h3 id="StringMsgParser.IsBodyString">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=4835:4883#L168">IsBodyString</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) IsBodyString() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
* Return true if the body is encoded as a string.
</p>
<pre>* If the parseSIPMessage(String) method is invoked then the body
* is assumed to be a string.
</pre>

				
				
			
				
				<h3 id="StringMsgParser.ParSetelephoneNumber">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=21228:21333#L634">ParSetelephoneNumber</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) ParSetelephoneNumber(telephone_number <a href="/pkg/builtin/#string">string</a>) (*<a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#TelephoneNumber">TelephoneNumber</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
*
</p>
<pre>* Parse a telephone number return a parsed structure.
* @param telphone_number is a String containing
* the telephone # to be parsed
* @return a parsed address structure.
* @since v1.0
* @exception throws a ParseException when the address is badly formatted.
</pre>

				
				
			
				
				<h3 id="StringMsgParser.ParseAddress">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=19788:19875#L594">ParseAddress</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) ParseAddress(address <a href="/pkg/builtin/#string">string</a>) (*<a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#AddressImpl">AddressImpl</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="StringMsgParser.ParseHost">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=20742:20813#L620">ParseHost</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) ParseHost(host <a href="/pkg/builtin/#string">string</a>) (*<a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Host">Host</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
*
</p>
<pre>* Parse a host name and return a parsed structure.
* @param host is a String containing the host name to be parsed
* @return a parsed address structure.
* @since v1.0
* @exception throws a ParseException when the hostname is badly formatted.
</pre>

				
				
			
				
				<h3 id="StringMsgParser.ParseHostPort">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=20255:20338#L607">ParseHostPort</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) ParseHostPort(hostport <a href="/pkg/builtin/#string">string</a>) (*<a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#HostPort">HostPort</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
*
</p>
<pre>* Parse a host:port and return a parsed structure.
* @param hostport is a String containing the host:port to be parsed
* @return a parsed address structure.
* @since v1.0
* @exception throws a ParseException when the address is badly formatted.
</pre>

				
				
			
				
				<h3 id="StringMsgParser.ParseMessage">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=15591:15680#L472">ParseMessage</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) ParseMessage(currentMessage <a href="/pkg/builtin/#string">string</a>) (<a href="/pkg/gosip/message/">message</a>.<a href="/pkg/gosip/message/#Message">Message</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* This is called repeatedly by parseSIPMessage to parse
</p>
<pre>* the contents of a message buffer. This assumes the message
* already has continuations etc. taken care of.
* prior to its being called.
</pre>

				
				
			
				
				<h3 id="StringMsgParser.ParseSIPHeader">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=22719:22799#L674">ParseSIPHeader</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) ParseSIPHeader(h <a href="/pkg/builtin/#string">string</a>) (*<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#SIPHeader">SIPHeader</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
*
</p>
<pre>* Parse an individual SIP message header from a string.
* @param header String containing the SIP header.
* @return a SIPHeader structure.
* @exception ParseException  if there was an error parsing the message.
</pre>

				
				
			
				
				<h3 id="StringMsgParser.ParseSIPMessage">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=10849:10937#L356">ParseSIPMessage</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) ParseSIPMessage(sipMessage <a href="/pkg/builtin/#string">string</a>) (<a href="/pkg/gosip/message/">message</a>.<a href="/pkg/gosip/message/#Message">Message</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="StringMsgParser.ParseSIPMessageFromByte">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=5628:5723#L186">ParseSIPMessageFromByte</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) ParseSIPMessageFromByte(msgBuffer []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/gosip/message/">message</a>.<a href="/pkg/gosip/message/#Message">Message</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Parse a buffer containing a single SIP Message where the body
</p>
<pre>* is an array of un-interpreted bytes. This is intended for parsing
* the message from a memory buffer when the buffer.
* Incorporates a bug fix for a bug that was noted by Will Sullin of
* Callcast
* @param msgBuffer a byte buffer containing the messages to be parsed.
*   This can consist of multiple SIP Messages concatenated toGether.
* @return a SIPMessage[] structure (request or response)
* 			containing the parsed SIP message.
* @exception SIPIllegalMessageException is thrown when an
* 			illegal message has been encountered (and
*			the rest of the buffer is discarded).
* @see ParseExceptionListener
</pre>

				
				
			
				
				<h3 id="StringMsgParser.ParseSIPRequestLine">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=23701:23798#L712">ParseSIPRequestLine</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) ParseSIPRequestLine(requestLine <a href="/pkg/builtin/#string">string</a>) (*<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#RequestLine">RequestLine</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="StringMsgParser.ParseSIPStatusLine">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=24174:24268#L726">ParseSIPStatusLine</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) ParseSIPStatusLine(statusLine <a href="/pkg/builtin/#string">string</a>) (*<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#StatusLine">StatusLine</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="StringMsgParser.ParseSIPUrl">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=21730:21807#L646">ParseSIPUrl</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) ParseSIPUrl(url <a href="/pkg/builtin/#string">string</a>) (*<a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#SipUri">SipUri</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
*
</p>
<pre>* Parse a  SIP url from a string and return a URI structure for it.
* @param url a String containing the URI structure to be parsed.
* @return A parsed URI structure
* @exception ParseException  if there was an error parsing the message.
</pre>

				
				
			
				
				<h3 id="StringMsgParser.ParseUrl">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=22293:22371#L662">ParseUrl</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) ParseUrl(url <a href="/pkg/builtin/#string">string</a>) (*<a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#GenericURI">GenericURI</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
*
</p>
<pre>* Parse a  uri from a string and return a URI structure for it.
* @param url a String containing the URI structure to be parsed.
* @return A parsed URI structure
* @exception ParseException  if there was an error parsing the message.
</pre>

				
				
			
				
				<h3 id="StringMsgParser.ReadBytesToEnd">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=4073:4125#L144">ReadBytesToEnd</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) ReadBytesToEnd() []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>
* Return tbe bytes to the end of the message.
</p>
<pre>* This is invoked when the parser is invoked with an array of bytes
* rather than with a string.
</pre>

				
				
			
				
				<h3 id="StringMsgParser.ReadToEnd">func (*StringMsgParser) <a href="/target/StringMsgParser.go?s=3763:3810#L134">ReadToEnd</a></h3>
				<pre>func (this *<a href="#StringMsgParser">StringMsgParser</a>) ReadToEnd() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
* Return the contents till the end of the buffer (this is useful when
</p>
<pre>* you encounter an error.
</pre>

				
				
			
		
			
			
			<h2 id="SubjectParser">type <a href="/target/SubjectParser.go?s=351:396#L10">SubjectParser</a></h2>
			<pre>type SubjectParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for Subject  header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewSubjectParser">func <a href="/target/SubjectParser.go?s=489:541#L17">NewSubjectParser</a></h3>
				<pre>func NewSubjectParser(subject <a href="/pkg/builtin/#string">string</a>) *<a href="#SubjectParser">SubjectParser</a></pre>
				<p>
* Creates a new instance of SubjectParser
</p>
<pre>* @param subject the header to parse
</pre>

				
			
				
				<h3 id="NewSubjectParserFromLexer">func <a href="/target/SubjectParser.go?s=702:765#L26">NewSubjectParserFromLexer</a></h3>
				<pre>func NewSubjectParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#SubjectParser">SubjectParser</a></pre>
				<p>
* Cosntructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="SubjectParser.Parse">func (*SubjectParser) <a href="/target/SubjectParser.go?s=1003:1078#L36">Parse</a></h3>
				<pre>func (this *<a href="#SubjectParser">SubjectParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (Subject object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="SubscriptionStateParser">type <a href="/target/SubscriptionStateParser.go?s=355:410#L10">SubscriptionStateParser</a></h2>
			<pre>type SubscriptionStateParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for SubscriptionState header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewSubscriptionStateParser">func <a href="/target/SubscriptionStateParser.go?s=523:605#L17">NewSubscriptionStateParser</a></h3>
				<pre>func NewSubscriptionStateParser(subscriptionState <a href="/pkg/builtin/#string">string</a>) *<a href="#SubscriptionStateParser">SubscriptionStateParser</a></pre>
				<p>
* Creates a new instance of SubscriptionStateParser
</p>
<pre>* @param subscriptionState the header to parse
</pre>

				
			
				
				<h3 id="NewSubscriptionStateParserFromLexer">func <a href="/target/SubscriptionStateParser.go?s=786:869#L26">NewSubscriptionStateParserFromLexer</a></h3>
				<pre>func NewSubscriptionStateParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#SubscriptionStateParser">SubscriptionStateParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="SubscriptionStateParser.Parse">func (*SubscriptionStateParser) <a href="/target/SubscriptionStateParser.go?s=1128:1213#L36">Parse</a></h3>
				<pre>func (this *<a href="#SubscriptionStateParser">SubscriptionStateParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (SubscriptionState  object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="SupportedParser">type <a href="/target/SupportedParser.go?s=340:387#L9">SupportedParser</a></h2>
			<pre>type SupportedParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for Supported header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewSupportedParser">func <a href="/target/SupportedParser.go?s=484:542#L16">NewSupportedParser</a></h3>
				<pre>func NewSupportedParser(supported <a href="/pkg/builtin/#string">string</a>) *<a href="#SupportedParser">SupportedParser</a></pre>
				<p>
* Creates a new instance of SupportedParser
</p>
<pre>* @param supported the header to parse
</pre>

				
			
				
				<h3 id="NewSupportedParserFromLexer">func <a href="/target/SupportedParser.go?s=707:774#L25">NewSupportedParserFromLexer</a></h3>
				<pre>func NewSupportedParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#SupportedParser">SupportedParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="SupportedParser.Parse">func (*SupportedParser) <a href="/target/SupportedParser.go?s=1016:1093#L35">Parse</a></h3>
				<pre>func (this *<a href="#SupportedParser">SupportedParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (Supported object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="TimeStampParser">type <a href="/target/TimeStampParser.go?s=352:399#L10">TimeStampParser</a></h2>
			<pre>type TimeStampParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for TimeStamp header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewTimeStampParser">func <a href="/target/TimeStampParser.go?s=496:554#L17">NewTimeStampParser</a></h3>
				<pre>func NewTimeStampParser(timeStamp <a href="/pkg/builtin/#string">string</a>) *<a href="#TimeStampParser">TimeStampParser</a></pre>
				<p>
* Creates a new instance of TimeStampParser
</p>
<pre>* @param timeStamp the header to parse
</pre>

				
			
				
				<h3 id="NewTimeStampParserFromLexer">func <a href="/target/TimeStampParser.go?s=719:786#L26">NewTimeStampParserFromLexer</a></h3>
				<pre>func NewTimeStampParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#TimeStampParser">TimeStampParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="TimeStampParser.Parse">func (*TimeStampParser) <a href="/target/TimeStampParser.go?s=1028:1105#L36">Parse</a></h3>
				<pre>func (this *<a href="#TimeStampParser">TimeStampParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (TimeStamp object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="ToParser">type <a href="/target/ToParser.go?s=107:158#L1">ToParser</a></h2>
			<pre>type ToParser struct {
    <a href="#AddressParametersParser">AddressParametersParser</a>
}</pre>
			<p>
To Header parser.
</p>


			

			

			

			
				
				<h3 id="NewToParser">func <a href="/target/ToParser.go?s=218:255#L7">NewToParser</a></h3>
				<pre>func NewToParser(to <a href="/pkg/builtin/#string">string</a>) *<a href="#ToParser">ToParser</a></pre>
				<p>
* Creates new ToParser
</p>
<pre>* @param String to set
</pre>

				
			
				
				<h3 id="NewToParserFromLexer">func <a href="/target/ToParser.go?s=341:394#L13">NewToParserFromLexer</a></h3>
				<pre>func NewToParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ToParser">ToParser</a></pre>
				
				
			

			
				
				<h3 id="ToParser.Parse">func (*ToParser) <a href="/target/ToParser.go?s=492:562#L19">Parse</a></h3>
				<pre>func (this *<a href="#ToParser">ToParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="URLParser">type <a href="/target/URLParser.go?s=177:212#L3">URLParser</a></h2>
			<pre>type URLParser struct {
    <a href="#Parser">Parser</a>
}</pre>
			<p>
* Parser For SIP and Tel URLs. Other kinds of URL&#39;s are handled by the
</p>


			

			

			

			
				
				<h3 id="NewURLParser">func <a href="/target/URLParser.go?s=216:256#L7">NewURLParser</a></h3>
				<pre>func NewURLParser(url <a href="/pkg/builtin/#string">string</a>) *<a href="#URLParser">URLParser</a></pre>
				
				
			
				
				<h3 id="NewURLParserFromLexer">func <a href="/target/URLParser.go?s=356:411#L13">NewURLParserFromLexer</a></h3>
				<pre>func NewURLParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#URLParser">URLParser</a></pre>
				
				
			

			
				
				<h3 id="URLParser.Base_phone_number">func (*URLParser) <a href="/target/URLParser.go?s=7797:7872#L301">Base_phone_number</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Base_phone_number() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Parser for the base phone number.
</p>

				
				
			
				
				<h3 id="URLParser.Escaped">func (*URLParser) <a href="/target/URLParser.go?s=3827:3892#L150">Escaped</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Escaped() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.Global_phone_number">func (*URLParser) <a href="/target/URLParser.go?s=10008:10101#L382">Global_phone_number</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Global_phone_number() (tn *<a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#TelephoneNumber">TelephoneNumber</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.Hvalue">func (*URLParser) <a href="/target/URLParser.go?s=15199:15263#L563">Hvalue</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Hvalue() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.IsEscaped">func (*URLParser) <a href="/target/URLParser.go?s=3486:3525#L139">IsEscaped</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) IsEscaped() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="URLParser.IsMark">func (*URLParser) <a href="/target/URLParser.go?s=540:585#L20">IsMark</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) IsMark(next <a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="URLParser.IsReserved">func (*URLParser) <a href="/target/URLParser.go?s=2934:2983#L115">IsReserved</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) IsReserved(next <a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="URLParser.IsReservedNoSlash">func (*URLParser) <a href="/target/URLParser.go?s=915:971#L37">IsReservedNoSlash</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) IsReservedNoSlash(next <a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="URLParser.IsUnreserved">func (*URLParser) <a href="/target/URLParser.go?s=760:811#L32">IsUnreserved</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) IsUnreserved(next <a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="URLParser.IsUserUnreserved">func (*URLParser) <a href="/target/URLParser.go?s=1245:1298#L50">IsUserUnreserved</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) IsUserUnreserved(la <a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Missing &#39;=&#39; bug in character set - discovered by interop testing
at SIPIT 13 by Bob Johnson and Scott Holben.
</p>

				
				
			
				
				<h3 id="URLParser.Local_number">func (*URLParser) <a href="/target/URLParser.go?s=8491:8561#L327">Local_number</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Local_number() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Parser for the local phone #.
</p>

				
				
			
				
				<h3 id="URLParser.Local_phone_number">func (*URLParser) <a href="/target/URLParser.go?s=10645:10737#L405">Local_phone_number</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Local_phone_number() (tn *<a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#TelephoneNumber">TelephoneNumber</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.Mark">func (*URLParser) <a href="/target/URLParser.go?s=4471:4533#L172">Mark</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Mark() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.ParamNameOrValue">func (*URLParser) <a href="/target/URLParser.go?s=1831:1905#L77">ParamNameOrValue</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) ParamNameOrValue() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Name or value of a parameter.
</p>

				
				
			
				
				<h3 id="URLParser.Parse">func (*URLParser) <a href="/target/URLParser.go?s=17932:18002#L655">Parse</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Parse() (url <a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#URI">URI</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.ParseTelephoneNumber">func (*URLParser) <a href="/target/URLParser.go?s=9278:9372#L358">ParseTelephoneNumber</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) ParseTelephoneNumber() (tn *<a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#TelephoneNumber">TelephoneNumber</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Parser for telephone subscriber.
</p>
<pre>*
*@return the parsed telephone number.
</pre>

				
				
			
				
				<h3 id="URLParser.Password">func (*URLParser) <a href="/target/URLParser.go?s=17344:17410#L633">Password</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Password() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.PeekScheme">func (*URLParser) <a href="/target/URLParser.go?s=14642:14710#L543">PeekScheme</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) PeekScheme() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.Qheader">func (*URLParser) <a href="/target/URLParser.go?s=14959:15034#L555">Qheader</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Qheader() (nv *<a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#NameValue">NameValue</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Get a name value for a given query header (ie one that comes
</p>
<pre>* after the ?).
</pre>

				
				
			
				
				<h3 id="URLParser.Reserved">func (*URLParser) <a href="/target/URLParser.go?s=3157:3223#L127">Reserved</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Reserved() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.SipURL">func (*URLParser) <a href="/target/URLParser.go?s=12238:12316#L469">SipURL</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) SipURL() (sipurl *<a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#SipUri">SipUri</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.TelURL">func (*URLParser) <a href="/target/URLParser.go?s=11794:11876#L454">TelURL</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) TelURL() (telUrl *<a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#TelURLImpl">TelURLImpl</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Parse and return a structure for a Tel URL.
</p>
<pre>*@return a parsed tel url structure.
</pre>

				
				
			
				
				<h3 id="URLParser.Tel_parameters">func (*URLParser) <a href="/target/URLParser.go?s=11362:11449#L436">Tel_parameters</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Tel_parameters() (nvl *<a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#NameValueList">NameValueList</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.Unreserved">func (*URLParser) <a href="/target/URLParser.go?s=1454:1522#L62">Unreserved</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Unreserved() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.UriParam">func (*URLParser) <a href="/target/URLParser.go?s=2423:2499#L97">UriParam</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) UriParam() (nv *<a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#NameValue">NameValue</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="URLParser.UriReference">func (*URLParser) <a href="/target/URLParser.go?s=6606:6683#L259">UriReference</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) UriReference() (url <a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#URI">URI</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Parse and return a structure for a generic URL.
</p>
<pre>* Note that non SIP URLs are just stored as a string (not parsed).
*@return URI is a URL structure for a SIP url.
*@throws ParsException if there was a problem parsing.
</pre>

				
				
			
				
				<h3 id="URLParser.Uric">func (*URLParser) <a href="/target/URLParser.go?s=4892:4928#L189">Uric</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) Uric() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
			
				
				<h3 id="URLParser.UricNoSlash">func (*URLParser) <a href="/target/URLParser.go?s=5513:5556#L216">UricNoSlash</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) UricNoSlash() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
			
				
				<h3 id="URLParser.UricString">func (*URLParser) <a href="/target/URLParser.go?s=6174:6216#L242">UricString</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) UricString() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
			
				
				<h3 id="URLParser.UrlString">func (*URLParser) <a href="/target/URLParser.go?s=16170:16237#L590">UrlString</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) UrlString() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* Scan forward until you hit a terminating character for a URL.
</p>
<pre>* We do not handle non sip urls in this implementation.
*@return the string that takes us to the end of this URL (i.e. to
* the next delimiter).
</pre>

				
				
			
				
				<h3 id="URLParser.User">func (*URLParser) <a href="/target/URLParser.go?s=16675:16737#L607">User</a></h3>
				<pre>func (this *<a href="#URLParser">URLParser</a>) User() (s <a href="/pkg/builtin/#string">string</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="UnsupportedParser">type <a href="/target/UnsupportedParser.go?s=342:391#L9">UnsupportedParser</a></h2>
			<pre>type UnsupportedParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for Unsupported header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewUnsupportedParser">func <a href="/target/UnsupportedParser.go?s=502:566#L16">NewUnsupportedParser</a></h3>
				<pre>func NewUnsupportedParser(unsupported <a href="/pkg/builtin/#string">string</a>) *<a href="#UnsupportedParser">UnsupportedParser</a></pre>
				<p>
* Creates a new instance of UnsupportedParser
</p>
<pre>* @param unsupported - Unsupported header to parse
</pre>

				
			
				
				<h3 id="NewUnsupportedParserFromLexer">func <a href="/target/UnsupportedParser.go?s=737:808#L25">NewUnsupportedParserFromLexer</a></h3>
				<pre>func NewUnsupportedParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#UnsupportedParser">UnsupportedParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer - the lexer to use to parse the header
</pre>

				
			

			
				
				<h3 id="UnsupportedParser.Parse">func (*UnsupportedParser) <a href="/target/UnsupportedParser.go?s=1054:1133#L35">Parse</a></h3>
				<pre>func (this *<a href="#UnsupportedParser">UnsupportedParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (Unsupported object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="UserAgentParser">type <a href="/target/UserAgentParser.go?s=363:410#L11">UserAgentParser</a></h2>
			<pre>type UserAgentParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for UserAgent header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewUserAgentParser">func <a href="/target/UserAgentParser.go?s=497:555#L19">NewUserAgentParser</a></h3>
				<pre>func NewUserAgentParser(userAgent <a href="/pkg/builtin/#string">string</a>) *<a href="#UserAgentParser">UserAgentParser</a></pre>
				<p>
* Constructor
</p>
<pre>         * @param userAgent - UserAgent header to parse
	 *
</pre>

				
			
				
				<h3 id="NewUserAgentParserFromLexer">func <a href="/target/UserAgentParser.go?s=703:770#L28">NewUserAgentParserFromLexer</a></h3>
				<pre>func NewUserAgentParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#UserAgentParser">UserAgentParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param lexer - the lexer to use.
</pre>

				
			

			
				
				<h3 id="UserAgentParser.Parse">func (*UserAgentParser) <a href="/target/UserAgentParser.go?s=1012:1089#L38">Parse</a></h3>
				<pre>func (this *<a href="#UserAgentParser">UserAgentParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (UserAgent object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="ViaParser">type <a href="/target/ViaParser.go?s=121:162#L2">ViaParser</a></h2>
			<pre>type ViaParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for via headers.
</p>


			

			

			

			
				
				<h3 id="NewViaParser">func <a href="/target/ViaParser.go?s=166:206#L6">NewViaParser</a></h3>
				<pre>func NewViaParser(via <a href="/pkg/builtin/#string">string</a>) *<a href="#ViaParser">ViaParser</a></pre>
				
				
			
				
				<h3 id="NewViaParserFromLexer">func <a href="/target/ViaParser.go?s=283:338#L12">NewViaParserFromLexer</a></h3>
				<pre>func NewViaParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#ViaParser">ViaParser</a></pre>
				
				
			

			
				
				<h3 id="ViaParser.NameValue">func (*ViaParser) <a href="/target/ViaParser.go?s=2628:2705#L110">NameValue</a></h3>
				<pre>func (this *<a href="#ViaParser">ViaParser</a>) NameValue() (nv *<a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#NameValue">NameValue</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="ViaParser.Parse">func (*ViaParser) <a href="/target/ViaParser.go?s=3826:3897#L160">Parse</a></h3>
				<pre>func (this *<a href="#ViaParser">ViaParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="ViaParser.ParseVia">func (*ViaParser) <a href="/target/ViaParser.go?s=488:557#L20">ParseVia</a></h3>
				<pre>func (this *<a href="#ViaParser">ViaParser</a>) ParseVia(v *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Via">Via</a>) (ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
*  a parser for the essential part of the via header.
</p>

				
				
			
		
			
			
			<h2 id="WWWAuthenticateParser">type <a href="/target/WWWAuthenticateParser.go?s=347:403#L9">WWWAuthenticateParser</a></h2>
			<pre>type WWWAuthenticateParser struct {
    <a href="#ChallengeParser">ChallengeParser</a>
}</pre>
			<p>
* Parser for WWW authenitcate header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewWWWAuthenticateParser">func <a href="/target/WWWAuthenticateParser.go?s=476:552#L16">NewWWWAuthenticateParser</a></h3>
				<pre>func NewWWWAuthenticateParser(wwwAuthenticate <a href="/pkg/builtin/#string">string</a>) *<a href="#WWWAuthenticateParser">WWWAuthenticateParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param wwwAuthenticate -  message to parse
</pre>

				
			
				
				<h3 id="NewWWWAuthenticateParserFromLexer">func <a href="/target/WWWAuthenticateParser.go?s=712:791#L25">NewWWWAuthenticateParserFromLexer</a></h3>
				<pre>func NewWWWAuthenticateParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#WWWAuthenticateParser">WWWAuthenticateParser</a></pre>
				<p>
* Cosntructor
</p>
<pre>* @param  lexer - lexer to use.
</pre>

				
			

			
				
				<h3 id="WWWAuthenticateParser.Parse">func (*WWWAuthenticateParser) <a href="/target/WWWAuthenticateParser.go?s=1048:1131#L35">Parse</a></h3>
				<pre>func (this *<a href="#WWWAuthenticateParser">WWWAuthenticateParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (WWWAuthenticate object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
			
			
			<h2 id="WarningParser">type <a href="/target/WarningParser.go?s=350:395#L10">WarningParser</a></h2>
			<pre>type WarningParser struct {
    <a href="#HeaderParser">HeaderParser</a>
}</pre>
			<p>
* Parser for Warning header.
*
*@version  JAIN-SIP-1.1
*
*@author Olivier Deruelle &lt;deruelle@nist.gov&gt;  &lt;br/&gt;
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
* @version 1.0
</p>


			

			

			

			
				
				<h3 id="NewWarningParser">func <a href="/target/WarningParser.go?s=466:518#L17">NewWarningParser</a></h3>
				<pre>func NewWarningParser(warning <a href="/pkg/builtin/#string">string</a>) *<a href="#WarningParser">WarningParser</a></pre>
				<p>
* Constructor
</p>
<pre>* @param warning - Warning header to parse
</pre>

				
			
				
				<h3 id="NewWarningParserFromLexer">func <a href="/target/WarningParser.go?s=662:725#L26">NewWarningParserFromLexer</a></h3>
				<pre>func NewWarningParserFromLexer(lexer <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#Lexer">Lexer</a>) *<a href="#WarningParser">WarningParser</a></pre>
				<p>
* Cosntructor
</p>
<pre>* @param lexer - the lexer to use.
</pre>

				
			

			
				
				<h3 id="WarningParser.Parse">func (*WarningParser) <a href="/target/WarningParser.go?s=967:1042#L36">Parse</a></h3>
				<pre>func (this *<a href="#WarningParser">WarningParser</a>) Parse() (sh <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
* parse the String message
</p>
<pre>* @return SIPHeader (WarningList object)
* @throws SIPParseException if the message does not respect the spec.
</pre>

				
				
			
		
	

	





