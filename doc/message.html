<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "gosip/message"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				
			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
			
			
				
				<dd><a href="#Message">type Message</a></dd>
				
				
			
				
				<dd><a href="#Request">type Request</a></dd>
				
				
			
				
				<dd><a href="#Response">type Response</a></dd>
				
				
			
				
				<dd><a href="#Router">type Router</a></dd>
				
				
			
				
				<dd><a href="#SIPMessage">type SIPMessage</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSIPMessage">func NewSIPMessage() *SIPMessage</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.AddHeader">func (this *SIPMessage) AddHeader(sipHeader header.Header)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.AddUnparsed">func (this *SIPMessage) AddUnparsed(unparsed string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.AttachHeader">func (this *SIPMessage) AttachHeader(h header.Header)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.AttachHeader2">func (this *SIPMessage) AttachHeader2(h header.Header, replaceflag bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.AttachHeader3">func (this *SIPMessage) AttachHeader3(h header.Header, replaceFlag, top bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.EncodeAsBytes">func (this *SIPMessage) EncodeAsBytes() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetAuthorization">func (this *SIPMessage) GetAuthorization() *header.Authorization</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetCSeq">func (this *SIPMessage) GetCSeq() header.CSeqHeader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetCSeqNumber">func (this *SIPMessage) GetCSeqNumber() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetCallId">func (this *SIPMessage) GetCallId() header.CallIdHeader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetCallIdentifier">func (this *SIPMessage) GetCallIdentifier() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetContactHeaders">func (this *SIPMessage) GetContactHeaders() *header.ContactList</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetContent">func (this *SIPMessage) GetContent() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetContentDisposition">func (this *SIPMessage) GetContentDisposition() header.ContentDispositionHeader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetContentEncoding">func (this *SIPMessage) GetContentEncoding() header.ContentEncodingHeader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetContentLanguage">func (this *SIPMessage) GetContentLanguage() header.ContentLanguageHeader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetContentLength">func (this *SIPMessage) GetContentLength() header.ContentLengthHeader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetContentTypeHeader">func (this *SIPMessage) GetContentTypeHeader() header.ContentTypeHeader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetErrorInfoHeaders">func (this *SIPMessage) GetErrorInfoHeaders() *header.ErrorInfoList</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetExpires">func (this *SIPMessage) GetExpires() header.ExpiresHeader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetFrom">func (this *SIPMessage) GetFrom() header.FromHeader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetFromTag">func (this *SIPMessage) GetFromTag() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetHeader">func (this *SIPMessage) GetHeader(headerName string) header.Header</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetHeaderList">func (this *SIPMessage) GetHeaderList(headerName string) header.Lister</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetHeaderNames">func (this *SIPMessage) GetHeaderNames() *list.List</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetHeaders">func (this *SIPMessage) GetHeaders(headerName string) header.Lister</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetMaxForwards">func (this *SIPMessage) GetMaxForwards() header.MaxForwardsHeader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetMessageAsEncodedStrings">func (this *SIPMessage) GetMessageAsEncodedStrings() *list.List</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetMessageContent">func (this *SIPMessage) GetMessageContent() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetMinExpires">func (this *SIPMessage) GetMinExpires() *header.MinExpires</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetOrganizationHeader">func (this *SIPMessage) GetOrganizationHeader() *header.Organization</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetPriorityHeader">func (this *SIPMessage) GetPriorityHeader() *header.Priority</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetProxyAuthorizationHeader">func (this *SIPMessage) GetProxyAuthorizationHeader() *header.ProxyAuthorization</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetRecordRouteHeaders">func (this *SIPMessage) GetRecordRouteHeaders() *header.RecordRouteList</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetRouteHeaders">func (this *SIPMessage) GetRouteHeaders() *header.RouteList</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetSIPHeaderList">func (this *SIPMessage) GetSIPHeaderList(headerName string) header.SIPHeaderLister</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetTo">func (this *SIPMessage) GetTo() header.ToHeader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetToTag">func (this *SIPMessage) GetToTag() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetTopmostVia">func (this *SIPMessage) GetTopmostVia() *header.Via</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetTransactionId">func (this *SIPMessage) GetTransactionId() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetUnrecognizedHeaders">func (this *SIPMessage) GetUnrecognizedHeaders() *list.List</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.GetViaHeaders">func (this *SIPMessage) GetViaHeaders() *header.ViaList</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.HasContent">func (this *SIPMessage) HasContent() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.HasFromTag">func (this *SIPMessage) HasFromTag() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.HasHeader">func (this *SIPMessage) HasHeader(headerName string) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.HasToTag">func (this *SIPMessage) HasToTag() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.IsRequestHeader">func (this *SIPMessage) IsRequestHeader(sipHeader header.Header) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.IsResponseHeader">func (this *SIPMessage) IsResponseHeader(sipHeader header.Header) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.RemoveContent">func (this *SIPMessage) RemoveContent()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.RemoveHeader">func (this *SIPMessage) RemoveHeader(headerName string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.RemoveHeader2">func (this *SIPMessage) RemoveHeader2(headerName string, top bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetCSeq">func (this *SIPMessage) SetCSeq(cseqHeader header.CSeqHeader)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetCallId">func (this *SIPMessage) SetCallId(callId header.CallIdHeader)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetCallIdFromString">func (this *SIPMessage) SetCallIdFromString(callId string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetContent">func (this *SIPMessage) SetContent(content interface{}, contentTypeHeader header.ContentTypeHeader)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetContentDisposition">func (this *SIPMessage) SetContentDisposition(contentDispositionHeader header.ContentDispositionHeader)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetContentEncoding">func (this *SIPMessage) SetContentEncoding(contentEncodingHeader header.ContentEncodingHeader)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetContentLanguage">func (this *SIPMessage) SetContentLanguage(contentLanguageHeader header.ContentLanguageHeader)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetContentLength">func (this *SIPMessage) SetContentLength(contentLength header.ContentLengthHeader)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetExpires">func (this *SIPMessage) SetExpires(expiresHeader header.ExpiresHeader)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetFrom">func (this *SIPMessage) SetFrom(from header.FromHeader)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetFromTag">func (this *SIPMessage) SetFromTag(tag string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetHeader">func (this *SIPMessage) SetHeader(sipHeader header.Header)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetHeaderFromSIPHeaderList">func (this *SIPMessage) SetHeaderFromSIPHeaderList(sipHeaderList header.SIPHeaderLister)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetHeaders">func (this *SIPMessage) SetHeaders(headers *list.List)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetMaxForwards">func (this *SIPMessage) SetMaxForwards(maxForwards header.MaxForwardsHeader)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetMessageContent">func (this *SIPMessage) SetMessageContent(content string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetMessageContent3">func (this *SIPMessage) SetMessageContent3(t string, subType string, messageContent []byte)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetMessageContentFromByte">func (this *SIPMessage) SetMessageContentFromByte(content []byte)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetMessageContentFromString">func (this *SIPMessage) SetMessageContentFromString(t string, subType string, messageContent string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetMinExpiresHeader">func (this *SIPMessage) SetMinExpiresHeader(minExpires header.MinExpiresHeader)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetTo">func (this *SIPMessage) SetTo(to header.ToHeader)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetToTag">func (this *SIPMessage) SetToTag(tag string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.SetVia">func (this *SIPMessage) SetVia(viaList *header.ViaList)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPMessage.String">func (this *SIPMessage) String() string</a></dd>
				
			
				
				<dd><a href="#SIPRequest">type SIPRequest</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSIPRequest">func NewSIPRequest() *SIPRequest</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.CheckHeaders">func (this *SIPRequest) CheckHeaders() (ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.CreateACKRequest">func (this *SIPRequest) CreateACKRequest() *SIPRequest</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.CreateAckRequest">func (this *SIPRequest) CreateAckRequest(responseToHeader *header.To) *SIPRequest</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.CreateBYERequest">func (this *SIPRequest) CreateBYERequest(switchHeaders bool) *SIPRequest</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.CreateCancelRequest">func (this *SIPRequest) CreateCancelRequest() *SIPRequest</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.CreateResponse">func (this *SIPRequest) CreateResponse(statusCode int) *SIPResponse</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.CreateResponse2">func (this *SIPRequest) CreateResponse2(statusCode int, reasonPhrase string) *SIPResponse</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.CreateSIPRequest">func (this *SIPRequest) CreateSIPRequest(requestLine *header.RequestLine, switchHeaders bool) *SIPRequest</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.EncodeAsBytes">func (this *SIPRequest) EncodeAsBytes() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.GetDialogId">func (this *SIPRequest) GetDialogId(isServer bool) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.GetDialogId2">func (this *SIPRequest) GetDialogId2(isServer bool, toTag string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.GetFirstLine">func (this *SIPRequest) GetFirstLine() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.GetMessageAsEncodedStrings">func (this *SIPRequest) GetMessageAsEncodedStrings() *list.List</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.GetMethod">func (this *SIPRequest) GetMethod() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.GetRequestLine">func (this *SIPRequest) GetRequestLine() *header.RequestLine</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.GetRequestURI">func (this *SIPRequest) GetRequestURI() address.URI</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.GetSIPVersion">func (this *SIPRequest) GetSIPVersion() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.GetTransaction">func (this *SIPRequest) GetTransaction() core.GenericObject</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.GetViaHost">func (this *SIPRequest) GetViaHost() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.GetViaPort">func (this *SIPRequest) GetViaPort() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.SetDefaults">func (this *SIPRequest) SetDefaults()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.SetMethod">func (this *SIPRequest) SetMethod(method string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.SetRequestLine">func (this *SIPRequest) SetRequestLine(requestLine *header.RequestLine)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.SetRequestLineDefaults">func (this *SIPRequest) SetRequestLineDefaults()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.SetRequestURI">func (this *SIPRequest) SetRequestURI(uri address.URI)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.SetSIPVersion">func (this *SIPRequest) SetSIPVersion(sipVersion string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.SetTransaction">func (this *SIPRequest) SetTransaction(transaction core.GenericObject)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPRequest.String">func (this *SIPRequest) String() string</a></dd>
				
			
				
				<dd><a href="#SIPResponse">type SIPResponse</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSIPResponse">func NewSIPResponse() *SIPResponse</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.CheckHeaders">func (this *SIPResponse) CheckHeaders() (ParseException error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.CreateRequest">func (this *SIPResponse) CreateRequest(requestURI address.SipURI, via *header.Via, cseq *header.CSeq) *SIPRequest</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.EncodeAsBytes">func (this *SIPResponse) EncodeAsBytes() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.GetDialogId">func (this *SIPResponse) GetDialogId(isServer bool) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.GetDialogId2">func (this *SIPResponse) GetDialogId2(isServer bool, toTag string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.GetFirstLine">func (this *SIPResponse) GetFirstLine() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.GetMessageAsEncodedStrings">func (this *SIPResponse) GetMessageAsEncodedStrings() *list.List</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.GetReasonPhrase">func (this *SIPResponse) GetReasonPhrase() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.GetReasonPhraseFromInt">func (this *SIPResponse) GetReasonPhraseFromInt(rc int) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.GetSIPVersion">func (this *SIPResponse) GetSIPVersion() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.GetStatusCode">func (this *SIPResponse) GetStatusCode() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.GetStatusLine">func (this *SIPResponse) GetStatusLine() *header.StatusLine</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.IsFinalResponse">func (this *SIPResponse) IsFinalResponse() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.IsFinalResponseFromInt">func (this *SIPResponse) IsFinalResponseFromInt(rc int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.SetReasonPhrase">func (this *SIPResponse) SetReasonPhrase(reasonPhrase string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.SetSIPVersion">func (this *SIPResponse) SetSIPVersion(sipVersion string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.SetStatusCode">func (this *SIPResponse) SetStatusCode(statusCode int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.SetStatusLine">func (this *SIPResponse) SetStatusLine(sl *header.StatusLine)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SIPResponse.String">func (this *SIPResponse) String() string</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/Message.go">Message.go</a>
			
				<a href="/target/Request.go">Request.go</a>
			
				<a href="/target/Response.go">Response.go</a>
			
				<a href="/target/Router.go">Router.go</a>
			
				<a href="/target/SIPMessage.go">SIPMessage.go</a>
			
				<a href="/target/SIPRequest.go">SIPRequest.go</a>
			
				<a href="/target/SIPResponse.go">SIPResponse.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const <span id="ACCEPTED">ACCEPTED</span> = 202</pre>
				<p>
*
</p>
<pre>* The Acceptable extension response code signifies that the request has
* been accepted for processing, but the processing has not been completed.
* The request might or might not eventually be acted upon, as it might be
* disallowed when processing actually takes place. There is no facility
* for re-sending a status code from an asynchronous operation such as this.
* The 202 response is intentionally non-committal. Its purpose is to allow
* a server to accept a request for some other process (perhaps a
* batch-oriented process that is only run once per day) without requiring
* that the user agent&#39;s connection to the server persist until the process
* is completed. The entity returned with this response SHOULD include an
* indication of the request&#39;s current status and either a pointer to a
* status monitor or some estimate of when the user can expect the request
* to be fulfilled. This response code is specific to the event notification
* framework.
*
* @since v1.1
</pre>

			
				<pre>const <span id="ACK">ACK</span> = &#34;ACK&#34;</pre>
				<p>
*
</p>
<pre>* An ACK is used to acknowledge the successful receipt
* of a message in a transaction. It is also used to illustrate the
* successful setup of a dialog via the a three-way handshake between an
* UAC and an UAS for an Invite transaction.
</pre>

			
				<pre>const <span id="ADDRESS_INCOMPLETE">ADDRESS_INCOMPLETE</span> = 484</pre>
				<p>
*
</p>
<pre>* The server received a request with a Request-URI that was incomplete.
* Additional information SHOULD be provided in the reason phrase. This
* status code allows overlapped dialing. With overlapped dialing, the
* client does not know the length of the dialing string. It sends strings
* of increasing lengths, prompting the user for more input, until it no
* longer receives a 484 (Address Incomplete) status response.
</pre>

			
				<pre>const <span id="ALTERNATIVE_SERVICE">ALTERNATIVE_SERVICE</span> = 380</pre>
				<p>
*
</p>
<pre>* The call was not successful, but alternative services are possible. The
* alternative services are described in the message body of the response.
* Formats for such bodies are not defined here, and may be the subject of
* future standardization.
</pre>

			
				<pre>const <span id="AMBIGUOUS">AMBIGUOUS</span> = 485</pre>
				<p>
*
</p>
<pre>* The Request-URI was ambiguous. The response MAY contain a listing of
* possible unambiguous addresses in Contact header fields. Revealing
* alternatives can infringe on privacy of the user or the organization.
* It MUST be possible to configure a server to respond with status 404
* (Not Found) or to suppress the listing of possible choices for ambiguous
* Request-URIs. Some email and voice mail systems provide this
* functionality. A status code separate from 3xx is used since the
* semantics are different: for 300, it is assumed that the same person or
* service will be reached by the choices provided. While an automated
* choice or sequential search makes sense for a 3xx response, user
* intervention is required for a 485 (Ambiguous) response.
</pre>

			
				<pre>const <span id="BAD_EVENT">BAD_EVENT</span> = 489</pre>
				<p>
*
</p>
<pre>* The Bad Event extension response code is used to indicate that the
* server did not understand the event package specified in a &#34;Event&#34;
* header field. This response code is specific to the event notification
* framework.
*
* @since v1.1
</pre>

			
				<pre>const <span id="BAD_EXTENSION">BAD_EXTENSION</span> = 420</pre>
				<p>
*
</p>
<pre>* The server did not understand the protocol extension specified in a
* Proxy-Require or Require header field. The server MUST include a list of
 * the unsupported extensions in an Unsupported header field in the response.
</pre>

			
				<pre>const <span id="BAD_GATEWAY">BAD_GATEWAY</span> = 502</pre>
				<p>
*
</p>
<pre>* The server, while acting as a gateway or proxy, received an invalid
* response from the downstream server it accessed in attempting to
* fulfill the request.
</pre>

			
				<pre>const <span id="BAD_REQUEST">BAD_REQUEST</span> = 400</pre>
				<p>
*
</p>
<pre>* The request could not be understood due to malformed syntax. The
* Reason-Phrase SHOULD identify the syntax problem in more detail, for
* example, &#34;Missing Call-ID header field&#34;.
</pre>

			
				<pre>const <span id="BUSY_EVERYWHERE">BUSY_EVERYWHERE</span> = 600</pre>
				<p>
*
</p>
<pre>* The callee&#39;s end system was contacted successfully but the callee is
* busy and does not wish to take the call at this time. The response
* MAY indicate a better time to call in the Retry-After header field.
* If the callee does not wish to reveal the reason for declining the call,
* the callee uses status code 603 (Decline) instead. This status response
* is returned only if the client knows that no other end point (such as a
* voice mail system) will answer the request. Otherwise, 486 (Busy Here)
* should be returned.
</pre>

			
				<pre>const <span id="BUSY_HERE">BUSY_HERE</span> = 486</pre>
				<p>
*
</p>
<pre>* The callee&#39;s end system was contacted successfully, but the callee is
* currently not willing or able to take additional calls at this end
* system. The response MAY indicate a better time to call in the Retry-After
* header field. The user could also be available elsewhere, such as
* through a voice mail service. Status 600 (Busy Everywhere) SHOULD be
* used if the client knows that no other end system will be able to accept
* this call.
</pre>

			
				<pre>const <span id="BYE">BYE</span> = &#34;BYE&#34;</pre>
				<p>
*
</p>
<pre>* The BYE request is used to terminate a specific
* session or attempted session. When a BYE is received on a dialog, any
* session associated with that dialog SHOULD terminate. A User Agent MUST
* NOT send a BYE outside of a dialog. The caller&#39;s User Agent MAY send a
* BYE for either confirmed or early dialogs, and the callee&#39;s User Agent
* MAY send a BYE on confirmed dialogs, but MUST NOT send a BYE on early
* dialogs. However, the callee&#39;s User Agent MUST NOT send a BYE on a
* confirmed dialog until it has received an ACK for its 2xx response or
* until the server transaction times out. If no SIP extensions have defined
* other application layer states associated with the dialog, the BYE also
* terminates the dialog.
</pre>

			
				<pre>const <span id="CALL_IS_BEING_FORWARDED">CALL_IS_BEING_FORWARDED</span> = 181</pre>
				<p>
*
</p>
<pre>* A server MAY use this status code to indicate that the call is being
* forwarded to a different set of destinations.
</pre>

			
				<pre>const <span id="CALL_OR_TRANSACTION_DOES_NOT_EXIST">CALL_OR_TRANSACTION_DOES_NOT_EXIST</span> = 481</pre>
				<p>
*
</p>
<pre>* This status indicates that the UAS received a request that does not
* match any existing dialog or transaction.
</pre>

			
				<pre>const <span id="CANCEL">CANCEL</span> = &#34;CANCEL&#34;</pre>
				<p>
*
</p>
<pre>* The CANCEL request is used to cancel a previous
* request sent by a client. Specifically, it asks the UAS to cease
* processing the request and to generate an error response to that request.
* CANCEL has no effect on a request to which a UAS has already given a
* final response. Because of this, it is most useful to CANCEL requests to
* which it can take a server long time to respond. For this reason, CANCEL
* is best for INVITE requests, which can take a long time to generate a
* response.
</pre>

			
				<pre>const <span id="DECLINE">DECLINE</span> = 603</pre>
				<p>
*
</p>
<pre>* The callee&#39;s machine was successfully contacted but the user explicitly
* does not wish to or cannot participate. The response MAY indicate a
* better time to call in the Retry-After header field. This status
* response is returned only if the client knows that no other end point
* will answer the request.
</pre>

			
				<pre>const <span id="DEFAULT_METHOD">DEFAULT_METHOD</span> = <a href="#INVITE">INVITE</a></pre>
				
			
				<pre>const <span id="DEFAULT_TRANSPORT">DEFAULT_TRANSPORT</span> = &#34;udp&#34;</pre>
				
			
				<pre>const <span id="DEFAULT_TTL">DEFAULT_TTL</span> = 1</pre>
				
			
				<pre>const <span id="DEFAULT_USER">DEFAULT_USER</span> = &#34;ip&#34;</pre>
				
			
				<pre>const <span id="DOES_NOT_EXIST_ANYWHERE">DOES_NOT_EXIST_ANYWHERE</span> = 604</pre>
				<p>
*
</p>
<pre>* The server has authoritative information that the user indicated in the
* Request-URI does not exist anywhere.
</pre>

			
				<pre>const <span id="EXTENSION_REQUIRED">EXTENSION_REQUIRED</span> = 421</pre>
				<p>
*
</p>
<pre>* The UAS needs a particular extension to process the request, but this
* extension is not listed in a Supported header field in the request.
* Responses with this status code MUST contain a Require header field
* listing the required extensions.
* &lt;p&gt;
* A UAS SHOULD NOT use this response unless it truly cannot provide any
* useful service to the client. Instead, if a desirable extension is not
* listed in the Supported header field, servers SHOULD process the request
* using baseline SIP capabilities and any extensions supported by the
* client.
*
* @since v1.1
</pre>

			
				<pre>const <span id="FORBIDDEN">FORBIDDEN</span> = 403</pre>
				<p>
*
</p>
<pre>* The server understood the request, but is refusing to fulfill it.
* Authorization will not help, and the request SHOULD NOT be repeated.
</pre>

			
				<pre>const <span id="GONE">GONE</span> = 410</pre>
				<p>
*
</p>
<pre>* The requested resource is no longer available at the server and no
* forwarding address is known. This condition is expected to be considered
* permanent. If the server does not know, or has no facility to determine,
* whether or not the condition is permanent, the status code 404
* (Not Found) SHOULD be used instead.
</pre>

			
				<pre>const <span id="INFO">INFO</span> = &#34;INFO&#34;</pre>
				<p>
*
</p>
<pre>* INFO is an extension method which allows for the carrying of session
* related control information that is generated during a session. One
* example of such session control information is ISUP and ISDN signaling
* messages used to control telephony call services. The purpose of the INFO
* message is to carry application level information along the SIP signaling
* path. The signaling path for the INFO method is the signaling path
* established as a result of the call setup. This can be either direct
* signaling between the calling and called user agents or a signaling path
* involving SIP proxy servers that were involved in the call setup and added
* themselves to the Record-Route header on the initial INVITE message.
* &lt;p&gt;
* The INFO method is used for communicating mid-session signaling
* information, it is not used to change the state of SIP calls, nor does it
* change the state of sessions initiated by SIP. Rather, it provides
* additional optional information which can further enhance the application
* using SIP. The mid-session information can be communicated in either an
* INFO message header or as part of a message body. There are no specific
* semantics associated with INFO. The semantics are derived from the body
* or new headers defined for usage in INFO. JAIN SIP provides the
* facility to send {@link javax.sip.header.ExtensionHeader} in messages.
* The INFO request MAY contain a message body. Bodies which imply a change
* in the SIP call state or the sessions initiated by SIP MUST NOT be sent
* in an INFO message.
*
* @since v1.1
</pre>

			
				<pre>const <span id="INTERVAL_TOO_BRIEF">INTERVAL_TOO_BRIEF</span> = 423</pre>
				<p>
*
</p>
<pre>* The server is rejecting the request because the expiration time of the
* resource refreshed by the request is too short. This response can be
* used by a registrar to reject a registration whose Contact header field
* expiration time was too small.
*
* @since v1.1
</pre>

			
				<pre>const <span id="INVITE">INVITE</span> = &#34;INVITE&#34;</pre>
				<p>
*
</p>
<pre>* The INVITE method is used by an user agent client that desires to
* initiate a session, session examples include, audio, video, or a game. The
* INVITE request asks a server to establish a session. This request may be
* forwarded by proxies, eventually arriving at one or more UAS&#39;s that can
* potentially accept the invitation. These UAS&#39;s will frequently need to
* query the user about whether to accept the invitation. After some time,
* those UAS&#39;s can accept the invitation (meaning the session is to be
* established) by sending a 2xx response. If the invitation is not
* accepted, a 3xx, 4xx, 5xx or 6xx response is sent, depending on the
* reason for the rejection. Before sending a final response, the UAS can
* also send provisional responses (1xx) to advise the UAC of progress in
* contacting the called user.
</pre>

			
				<pre>const <span id="LOOP_DETECTED">LOOP_DETECTED</span> = 482</pre>
				<p>
*
</p>
<pre>* The server has detected a loop.
</pre>

			
				<pre>const <span id="MESSAGE">MESSAGE</span> = &#34;MESSAGE&#34;</pre>
				<p>
*
</p>
<pre>* Message is an extension method that allows the transfer of Instant Messages.
* The MESSAGE request inherits all the request routing and security
* features of SIP. MESSAGE requests carry the content in the form of MIME
* body parts. The actual communication between participants happens in the
* media sessions, not in the SIP requests themselves. The MESSAGE method
* changes this assumption.
* &lt;p&gt;
* MESSAGE requests do not themselves initiate a SIP dialog; under
* normal usage each Instant Message stands alone, much like pager
* messages, that is there are no explicit association between messages.
* MESSAGE requests may be sent in the context of a dialog initiated by some
* other SIP request. If a MESSAGE request is sent within a dialog, it is
* &#34;associated&#34; with any media session or sessions associated with that dialog.
* &lt;p&gt;
* When a user wishes to send an instant message to another, the sender
* formulates and issues a Message request. The Request-URI of this request
* will normally be the &#34;address of record&#34; for the recipient of the instant
* message, but it may be a device address in situations where the client
* has current information about the recipient&#39;s location. The body of the
* request will contain the message to be delivered.
* &lt;p&gt;
* Provisional and final responses to the request will be returned to the
* sender as with any other SIP request. Normally, a 200 OK response will be
* generated by the user agent of the request&#39;s final recipient. Note that
* this indicates that the user agent accepted the message, not that the
* user has seen it.
* &lt;p&gt;
* The UAC MAY add an Expires header field to limit the validity of the message
* content. If the UAC adds an Expires header field with a non-zero value, it
* SHOULD also add a Date header field containing the time the message is sent.
* Most SIP requests are used to setup and modify communication sessions.
*
* @since v1.1
</pre>

			
				<pre>const <span id="MESSAGE_TOO_LARGE">MESSAGE_TOO_LARGE</span> = 513</pre>
				<p>
*
</p>
<pre>* The server was unable to process the request since the message length
* exceeded its capabilities.
*
* @since v1.1
</pre>

			
				<pre>const <span id="METHOD_NOT_ALLOWED">METHOD_NOT_ALLOWED</span> = 405</pre>
				<p>
*
</p>
<pre>* The method specified in the Request-Line is understood, but not allowed
* for the address identified by the Request-URI. The response MUST include
* an Allow header field containing a list of valid methods for the
* indicated address
</pre>

			
				<pre>const <span id="MOVED_PERMANENTLY">MOVED_PERMANENTLY</span> = 301</pre>
				<p>
*
</p>
<pre>* The user can no longer be found at the address in the Request-URI, and
* the requesting client SHOULD retry at the new address given by the
* Contact header field. The requestor SHOULD update any local directories,
* address books, and user location caches with this new value and redirect
* future requests to the address(es) listed.
</pre>

			
				<pre>const <span id="MOVED_TEMPORARILY">MOVED_TEMPORARILY</span> = 302</pre>
				<p>
*
</p>
<pre>* The requesting client SHOULD retry the request at the new address(es)
* given by the Contact header field. The Request-URI of the new request
* uses the value of the Contact header field in the response.
* &lt;p&gt;
* The duration of the validity of the Contact URI can be indicated through
* an Expires header field or an expires parameter in the Contact header
* field. Both proxies and User Agents MAY cache this URI for the duration
* of the expiration time. If there is no explicit expiration time, the
* address is only valid once for recursing, and MUST NOT be cached for
* future transactions.
* &lt;p&gt;
* If the URI cached from the Contact header field fails, the Request-URI
* from the redirected request MAY be tried again a single time. The
* temporary URI may have become out-of-date sooner than the expiration
* time, and a new temporary URI may be available.
</pre>

			
				<pre>const <span id="MULTIPLE_CHOICES">MULTIPLE_CHOICES</span> = 300</pre>
				<p>
*
</p>
<pre>* The address in the request resolved to several choices, each with its
* own specific location, and the user (or UA) can select a preferred
* communication end point and redirect its request to that location.
* &lt;p&gt;
* The response MAY include a message body containing a list of resource
* characteristics and location(s) from which the user or UA can choose
* the one most appropriate, if allowed by the Accept request header field.
* However, no MIME types have been defined for this message body.
* &lt;p&gt;
* The choices SHOULD also be listed as Contact fields. Unlike HTTP, the
* SIP response MAY contain several Contact fields or a list of addresses
* in a Contact field. User Agents MAY use the Contact header field value
* for automatic redirection or MAY ask the user to confirm a choice.
* However, this specification does not define any standard for such
* automatic selection.
* &lt;p&gt;
* This status response is appropriate if the callee can be reached at
* several different locations and the server cannot or prefers not to
* proxy the request.
</pre>

			
				<pre>const <span id="NOTIFY">NOTIFY</span> = &#34;NOTIFY&#34;</pre>
				<p>
*
</p>
<pre>* Notify is an extension method that informs subscribers of changes in state
* to which the subscriber has a subscription. Subscriptions are typically
* put in place using the SUBSCRIBE method; however, it is possible that
* other means have been used.
* &lt;p&gt;
* When a SUBSCRIBE request is answered with a 200-class response, the
* notifier MUST immediately construct and send a NOTIFY request to the
* subscriber. When a change in the subscribed state occurs, the notifier
* SHOULD immediately construct and send a NOTIFY request, subject to
* authorization, local policy, and throttling considerations.
* &lt;p&gt;
* A NOTIFY does not terminate its corresponding subscription. i.e. a single
* SUBSCRIBE request may trigger several NOTIFY requests. NOTIFY requests
* MUST contain a &#34;Subscription-State&#34; header with a value of &#34;active&#34;,
* &#34;pending&#34;, or &#34;terminated&#34;. As in SUBSCRIBE requests, NOTIFY &#34;Event&#34;
* headers will contain a single event package name for which a notification
* is being generated. The package name in the &#34;Event&#34; header MUST match
* the &#34;Event&#34; header in the corresponding SUBSCRIBE message. If an &#34;id&#34;
* parameter was present in the SUBSCRIBE message, that &#34;id&#34; parameter MUST
* also be present in the corresponding NOTIFY messages.
* &lt;p&gt;
* Event packages may define semantics associated with the body of their
* NOTIFY requests; if they do so, those semantics apply. NOTIFY bodies
* are expected to provide additional details about the nature of the event
* which has occurred and the resultant resource state. When present, the
* body of the NOTIFY request MUST be formatted into one of the body formats
* specified in the &#34;Accept&#34; header of the corresponding SUBSCRIBE request.
* This body will contain either the state of the subscribed resource or a
* pointer to such state in the form of a URI
* &lt;p&gt;
* A NOTIFY request is considered failed if the response times out, or a
* non-200 class response code is received which has no &#34;Retry-After&#34;
* header and no implied further action which can be taken to retry the
* request. If a NOTIFY request receives a 481 response, the notifier MUST
* remove the corresponding subscription even if such subscription was
* installed by non-SUBSCRIBE means.
* &lt;p&gt;
* If necessary, clients may probe for the support of NOTIFY using the
* OPTIONS. The presence of the &#34;Allow-Events&#34; header in a message is
* sufficient to indicate support for NOTIFY. The &#34;methods&#34; parameter for
* Contact may also be used to specifically announce support for NOTIFY
* messages when registering.
*
* @since v1.1
</pre>

			
				<pre>const <span id="NOT_ACCEPTABLE">NOT_ACCEPTABLE</span> = 406</pre>
				<p>
*
</p>
<pre>* The resource identified by the request is only capable of generating
* response entities that have content characteristics not acceptable
* according to the Accept header field sent in the request.
</pre>

			
				<pre>const <span id="NOT_ACCEPTABLE_HERE">NOT_ACCEPTABLE_HERE</span> = 488</pre>
				<p>
*
</p>
<pre>* The response has the same meaning as 606 (Not Acceptable), but only
* applies to the specific resource addressed by the Request-URI and the
* request may succeed elsewhere. A message body containing a description
* of media capabilities MAY be present in the response, which is formatted
* according to the Accept header field in the INVITE (or application/sdp
* if not present), the same as a message body in a 200 (OK) response to
* an OPTIONS request.
*
* @since v1.1
</pre>

			
				<pre>const <span id="NOT_FOUND">NOT_FOUND</span> = 404</pre>
				<p>
*
</p>
<pre>* The server has definitive information that the user does not exist at
* the domain specified in the Request-URI.  This status is also returned
* if the domain in the Request-URI does not match any of the domains
* handled by the recipient of the request.
</pre>

			
				<pre>const <span id="NOT_IMPLEMENTED">NOT_IMPLEMENTED</span> = 501</pre>
				<p>
*
</p>
<pre>* The server does not support the functionality required to fulfill the
* request. This is the appropriate response when a UAS does not recognize
* the request method and is not capable of supporting it for any user.
* Proxies forward all requests regardless of method. Note that a 405
* (Method Not Allowed) is sent when the server recognizes the request
* method, but that method is not allowed or supported.
</pre>

			
				<pre>const <span id="OK">OK</span> = 200</pre>
				<p>
*
</p>
<pre>* The request has succeeded. The information returned with the response
* depends on the method used in the request.
</pre>

			
				<pre>const <span id="OPTIONS">OPTIONS</span> = &#34;OPTIONS&#34;</pre>
				<p>
*
</p>
<pre>* The OPTIONS method allows a User Agent to query
* another User Agent or a proxy server as to its capabilities. This allows
* a client to discover information about the supported methods, content
* types, extensions, codecs, etc. without &#34;ringing&#34; the other party. For
* example, before a client inserts a Require header field into an INVITE
* listing an option that it is not certain the destination UAS supports,
* the client can query the destination UAS with an OPTIONS to see if this
* option is returned in a Supported header field. All User Agents MUST
* support the OPTIONS method.
</pre>

			
				<pre>const <span id="PAYMENT_REQUIRED">PAYMENT_REQUIRED</span> = 402</pre>
				<p>
*
</p>
<pre>* Reserved for future use.
</pre>

			
				<pre>const <span id="PRACK">PRACK</span> = &#34;PRACK&#34;</pre>
				<p>
*
</p>
<pre>* PRACK is an extension method that plays the same role as ACK, but for
* provisional responses. PRACK is a normal SIP message, like BYE. As such,
* its own reliability is ensured hop-by-hop through each stateful
* proxy. Also like BYE, but unlike ACK, PRACK has its own response.
* In order to achieve reliability of provisional responses, in a similiar
* manner to 2xx final responses to INVITE, reliable provisional responses
* are retransmitted with an exponential backoff, which cease when a PRACK
* message is received. The PRACK messages contain an RAck header field,
* which indicates the sequence number of the provisional response that is
* being acknowledged.
* &lt;p&gt;
* PRACK is like any other request within a dialog, and is treated likewise.
* In particular, a UAC SHOULD NOT retransmit the PRACK request when it
* receives a retransmission of the provisional response being acknowledged,
* although doing so does not create a protocol error. A matching PRACK is
* defined as one within the same dialog as the response, and whose
* method, CSeq-num, and RSeq-num in the RAck header field match,
* respectively, the method and sequence number from the CSeq and the
* sequence number from the RSeq header of the reliable provisional response.
* PRACK requests MAY contain bodies, which are interpreted according to
* their type and disposition.
*
* @since v1.1
</pre>

			
				<pre>const <span id="PROXY_AUTHENTICATION_REQUIRED">PROXY_AUTHENTICATION_REQUIRED</span> = 407</pre>
				<p>
*
</p>
<pre>* This code is similar to 401 (Unauthorized), but indicates that the client
* MUST first authenticate itself with the proxy. This status code can be
* used for applications where access to the communication channel (for
* example, a telephony gateway) rather than the callee requires
* authentication.
</pre>

			
				<pre>const <span id="QUEUED">QUEUED</span> = 182</pre>
				<p>
*
</p>
<pre>* The called party is temporarily unavailable, but the server has decided
* to queue the call rather than reject it. When the callee becomes
* available, it will return the appropriate final status response. The
* reason phrase MAY give further details about the status of the call,
* for example, &#34;5 calls queued; expected waiting time is 15 minutes&#34;. The
* server MAY issue several 182 (Queued) responses to update the caller
* about the status of the queued call.
</pre>

			
				<pre>const <span id="REFER">REFER</span> = &#34;REFER&#34;</pre>
				<p>
*
</p>
<pre>* Refer is an extension method that requests that the recipient REFER to a
* resource provided in the request, this can be used to enable many
* applications such as Call Transfer. The REFER method indicates that
* the recipient (identified by the Request-URI) should contact a third
* party using the contact information provided in the request. A REFER
* request MUST contain exactly one Refer-To header field value and MAY
* contain a body. A receiving agent may choose to process the body
* according to its Content-Type.
* &lt;p&gt;
* A User Agent accepting a well-formed REFER request SHOULD request
* approval from the user to proceed. If approval is granted, the User
* Agent MUST contact the resource identified by the URI. SIP proxies do
* not require modification to support the REFER method. A proxy should
* process a REFER request the same way it processes an OPTIONS request.
* &lt;p&gt;
* A REFER request implicitly establishes a subscription to the &#34;refer&#34;
* event. The agent issuing the REFER can terminate this subscription
* prematurely by unsubscribing. A REFER request MAY be placed outside
* the scope of a dialog created with an INVITE. REFER creates a dialog,
* and MAY be Record-Routed, hence MUST contain a single Contact header
* field value. REFERs occurring inside an existing dialog MUST follow
* the Route/Record-Route logic of that dialog. The NOTIFY mechanism MUST
* be used to inform the agent sending the REFER of the status of the
* reference. The dialog identifiers of each NOTIFY must match those of
* the REFER as they would if the REFER had been a SUBSCRIBE request. If
* more than one REFER is issued in the same dialog, the dialog
* identifiers do not provide enough information to associate the
* resulting NOTIFYs with the proper REFER. Therefore it MUST include an
* &#34;id&#34; parameter in the Event header field of each NOTIFY containing the
* sequence number of the REFER this NOTIFY is associated with. A REFER
* sent within the scope of an existing dialog will not fork. A REFER
* sent outside the context of a dialog MAY fork, and if it is accepted
* by multiple agents, MAY create multiple subscriptions.
*
* @since v1.1
</pre>

			
				<pre>const <span id="REGISTER">REGISTER</span> = &#34;REGISTER&#34;</pre>
				<p>
*
</p>
<pre>* The REGISTER method requests the addition,
* removal, and query of bindings. A REGISTER request can add a new binding
* between an address-of-record and one or more contact addresses.
* Registration on behalf of a particular address-of-record can be performed
* by a suitably authorized third party. A client can also remove previous
* bindings or query to determine which bindings are currently in place for
* an address-of-record. A REGISTER request does not establish a dialog.
* Registration entails sending a REGISTER request to a special type of UAS
* known as a registrar. A registrar acts as the front end to the location
* service for a domain, reading and writing mappings based on the contents
* of REGISTER requests. This location service is then typically consulted
* by a proxy server that is responsible for routing requests for that domain.
</pre>

			
				<pre>const <span id="REQUEST_ENTITY_TOO_LARGE">REQUEST_ENTITY_TOO_LARGE</span> = 413</pre>
				<p>
*
</p>
<pre>* The server is refusing to process a request because the request
* entity-body is larger than the server is willing or able to process. The
* server MAY close the connection to prevent the client from continuing
* the request. If the condition is temporary, the server SHOULD include a
* Retry-After header field to indicate that it is temporary and after what
* time the client MAY try again.
*
* @since v1.1
</pre>

			
				<pre>const <span id="REQUEST_PENDING">REQUEST_PENDING</span> = 491</pre>
				<p>
*
</p>
<pre>* The request was received by a UAS that had a pending request within
* the same dialog.
*
* @since v1.1
</pre>

			
				<pre>const <span id="REQUEST_TERMINATED">REQUEST_TERMINATED</span> = 487</pre>
				<p>
*
</p>
<pre>* The request was terminated by a BYE or CANCEL request. This response is
* never returned for a CANCEL request itself.
*
* @since v1.1
</pre>

			
				<pre>const <span id="REQUEST_TIMEOUT">REQUEST_TIMEOUT</span> = 408</pre>
				<p>
*
</p>
<pre>* The server could not produce a response within a suitable amount of
* time, for example, if it could not determine the location of the user
* in time. The client MAY repeat the request without modifications at
* any later time.
</pre>

			
				<pre>const <span id="REQUEST_URI_TOO_LONG">REQUEST_URI_TOO_LONG</span> = 414</pre>
				<p>
*
</p>
<pre>* The server is refusing to service the request because the Request-URI
* is longer than the server is willing to interpret.
*
* @since v1.1
</pre>

			
				<pre>const <span id="RINGING">RINGING</span> = 180</pre>
				<p>
*
</p>
<pre>* The User Agent receiving the INVITE is trying to alert the user. This
* response MAY be used to initiate local ringback.
</pre>

			
				<pre>const <span id="SERVER_INTERNAL_ERROR">SERVER_INTERNAL_ERROR</span> = 500</pre>
				<p>
*
</p>
<pre>* The server encountered an unexpected condition that prevented it from
* fulfilling the request. The client MAY display the specific error
* condition and MAY retry the request after several seconds. If the
* condition is temporary, the server MAY indicate when the client may
* retry the request using the Retry-After header field.
</pre>

			
				<pre>const <span id="SERVER_TIMEOUT">SERVER_TIMEOUT</span> = 504</pre>
				<p>
*
</p>
<pre>* The server did not receive a timely response from an external server
* it accessed in attempting to process the request. 408 (Request Timeout)
* should be used instead if there was no response within the
* period specified in the Expires header field from the upstream server.
</pre>

			
				<pre>const <span id="SERVICE_UNAVAILABLE">SERVICE_UNAVAILABLE</span> = 503</pre>
				<p>
*
</p>
<pre>* The server is temporarily unable to process the request due to a
* temporary overloading or maintenance of the server. The server MAY
* indicate when the client should retry the request in a Retry-After
* header field. If no Retry-After is given, the client MUST act as if it
* had received a 500 (Server Internal Error) response.
* &lt;p&gt;
* A client (proxy or UAC) receiving a 503 (Service Unavailable) SHOULD
* attempt to forward the request to an alternate server. It SHOULD NOT
* forward any other requests to that server for the duration specified
* in the Retry-After header field, if present.
* &lt;p&gt;
* Servers MAY refuse the connection or drop the request instead of
* responding with 503 (Service Unavailable).
*
* @since v1.1
</pre>

			
				<pre>const <span id="SESSION_NOT_ACCEPTABLE">SESSION_NOT_ACCEPTABLE</span> = 606</pre>
				<p>
*
</p>
<pre>* The user&#39;s agent was contacted successfully but some aspects of the
* session description such as the requested media, bandwidth, or addressing
* style were not acceptable. A 606 (Not Acceptable) response means that
* the user wishes to communicate, but cannot adequately support the
* session described. The 606 (Not Acceptable) response MAY contain a list
* of reasons in a Warning header field describing why the session described
* cannot be supported.
* &lt;p&gt;
* A message body containing a description of media capabilities MAY be
* present in the response, which is formatted according to the Accept
* header field in the INVITE (or application/sdp if not present), the same
* as a message body in a 200 (OK) response to an OPTIONS request.
* &lt;p&gt;
* It is hoped that negotiation will not frequently be needed, and when a
* new user is being invited to join an already existing conference,
* negotiation may not be possible. It is up to the invitation initiator to
* decide whether or not to act on a 606 (Not Acceptable) response.
* &lt;p&gt;
* This status response is returned only if the client knows that no other
* end point will answer the request. This specification renames this
* status code from NOT_ACCEPTABLE as in RFC3261 to SESSION_NOT_ACCEPTABLE
* due to it conflict with 406 (Not Acceptable) defined in this interface.
</pre>

			
				<pre>const <span id="SESSION_PROGRESS">SESSION_PROGRESS</span> = 183</pre>
				<p>
*
</p>
<pre>* The 183 (Session Progress) response is used to convey information about
* the progress of the call that is not otherwise classified. The
* Reason-Phrase, header fields, or message body MAY be used to convey more
* details about the call progress.
*
* @since v1.1
</pre>

			
				<pre>const <span id="SUBSCRIBE">SUBSCRIBE</span> = &#34;SUBSCRIBE&#34;</pre>
				<p>
*
</p>
<pre>* Subscribe is an extension method that is used to request current state
* and state updates from a remote node. SUBSCRIBE requests SHOULD contain
* an &#34;Expires&#34; header, which indicates the duration of the subscription.
* In order to keep subscriptions effective beyond the duration communicated
* in the &#34;Expires&#34; header, subscribers need to refresh subscriptions on a
* periodic basis using a new SUBSCRIBE message on the same dialog. If no
* &#34;Expires&#34; header is present in a SUBSCRIBE request, the implied default
* is defined by the event package being used.
* &lt;p&gt;
* 200-class responses to a SUBSCRIBE request indicate that the subscription
* has been accepted, and that a NOTIFY will be sent immediately. If the
* subscription resource has no meaningful state at the time that the SUBSCRIBE
* message is processed, this NOTIFY message MAY contain an empty or neutral body.
* 200-class responses to SUBSCRIBE requests also MUST contain an &#34;Expires&#34;
* header. The period of time in the response MAY be shorter but MUST NOT be
* longer than specified in the request. The period of time in the response
* is the one which defines the duration of the subscription. An &#34;expires&#34;
* parameter on the &#34;Contact&#34; header has no semantics for SUBSCRIBE and is
* explicitly not equivalent to an &#34;Expires&#34; header in a SUBSCRIBE request
* or response.
* &lt;p&gt;
* The Request URI of a SUBSCRIBE request, contains enough information to
* route the request to the appropriate entity. It also contains enough
* information to identify the resource for which event notification is
* desired, but not necessarily enough information to uniquely identify the
* nature of the event. Therefore Subscribers MUST include exactly one
* &#34;Event&#34; header in SUBSCRIBE requests, indicating to which event or class
* of events they are subscribing. The &#34;Event&#34; header will contain a token
* which indicates the type of state for which a subscription is being
* requested.
* &lt;p&gt;
* As SUBSCRIBE requests create a dialog, they MAY contain an &#34;Accept&#34;
* header. This header, if present, indicates the body formats allowed in
* subsequent NOTIFY requests. Event packages MUST define the behavior for
* SUBSCRIBE requests without &#34;Accept&#34; headers. If an initial SUBSCRIBE is
* sent on a pre-existing dialog, a matching 200-class response or successful
* NOTIFY request merely creates a new subscription associated with that
* dialog. Multiple subscriptions can be associated with a single dialog.
* &lt;p&gt;
* Unsubscribing is handled in the same way as refreshing of a subscription,
* with the &#34;Expires&#34; header set to &#34;0&#34;. Note that a successful unsubscription
* will also trigger a final NOTIFY message.
* &lt;p&gt;
* If necessary, clients may probe for the support of SUBSCRIBE using the
* OPTIONS. The presence of the &#34;Allow-Events&#34; header in a message is
* sufficient to indicate support for SUBSCRIBE. The &#34;methods&#34; parameter for
* Contact may also be used to specifically announce support for SUBSCRIBE
* messages when registering.
*
* @since v1.1
</pre>

			
				<pre>const <span id="TEMPORARILY_UNAVAILABLE">TEMPORARILY_UNAVAILABLE</span> = 480</pre>
				<p>
*
</p>
<pre>* The callee&#39;s end system was contacted successfully but the callee is
* currently unavailable (for example, is not logged in, logged in but in a
* state that precludes communication with the callee, or has activated the
* &#34;do not disturb&#34; feature). The response MAY indicate a better time to
* call in the Retry-After header field. The user could also be available
* elsewhere (unbeknownst to this server). The reason phrase SHOULD indicate
* a more precise cause as to why the callee is unavailable. This value
* SHOULD be settable by the UA. Status 486 (Busy Here) MAY be used to more
* precisely indicate a particular reason for the call failure.
* &lt;p&gt;
* This status is also returned by a redirect or proxy server that
* recognizes the user identified by the Request-URI, but does not currently
* have a valid forwarding location for that user.
*
* @since v1.1
</pre>

			
				<pre>const <span id="TOO_MANY_HOPS">TOO_MANY_HOPS</span> = 483</pre>
				<p>
*
</p>
<pre>* The server received a request that contains a Max-Forwards header field
* with the value zero.
</pre>

			
				<pre>const <span id="TRYING">TRYING</span> = 100</pre>
				<p>
*
</p>
<pre>* This response indicates that the request has been received by the
* next-hop server and that some unspecified action is being taken on
* behalf of this call (for example, a database is being consulted). This
* response, like all other provisional responses, stops retransmissions of
* an INVITE by a UAC. The 100 (Trying) response is different from other
* provisional responses, in that it is never forwarded upstream by a
* stateful proxy.
</pre>

			
				<pre>const <span id="UNAUTHORIZED">UNAUTHORIZED</span> = 401</pre>
				<p>
*
</p>
<pre>* The request requires user authentication. This response is issued by
* UASs and registrars, while 407 (Proxy Authentication Required) is used
* by proxy servers.
</pre>

			
				<pre>const <span id="UNDECIPHERABLE">UNDECIPHERABLE</span> = 493</pre>
				<p>
*
</p>
<pre>* The request was received by a UAS that contained an encrypted MIME body
* for which the recipient does not possess or will not provide an
* appropriate decryption key. This response MAY have a single body
* containing an appropriate public key that should be used to encrypt MIME
* bodies sent to this UA.
*
* @since v1.1
</pre>

			
				<pre>const <span id="UNSUPPORTED_MEDIA_TYPE">UNSUPPORTED_MEDIA_TYPE</span> = 415</pre>
				<p>
*
</p>
<pre>* The server is refusing to service the request because the message body
* of the request is in a format not supported by the server for the
* requested method. The server MUST return a list of acceptable formats
* using the Accept, Accept-Encoding, or Accept-Language header field,
* depending on the specific problem with the content.
</pre>

			
				<pre>const <span id="UNSUPPORTED_URI_SCHEME">UNSUPPORTED_URI_SCHEME</span> = 416</pre>
				<p>
*
</p>
<pre>* The server cannot process the request because the scheme of the URI in
* the Request-URI is unknown to the server.
*
* @since v1.1
</pre>

			
				<pre>const <span id="UPDATE">UPDATE</span> = &#34;UPDATE&#34;</pre>
				<p>
*
</p>
<pre>* UPDATE is an extension method that allows a client to update parameters
* of a session (such as the set of media streams and their codecs) but has
* no impact on the state of a dialog. In that sense, it is like a re-INVITE,
* but unlike re-INVITE, it can be sent before the initial INVITE has been
* completed. This makes it very useful for updating session parameters
* within early dialogs. Operation of this extension is straightforward, the
* caller begins with an INVITE transaction, which proceeds normally. Once a
* dialog is established, the caller can generate an UPDATE method that
* contains an SDP offer for the purposes of updating the session. The
* response to the UPDATE method contains the answer. The Allow header
* field is used to indicate support for the UPDATE method. There are
* additional constraints on when UPDATE can be used, based on the
* restrictions of the offer/answer model. Although UPDATE can be used on
* confirmed dialogs, it is RECOMMENDED that a re-INVITE be used instead.
* This is because an UPDATE needs to be answered immediately, ruling out
* the possibility of user approval. Such approval will frequently be needed,
* and is possible with a re-INVITE.
*
* @since v1.1
</pre>

			
				<pre>const <span id="USE_PROXY">USE_PROXY</span> = 305</pre>
				<p>
*
</p>
<pre>* The requested resource MUST be accessed through the proxy given by the
* Contact field.  The Contact field gives the URI of the proxy. The
* recipient is expected to repeat this single request via the proxy.
* 305 (Use Proxy) responses MUST only be generated by UASs.
</pre>

			
				<pre>const <span id="VERSION_NOT_SUPPORTED">VERSION_NOT_SUPPORTED</span> = 505</pre>
				<p>
*
</p>
<pre>* The server does not support, or refuses to support, the SIP protocol
* version that was used in the request. The server is indicating that
* it is unable or unwilling to complete the request using the same major
* version as the client, other than with this error message.
</pre>

			
		
		
		
		
			
			
			<h2 id="Message">type <a href="/target/Message.go?s=1571:12671#L34">Message</a></h2>
			<pre>type Message interface {

    <span class="comment">/**
     * Adds the new Header to the existing list of Headers contained in this
     * Message. The Header is added to the end of the List and will appear in
     * that order in the SIP Message.
     * &lt;p&gt;
     * Required Headers that are singletons should not be added to the message
     * as they already exist in the message and therefore should be changed using
     * the {@link Message#setHeader(Header)} method.
     * &lt;p&gt;
     * This method should be used to support the special case of adding
     * required ViaHeaders to a message. When adding a ViaHeader using this
     * method the implementation will add the ViaHeader to the top of the
     * ViaHeader list, and not the end like all other Headers.
     *
     * @param header the new Header to be added to the existing Headers List.
     */</span>
    AddHeader(h <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>)

    <span class="comment">/**
     * Removes the Header of the supplied name from the list of headers in
     * this Message. If multiple headers exist then they are all removed from
     * the header list. If no headers exist then this method returns silently.
     * This method should not be used to remove required Headers, required
     * Headers should be replaced using the {@link Message#setHeader(Header)}.
     *
     * @param headername the new string value name of the Header to be
     * removed.
     */</span>
    RemoveHeader(headerName <a href="/pkg/builtin/#string">string</a>)

    <span class="comment">/**
     * Gets a ListIterator over all the header names in this Message. Note
     * that the order of the Header Names in the ListIterator is same as the
     * order in which they appear in the SIP Message.
     *
     * @return the ListIterator over all the Header Names in the Message.
     */</span>
    GetHeaderNames() *<a href="/pkg/container/list/">list</a>.<a href="/pkg/container/list/#List">List</a> <span class="comment">//ListIterator;</span>

    <span class="comment">/**
     * Gets a ListIterator over all the Headers of the newly specified name
     * in this Message. Note that order of the Headers in ListIterator is the
     * same as the order in which they appear in the SIP Message.
     *
     * @param headerName the new string name of Header types requested.
     * @return the ListIterator over all the Headers of the specified name in
     * the Message, this method returns an empty ListIterator if no Headers
     * exist of this header type.
     */</span>
    GetHeaders(headerName <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Lister">Lister</a> <span class="comment">//*list.List //ListIterator;</span>

    <span class="comment">/**
     * Gets the Header of the specified name in this Message. If multiple
     * Headers of this header name exist in the message, the first header
     * in the message is returned.
     *
     * @param headerName the new string name of Header type requested.
     * @return the Header of the specified name in the Message, this method
     * returns null if the Header does not exist.
     */</span>
    GetHeader(headerName <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>

    <span class="comment">/**
     * Gets a ListIterator over all the UnrecognizedHeaders in this
     * Message. Note the order of the UnrecognizedHeaders in the ListIterator is
     * the same as order in which they appeared in the SIP Message.
     * UnrecognizedHeaders are headers that the underlying implementation does
     * not recognize, if a header is recognized but is badly formatted it will
     * be dropped by the underlying implementation and will not be included in
     * this list. A Proxy should not delete UnrecognizedHeaders and should
     * add these Headers to the end of the header list of the Message that is
     * being forwarded. A User Agent may display these unrecognized headers to
     * the user.
     *
     * @return the ListIterator over all the UnrecognizedHeaders in the Message
     * represented as Strings, this method returns an empty ListIterator if no
     * UnrecognizedHeaders exist.
     */</span>
    GetUnrecognizedHeaders() *<a href="/pkg/container/list/">list</a>.<a href="/pkg/container/list/#List">List</a> <span class="comment">//ListIterator;</span>

    <span class="comment">/**
     * Sets the new Header to replace existings Header of that type in
     * the message. If the SIP message contains more than one Header of
     * the new Header type it should replace the first occurance of this
     * Header and removes all other Headers of this type. If no Header of this
     * type exists this header is added to the end of the SIP Message.
     * This method should be used to change required Headers and overwrite
     * optional Headers.
     *
     * @param header the new Header to replace any existing Headers of that
     * type.
     */</span>
    SetHeader(h <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>)

    <span class="comment">/**
     * Set the ContentLengthHeader of this Message.
     * The actual content length for the outgoing message will be computed from
     * the content assigned. If the content is speficied as an object it will
     * be converted to a String before the message is sent out and the content
     * length computed from the length of the string. If the message content is
     * specified in bytes, the length of the byte array specified will be used
     * to determine the content length header, that is in both cases, the length
     * of the content overrides any value specified in the content-length
     * header.
     *
     * @param contentLength the new ContentLengthHeader object containing the
     * content length value of this Message.
     *
     */</span>
    SetContentLength(contentLength <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentLengthHeader">ContentLengthHeader</a>)

    <span class="comment">/**
     * Gets the ContentLengthHeader of the body content of this Message. This is
     * the same as &lt;code&gt;this.getHeader(Content-Length);&lt;/code&gt;
     *
     * @return the ContentLengthHeader of the message body.
     */</span>
    GetContentLength() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentLengthHeader">ContentLengthHeader</a>

    <span class="comment">/**
     * Sets the ContentLanguageHeader of this Message. This overrides the
     * ContentLanguageHeader set using the setHeaders method. If no
     * ContentLanguageHeader exists in this message this ContentLanguageHeader
     * is added to the end of the Header List.
     *
     * @param contentLanguage the new ContentLanguageHeader object containing the
     * content language value of this Message.
     */</span>
    SetContentLanguage(contentLanguage <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentLanguageHeader">ContentLanguageHeader</a>)

    <span class="comment">/**
     * Gets the ContentLanguageHeader of this Message. This is the same as
     * &lt;code&gt;this.getHeader(Content-Langauge);&lt;/code&gt;
     *
     * @return the ContentLanguageHeader of the message body.
     */</span>
    GetContentLanguage() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentLanguageHeader">ContentLanguageHeader</a>

    <span class="comment">/**
     * Sets the ContentEncodingHeader of this Message. This overrides the
     * ContentEncodingHeader set using the setHeaders method. If no
     * ContentEncodingHeader exists in this message this ContentEncodingHeader
     * is added to the end of the Header List.
     *
     * @param contentEncoding the new ContentEncodingHeader object containing the
     * content encoding values of this Message.
     */</span>
    SetContentEncoding(contentEncoding <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentEncodingHeader">ContentEncodingHeader</a>)

    <span class="comment">/**
     * Gets the ContentEncodingHeader of this Message. This is the same as
     * &lt;code&gt;this.getHeader(Content-Encoding);&lt;/code&gt;
     *
     * @return the ContentEncodingHeader of the message body.
     */</span>
    GetContentEncoding() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentEncodingHeader">ContentEncodingHeader</a>

    <span class="comment">/**
     * Sets the ContentDispositionHeader of this Message. This overrides the
     * ContentDispositionHeader set using the setHeaders method. If no
     * ContentDispositionHeader exists in this message this ContentDispositionHeader
     * is added to the end of the Header List.
     *
     * @param contentDisposition the new ContentDispositionHeader object
     * containing the content disposition value of this Message.
     */</span>
    SetContentDisposition(contentDisposition <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentDispositionHeader">ContentDispositionHeader</a>)

    <span class="comment">/**
     * Gets the ContentDispositionHeader of this Message. This is the same as
     * &lt;code&gt;this.getHeader(Content-Disposition);&lt;/code&gt;
     *
     * @return the ContentDispositionHeader of the message body.
     */</span>
    GetContentDisposition() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentDispositionHeader">ContentDispositionHeader</a>

    <span class="comment">/**
       * Sets the body of this Message, with the ContentType defined by the new
       * ContentTypeHeader object and the string value of the content.
       *
      * @param content the new Object value of the content of the Message.
       * @param contentTypeHeader the new ContentTypeHeader object that defines
       * the content type value.
       * @throws ParseException which signals that an error has been reached
       * unexpectedly while parsing the body.
    */</span>
    SetContent(content interface{}, contentTypeHeader <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentTypeHeader">ContentTypeHeader</a>) <span class="comment">//(ParseException error)</span>

    <span class="comment">/**
     * Gets the body content of the Message as an Object.
     *
     * @return the body content of the Message as an Object, this method
     * returns null if a body does not exist.
     */</span>
    GetContent() <a href="/pkg/builtin/#string">string</a>

    <span class="comment">/**
     * Removes the body content from this Message and all associated entity
     * headers, if a body exists, this method returns sliently if no body exists.
     */</span>
    RemoveContent()

    <span class="comment">/**
     * Sets the ExpiresHeader of this Message. This overrides the ExpiresHeader
     * set using the setHeaders method. If no ExpiresHeader exists in this
     * message this ExpiresHeader is added to the end of the Header List.
     *
     * @param expires the new ExpiresHeader object containing the expires
     * values of this Message.
     */</span>
    SetExpires(expires <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ExpiresHeader">ExpiresHeader</a>)

    <span class="comment">/**
     * Gets the ExpiresHeader of this Message. This is the same as
     * &lt;code&gt;this.getHeader(Expires);&lt;/code&gt;
     *
     * @return the ExpiresHeader of the message body.
     */</span>
    GetExpires() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ExpiresHeader">ExpiresHeader</a>

    <span class="comment">/**
     * Sets the protocol version of SIP being used by this Message.
     *
     * @param version the new String object containing the version of the SIP
     * Protocol of this Message.
     * @throws ParseException which signals that an error has been reached
     * unexpectedly while parsing the version argument.
     */</span>
    SetSIPVersion(version <a href="/pkg/builtin/#string">string</a>) <span class="comment">//(ParseException error)</span>

    <span class="comment">/**
     * Gets the protocol version of SIP being used by this Message.
     *
     * @return the protocol version of the SIP protocol of this message.
     */</span>
    GetSIPVersion() <a href="/pkg/builtin/#string">string</a>

    <span class="comment">/**
     * Gets string representation of Message
     * @return string representation of Message
     */</span>
    String() <a href="/pkg/builtin/#string">string</a>

    SetMessageContentFromByte(content []<a href="/pkg/builtin/#byte">byte</a>)
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Request">type <a href="/target/Request.go?s=3452:5109#L59">Request</a></h2>
			<pre>type Request interface {
    <a href="#Message">Message</a>

    <span class="comment">/**
     * Gets method string of this Request message.
     *
     * @return the method of this Request message.
     */</span>
    GetMethod() <a href="/pkg/builtin/#string">string</a>

    <span class="comment">/**
     * Sets the method of Request to the newly supplied value. The standard
     * RFC3261 methods are REGISTER for registering contact information, INVITE,
     * ACK, and CANCEL for setting up sessions, BYE for terminating sessions, and
     * OPTIONS for querying servers about their capabilities.
     *
     * @param method - the new string value of the method of Request
     * @throws ParseException which signals that an error has been reached
     * unexpectedly while parsing the method value.
     */</span>
    SetMethod(method <a href="/pkg/builtin/#string">string</a>) (ParseException <a href="/pkg/builtin/#error">error</a>)

    <span class="comment">/**
     * Gets the URI Object identifying the request URI of this Request, which
     * indicates the user or service to which this request is addressed.
     *
     * @return Request URI of Request
     */</span>
    GetRequestURI() <a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#URI">URI</a>

    <span class="comment">/**
     * Sets the RequestURI of Request. The Request-URI is a SIP or SIPS URI
     * or a general URI. It indicates the user or service to which this request
     * is being addressed. SIP elements MAY support Request-URIs with schemes
     * other than &#34;sip&#34; and &#34;sips&#34;, for example the &#34;tel&#34; URI scheme. SIP
     * elements MAY translate non-SIP URIs using any mechanism at their disposal,
     * resulting in SIP URI, SIPS URI, or some other scheme.
     *
     * @param requestURI - the new Request URI of this request message
     */</span>
    SetRequestURI(requestURI <a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#URI">URI</a>)
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Response">type <a href="/target/Response.go?s=8448:10177#L186">Response</a></h2>
			<pre>type Response interface {
    <a href="#Message">Message</a>

    <span class="comment">/**
     * Sets the status-code of Response. The status-code is a 3-digit integer
     * result code that indicates the outcome of an attempt to understand and
     * satisfy a request.  The Status-Code is intended for use by automata.
     *
     * @param statusCode the new integer value of the status code.
     * @throws ParseException which signals that an error has been reached
     * unexpectedly while parsing the statusCode value.
     */</span>
    SetStatusCode(statusCode <a href="/pkg/builtin/#int">int</a>) (ParseException <a href="/pkg/builtin/#error">error</a>)

    <span class="comment">/**
     * Gets the integer value of the status code of Response, which identifies
     * the outcome of the request to which this response is related.
     *
     * @return the integer status-code of this Response message.
     */</span>
    GetStatusCode() <a href="/pkg/builtin/#int">int</a>

    <span class="comment">/**
     * Sets reason phrase of Response. The reason-phrase is intended to give a
     * short textual description of the status-code. The reason-phrase is
     * intended for the human user. A client is not required to examine or
     * display the reason-phrase. While RFC3261 suggests specific wording for
     * the reason phrase, implementations MAY choose other text.
     *
     * @param reasonPhrase the new string value of the reason phrase.
     * @throws ParseException which signals that an error has been reached
     * unexpectedly while parsing the reasonPhrase value.
     */</span>
    SetReasonPhrase(reasonPhrase <a href="/pkg/builtin/#string">string</a>) (ParseException <a href="/pkg/builtin/#error">error</a>)

    <span class="comment">/**
     * Gets the reason phrase of this Response message.
     *
     * @return the string value of the reason phrase of this Response message.
     */</span>
    GetReasonPhrase() <a href="/pkg/builtin/#string">string</a>
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Router">type <a href="/target/Router.go?s=1507:2196#L29">Router</a></h2>
			<pre>type Router interface {

    <span class="comment">/**
     * Gets the Outbound Proxy parameter of this Router, this method may return
     * null if no outbound proxy is defined.
     *
     * @return the Outbound Proxy of this Router.
     * @see Hop
     */</span>
    GetOutboundProxy() <a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#Hop">Hop</a>

    <span class="comment">/**
     * Gets the ListIterator of the hops of the default Route. This method may
     * return null if a default route is not defined.
     *
     * @param request - the Request message that determines the default route.
     * @return the ListIterator over all the hops of this Router.
     * @see Hop
     */</span>
    GetNextHops(request <a href="#Request">Request</a>) *<a href="/pkg/container/list/">list</a>.<a href="/pkg/container/list/#List">List</a> <span class="comment">//ListIterator</span>

}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="SIPMessage">type <a href="/target/SIPMessage.go?s=397:1195#L16">SIPMessage</a></h2>
			<pre>type SIPMessage struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			
				
				<h3 id="NewSIPMessage">func <a href="/target/SIPMessage.go?s=1500:1532#L53">NewSIPMessage</a></h3>
				<pre>func NewSIPMessage() *<a href="#SIPMessage">SIPMessage</a></pre>
				<p>
/**
</p>
<pre>*
* Constructor: Initializes lists and list headers.
* All the headers for which there can be multiple occurances in
* a message are  derived from the SIPHeaderListClass. All singleton
* headers are derived from SIPHeader class.
*
*/
</pre>

				
			

			
				
				<h3 id="SIPMessage.AddHeader">func (*SIPMessage) <a href="/target/SIPMessage.go?s=52123:52181#L1530">AddHeader</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) AddHeader(sipHeader <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>)</pre>
				<p>
/** Add a SIP header.
</p>
<pre>*@param sipHeader -- sip header to add.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.AddUnparsed">func (*SIPMessage) <a href="/target/SIPMessage.go?s=52815:52867#L1552">AddUnparsed</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) AddUnparsed(unparsed <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
/** Add a header to the unparsed list of headers.
</p>
<pre>*
*@param unparsed -- unparsed header to add to the list.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.AttachHeader">func (*SIPMessage) <a href="/target/SIPMessage.go?s=21604:21657#L586">AttachHeader</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) AttachHeader(h <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>)</pre>
				<p>
/**
</p>
<pre>* Attach a header and die if you Get a duplicate header exception.
* @param h SIPHeader to attach.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.AttachHeader2">func (*SIPMessage) <a href="/target/SIPMessage.go?s=23798:23870#L652">AttachHeader2</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) AttachHeader2(h <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, replaceflag <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
/**
</p>
<pre>* Attach a header to the end of the existing headers in
* this SIPMessage structure.
* This is equivalent to the attachHeader(SIPHeader,replaceflag,false);
* which is the normal way in which headers are attached.
* This was added in support of JAIN-SIP.
*
* @since 1.0 (made this public)
* @param h header to attach.
* @param replaceflag if true then replace a header if it exists.
* @throws SIPDuplicateHeaderException If replaceFlag is false and
* only a singleton header is allowed (fpr example CSeq).
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.AttachHeader3">func (*SIPMessage) <a href="/target/SIPMessage.go?s=24624:24701#L671">AttachHeader3</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) AttachHeader3(h <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>, replaceFlag, top <a href="/pkg/builtin/#bool">bool</a>)</pre>
				
				
				
			
				
				<h3 id="SIPMessage.EncodeAsBytes">func (*SIPMessage) <a href="/target/SIPMessage.go?s=14893:14939#L412">EncodeAsBytes</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) EncodeAsBytes() []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>
/**
</p>
<pre>* Encode the message as a byte array.
* Use this when the message payload is a binary byte array.
*
* @return The Canonical byte array representation of the message
* (including the canonical byte array representation of
* the SDP payload if it exists all in one contiguous byte array).
*
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetAuthorization">func (*SIPMessage) <a href="/target/SIPMessage.go?s=36696:36760#L1040">GetAuthorization</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetAuthorization() *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Authorization">Authorization</a></pre>
				<p>
/**
</p>
<pre>* Get the Authorization header (nil if one does not exist).
* @return Authorization header.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetCSeq">func (*SIPMessage) <a href="/target/SIPMessage.go?s=36298:36349#L1025">GetCSeq</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetCSeq() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#CSeqHeader">CSeqHeader</a></pre>
				<p>
/**
</p>
<pre>* Get the CSeq list of header (nil if one does not exist).
* @return CSeq header
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetCSeqNumber">func (*SIPMessage) <a href="/target/SIPMessage.go?s=36469:36512#L1032">GetCSeqNumber</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetCSeqNumber() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
/** Get the sequence number.
</p>
<pre>* @return the sequence number.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetCallId">func (*SIPMessage) <a href="/target/SIPMessage.go?s=39063:39118#L1111">GetCallId</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetCallId() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#CallIdHeader">CallIdHeader</a></pre>
				<p>
/** Get the CallID header (nil if one does not exist)
</p>
<pre>*
* @return Call-ID header .
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetCallIdentifier">func (*SIPMessage) <a href="/target/SIPMessage.go?s=39999:40049#L1143">GetCallIdentifier</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetCallIdentifier() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
/**
</p>
<pre>* Get the call ID string.
* A conveniance function that returns the stuff following
* the header name for the call id header.
*
*@return the call identifier.
*
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetContactHeaders">func (*SIPMessage) <a href="/target/SIPMessage.go?s=34623:34686#L969">GetContactHeaders</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetContactHeaders() *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContactList">ContactList</a></pre>
				<p>
/**
</p>
<pre>* Get the Contact list of headers (nil if one does not exist).
* @return List containing Contact headers.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetContent">func (*SIPMessage) <a href="/target/SIPMessage.go?s=46619:46662#L1330">GetContent</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetContent() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
/** Get the content of the header.
</p>
<pre>*
*@return the content of the sip message.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetContentDisposition">func (*SIPMessage) <a href="/target/SIPMessage.go?s=55220:55299#L1634">GetContentDisposition</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetContentDisposition() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentDispositionHeader">ContentDispositionHeader</a></pre>
				<p>
/** Get content disposition header or nil if no such header exists.
</p>
<pre>*
* @return the contentDisposition header
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetContentEncoding">func (*SIPMessage) <a href="/target/SIPMessage.go?s=55517:55590#L1642">GetContentEncoding</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetContentEncoding() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentEncodingHeader">ContentEncodingHeader</a></pre>
				<p>
/** Get the content encoding header.
</p>
<pre>*
*@return the contentEncoding header.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetContentLanguage">func (*SIPMessage) <a href="/target/SIPMessage.go?s=55802:55875#L1650">GetContentLanguage</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetContentLanguage() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentLanguageHeader">ContentLanguageHeader</a></pre>
				<p>
/** Get the contentLanguage header.
</p>
<pre>*
*@return the content language header.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetContentLength">func (*SIPMessage) <a href="/target/SIPMessage.go?s=40902:40971#L1177">GetContentLength</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetContentLength() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentLengthHeader">ContentLengthHeader</a></pre>
				<p>
/**
</p>
<pre>* Get the ContentLength header (nil if one does not exist).
*
* @return content-length header.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetContentTypeHeader">func (*SIPMessage) <a href="/target/SIPMessage.go?s=33838:33909#L946">GetContentTypeHeader</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetContentTypeHeader() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentTypeHeader">ContentTypeHeader</a></pre>
				<p>
/**
</p>
<pre>* Get the contentType header (nil if one does not exist).
*@return contentType header
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetErrorInfoHeaders">func (*SIPMessage) <a href="/target/SIPMessage.go?s=34316:34383#L961">GetErrorInfoHeaders</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetErrorInfoHeaders() *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ErrorInfoList">ErrorInfoList</a></pre>
				<p>
/**
</p>
<pre>* Get the ErrorInfo list of headers (nil if one does not exist).
* @return List containing ErrorInfo headers.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetExpires">func (*SIPMessage) <a href="/target/SIPMessage.go?s=56099:56156#L1658">GetExpires</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetExpires() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ExpiresHeader">ExpiresHeader</a></pre>
				<p>
/** Get the exipres header.
</p>
<pre>*
*@return the expires header or nil if one does not exist.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetFrom">func (*SIPMessage) <a href="/target/SIPMessage.go?s=34083:34134#L953">GetFrom</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetFrom() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#FromHeader">FromHeader</a></pre>
				<p>
/** Get the from header.
</p>
<pre>*@return -- the from header.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetFromTag">func (*SIPMessage) <a href="/target/SIPMessage.go?s=51072:51115#L1477">GetFromTag</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetFromTag() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
/**
</p>
<pre>* Return the from tag.
*
*@return the tag from the from header.
*
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetHeader">func (*SIPMessage) <a href="/target/SIPMessage.go?s=33375:33441#L932">GetHeader</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetHeader(headerName <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a></pre>
				<p>
/** Get the first header of the given name.
</p>
<pre>*
*@return header -- the first header of the given name.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetHeaderList">func (*SIPMessage) <a href="/target/SIPMessage.go?s=49647:49717#L1426">GetHeaderList</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetHeaderList(headerName <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Lister">Lister</a></pre>
				
				
				
			
				
				<h3 id="SIPMessage.GetHeaderNames">func (*SIPMessage) <a href="/target/SIPMessage.go?s=53891:53942#L1587">GetHeaderNames</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetHeaderNames() *<a href="/pkg/container/list/">list</a>.<a href="/pkg/container/list/#List">List</a></pre>
				<p>
/** Get the header names.
</p>
<pre>*
*@return a list iterator to a list of header names. These are ordered
* in the same order as are present in the message.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetHeaders">func (*SIPMessage) <a href="/target/SIPMessage.go?s=48968:49035#L1402">GetHeaders</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetHeaders(headerName <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Lister">Lister</a></pre>
				<p>
/** Get a SIP header or Header list given its name.
</p>
<pre>*@param headerName is the name of the header to Get.
*@return a header or header list that contians the retrieved header.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetMaxForwards">func (*SIPMessage) <a href="/target/SIPMessage.go?s=36978:37043#L1048">GetMaxForwards</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetMaxForwards() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#MaxForwardsHeader">MaxForwardsHeader</a></pre>
				<p>
/**
</p>
<pre>* Get the MaxForwards header (nil if one does not exist).
* @return Max-Forwards header
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetMessageAsEncodedStrings">func (*SIPMessage) <a href="/target/SIPMessage.go?s=3938:4001#L149">GetMessageAsEncodedStrings</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetMessageAsEncodedStrings() *<a href="/pkg/container/list/">list</a>.<a href="/pkg/container/list/#List">List</a></pre>
				<p>
/** Get the headers as a linked list of encoded Strings
</p>
<pre>*@return a linked list with each element of the list containing a
* string encoded header in canonical form.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetMessageContent">func (*SIPMessage) <a href="/target/SIPMessage.go?s=41487:41537#L1192">GetMessageContent</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetMessageContent() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
/**
</p>
<pre>* Get the message body as a string.
*	If the message contains a content type header with a specified
*  charSet, and if the payload has been read as a byte array, then
*  it is returned encoded into this charSet.
*
* @return Message body (as a string)
* @throws UnsupportedEncodingException if the platform does not
*  support the charSet specified in the content type header.
*
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetMinExpires">func (*SIPMessage) <a href="/target/SIPMessage.go?s=37410:37468#L1063">GetMinExpires</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetMinExpires() *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#MinExpires">MinExpires</a></pre>
				<p>
/**
</p>
<pre>* Get the MinExpires header.
* @return Min-Expires header
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetOrganizationHeader">func (*SIPMessage) <a href="/target/SIPMessage.go?s=37901:37969#L1079">GetOrganizationHeader</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetOrganizationHeader() *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Organization">Organization</a></pre>
				<p>
/**
</p>
<pre>* Get the Organization header (nil if one does not exist).
* @return Orgnaization header.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetPriorityHeader">func (*SIPMessage) <a href="/target/SIPMessage.go?s=38178:38238#L1087">GetPriorityHeader</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetPriorityHeader() *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Priority">Priority</a></pre>
				<p>
/**
</p>
<pre>* Get the Priority header (nil if one does not exist).
* @return Priority header
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetProxyAuthorizationHeader">func (*SIPMessage) <a href="/target/SIPMessage.go?s=38478:38558#L1095">GetProxyAuthorizationHeader</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetProxyAuthorizationHeader() *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ProxyAuthorization">ProxyAuthorization</a></pre>
				<p>
/**
</p>
<pre>* Get the ProxyAuthorization header (nil if one does not exist).
* @return List containing Proxy-Authorization headers.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetRecordRouteHeaders">func (*SIPMessage) <a href="/target/SIPMessage.go?s=40238:40309#L1152">GetRecordRouteHeaders</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetRecordRouteHeaders() *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#RecordRouteList">RecordRouteList</a></pre>
				<p>
/**
</p>
<pre>* Get the RecordRoute header list (nil if one does not exist).
*
* @return Record-Route header
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetRouteHeaders">func (*SIPMessage) <a href="/target/SIPMessage.go?s=38800:38859#L1103">GetRouteHeaders</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetRouteHeaders() *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#RouteList">RouteList</a></pre>
				<p>
/**
</p>
<pre>* Get the Route List of headers (nil if one does not exist).
* @return List containing Route headers
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetSIPHeaderList">func (*SIPMessage) <a href="/target/SIPMessage.go?s=49478:49560#L1422">GetSIPHeaderList</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetSIPHeaderList(headerName <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#SIPHeaderLister">SIPHeaderLister</a></pre>
				
				
				
			
				
				<h3 id="SIPMessage.GetTo">func (*SIPMessage) <a href="/target/SIPMessage.go?s=40516:40563#L1160">GetTo</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetTo() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ToHeader">ToHeader</a></pre>
				<p>
/**
</p>
<pre>* Get the To header (nil if one does not exist).
* @return To header
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetToTag">func (*SIPMessage) <a href="/target/SIPMessage.go?s=51785:51826#L1514">GetToTag</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetToTag() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
/**
</p>
<pre>* Return the to tag.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetTopmostVia">func (*SIPMessage) <a href="/target/SIPMessage.go?s=35996:36047#L1013">GetTopmostVia</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetTopmostVia() *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Via">Via</a></pre>
				<p>
/** Get the topmost via header.
</p>
<pre>*@return the top most via header if one exists or nil if none exists.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetTransactionId">func (*SIPMessage) <a href="/target/SIPMessage.go?s=31050:31099#L865">GetTransactionId</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetTransactionId() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
/**
</p>
<pre>* Generate (compute) a transaction ID for this SIP message.
* @return A string containing the concatenation of various
* portions of the From,To,Via and RequestURI portions
* of this message as specified in RFC 2543:
* All responses to a request contain the same values in
* the Call-ID, CSeq, To, and From fields
* (with the possible addition of  a tag in the To field
* (section 10.43)). This allows responses to be matched with requests.
* Incorporates a bug fix  for a bug sent in by Gordon Ledgard of
* IPera for generating transactionIDs when no port is present in the
* via header.
* Incorporates a bug fix for a bug report sent in by Chris Mills
* of Nortel Networks (converts to lower case when returning the
* transaction identifier).
*
*@return a string that can be used as a transaction identifier
*  for this message. This can be used for matching responses and
*  requests (i.e. an outgoing request and its matching response have
*	the same computed transaction identifier).
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetUnrecognizedHeaders">func (*SIPMessage) <a href="/target/SIPMessage.go?s=53598:53657#L1578">GetUnrecognizedHeaders</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetUnrecognizedHeaders() *<a href="/pkg/container/list/">list</a>.<a href="/pkg/container/list/#List">List</a></pre>
				<p>
/** Get a list containing the unrecognized headers.
</p>
<pre>*@return a linked list containing unrecongnized headers.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.GetViaHeaders">func (*SIPMessage) <a href="/target/SIPMessage.go?s=34913:34968#L977">GetViaHeaders</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) GetViaHeaders() *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ViaList">ViaList</a></pre>
				<p>
/**
</p>
<pre>* Get the Via list of headers (nil if one does not exist).
* @return List containing Via headers.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.HasContent">func (*SIPMessage) <a href="/target/SIPMessage.go?s=32896:32937#L917">HasContent</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) HasContent() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
/** Return true if this message has a body.
</p>
<pre>*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.HasFromTag">func (*SIPMessage) <a href="/target/SIPMessage.go?s=50544:50585#L1457">HasFromTag</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) HasFromTag() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
/**
</p>
<pre>* Return true if the message has a From header tag.
*
*@return true if the message has a from header and that header has
* 		a tag.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.HasHeader">func (*SIPMessage) <a href="/target/SIPMessage.go?s=50215:50272#L1446">HasHeader</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) HasHeader(headerName <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="SIPMessage.HasToTag">func (*SIPMessage) <a href="/target/SIPMessage.go?s=50842:50881#L1467">HasToTag</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) HasToTag() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
/**
</p>
<pre>* Return true if the message has a To header tag.
*
*@return true if the message has a to header and that header has
* 		a tag.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.IsRequestHeader">func (*SIPMessage) <a href="/target/SIPMessage.go?s=2131:2200#L75">IsRequestHeader</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) IsRequestHeader(sipHeader <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
* Return true if the header belongs only in a Request.
</p>
<pre>*
*@param sipHeader is the header to test.
</pre>

				
				
			
				
				<h3 id="SIPMessage.IsResponseHeader">func (*SIPMessage) <a href="/target/SIPMessage.go?s=3141:3211#L118">IsResponseHeader</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) IsResponseHeader(sipHeader <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
/** Return true if the header belongs only in a response.
</p>
<pre>*
*@param sipHeader is the header to test.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.RemoveContent">func (*SIPMessage) <a href="/target/SIPMessage.go?s=48516:48555#L1389">RemoveContent</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) RemoveContent()</pre>
				<p>
/** Remove the message content if it exists.
</p>
<pre>*
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.RemoveHeader">func (*SIPMessage) <a href="/target/SIPMessage.go?s=28816:28871#L811">RemoveHeader</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) RemoveHeader(headerName <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
/** Remove all headers given its name.
</p>
<pre>*
*@param headerName is the name of the header to remove.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.RemoveHeader2">func (*SIPMessage) <a href="/target/SIPMessage.go?s=27134:27200#L754">RemoveHeader2</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) RemoveHeader2(headerName <a href="/pkg/builtin/#string">string</a>, top <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
/** Remove a header given its name. If multiple headers of a given name
</p>
<pre>* are present then the top flag determines which end to remove headers
* from.
*
*@param headerName is the name of the header to remove.
*@param top -- flag that indicates which end of header list to process.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.SetCSeq">func (*SIPMessage) <a href="/target/SIPMessage.go?s=57494:57555#L1704">SetCSeq</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetCSeq(cseqHeader <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#CSeqHeader">CSeqHeader</a>)</pre>
				
				
				
			
				
				<h3 id="SIPMessage.SetCallId">func (*SIPMessage) <a href="/target/SIPMessage.go?s=39275:39336#L1119">SetCallId</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetCallId(callId <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#CallIdHeader">CallIdHeader</a>)</pre>
				<p>
/** Set the call id header.
</p>
<pre>*
*@param callid -- call idHeader (what else could it be?)
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.SetCallIdFromString">func (*SIPMessage) <a href="/target/SIPMessage.go?s=39535:39593#L1127">SetCallIdFromString</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetCallIdFromString(callId <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
/** Get the CallID header (nil if one does not exist)
</p>
<pre>*
*@param callId -- the call identifier to be assigned to the call id header
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.SetContent">func (*SIPMessage) <a href="/target/SIPMessage.go?s=45560:45659#L1295">SetContent</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetContent(content interface{}, contentTypeHeader <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentTypeHeader">ContentTypeHeader</a>)</pre>
				<p>
/** Set the message content after converting the given object to a
</p>
<pre>* String.
*
*@param content -- content to Set.
*@param contentTypeHeader -- content type header corresponding to
*	content.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.SetContentDisposition">func (*SIPMessage) <a href="/target/SIPMessage.go?s=56610:56713#L1676">SetContentDisposition</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetContentDisposition(contentDispositionHeader <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentDispositionHeader">ContentDispositionHeader</a>)</pre>
				
				
				
			
				
				<h3 id="SIPMessage.SetContentEncoding">func (*SIPMessage) <a href="/target/SIPMessage.go?s=56765:56859#L1680">SetContentEncoding</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetContentEncoding(contentEncodingHeader <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentEncodingHeader">ContentEncodingHeader</a>)</pre>
				
				
				
			
				
				<h3 id="SIPMessage.SetContentLanguage">func (*SIPMessage) <a href="/target/SIPMessage.go?s=56908:57002#L1684">SetContentLanguage</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetContentLanguage(contentLanguageHeader <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentLanguageHeader">ContentLanguageHeader</a>)</pre>
				
				
				
			
				
				<h3 id="SIPMessage.SetContentLength">func (*SIPMessage) <a href="/target/SIPMessage.go?s=57170:57252#L1692">SetContentLength</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetContentLength(contentLength <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentLengthHeader">ContentLengthHeader</a>)</pre>
				<p>
/** Set the content length header.
</p>
<pre>*
*@param contentLength -- content length header.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.SetExpires">func (*SIPMessage) <a href="/target/SIPMessage.go?s=56357:56427#L1667">SetExpires</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetExpires(expiresHeader <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ExpiresHeader">ExpiresHeader</a>)</pre>
				
				
				
			
				
				<h3 id="SIPMessage.SetFrom">func (*SIPMessage) <a href="/target/SIPMessage.go?s=40674:40729#L1168">SetFrom</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetFrom(from <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#FromHeader">FromHeader</a>)</pre>
				
				
				
			
				
				<h3 id="SIPMessage.SetFromTag">func (*SIPMessage) <a href="/target/SIPMessage.go?s=51321:51367#L1489">SetFromTag</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetFromTag(tag <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
/** Set the From Tag.
</p>
<pre>*
*@param tag -- tag to Set in the from header.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.SetHeader">func (*SIPMessage) <a href="/target/SIPMessage.go?s=22181:22239#L605">SetHeader</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetHeader(sipHeader <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>)</pre>
				<p>
/**
</p>
<pre>* Attach a header (replacing the original header).
* @param header SIPHeader that replaces a header of the same type.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.SetHeaderFromSIPHeaderList">func (*SIPMessage) <a href="/target/SIPMessage.go?s=35739:35827#L1006">SetHeaderFromSIPHeaderList</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetHeaderFromSIPHeaderList(sipHeaderList <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#SIPHeaderLister">SIPHeaderLister</a>)</pre>
				
				
				
			
				
				<h3 id="SIPMessage.SetHeaders">func (*SIPMessage) <a href="/target/SIPMessage.go?s=22865:22919#L629">SetHeaders</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetHeaders(headers *<a href="/pkg/container/list/">list</a>.<a href="/pkg/container/list/#List">List</a>)</pre>
				
				
				
			
				
				<h3 id="SIPMessage.SetMaxForwards">func (*SIPMessage) <a href="/target/SIPMessage.go?s=37199:37275#L1055">SetMaxForwards</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetMaxForwards(maxForwards <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#MaxForwardsHeader">MaxForwardsHeader</a>)</pre>
				<p>
/** Set the max forwards header.
</p>
<pre>*@param -- maxForwards is the MaxForwardsHeader to Set.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.SetMessageContent">func (*SIPMessage) <a href="/target/SIPMessage.go?s=47666:47723#L1362">SetMessageContent</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetMessageContent(content <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
/**
</p>
<pre>* Set the message content for this message.
*
* @param content Message body as a string.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.SetMessageContent3">func (*SIPMessage) <a href="/target/SIPMessage.go?s=47189:47280#L1348">SetMessageContent3</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetMessageContent3(t <a href="/pkg/builtin/#string">string</a>, subType <a href="/pkg/builtin/#string">string</a>, messageContent []<a href="/pkg/builtin/#byte">byte</a>)</pre>
				<p>
/** Set the message content for a given type and subtype.
</p>
<pre>*
*@param type is the messge type.
*@param subType is the message subType.
*@param messageContent is the message content as a byte array.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.SetMessageContentFromByte">func (*SIPMessage) <a href="/target/SIPMessage.go?s=48156:48221#L1376">SetMessageContentFromByte</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetMessageContentFromByte(content []<a href="/pkg/builtin/#byte">byte</a>)</pre>
				<p>
/** Set the message content as an array of bytes.
</p>
<pre>*
*@param content is the content of the message as an array of bytes.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.SetMessageContentFromString">func (*SIPMessage) <a href="/target/SIPMessage.go?s=44803:44903#L1275">SetMessageContentFromString</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetMessageContentFromString(t <a href="/pkg/builtin/#string">string</a>, subType <a href="/pkg/builtin/#string">string</a>, messageContent <a href="/pkg/builtin/#string">string</a>)</pre>
				
				
				
			
				
				<h3 id="SIPMessage.SetMinExpiresHeader">func (*SIPMessage) <a href="/target/SIPMessage.go?s=37656:37735#L1071">SetMinExpiresHeader</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetMinExpiresHeader(minExpires <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#MinExpiresHeader">MinExpiresHeader</a>)</pre>
				<p>
/** Set the min expires header.
</p>
<pre>*
*@return the Min-Expires header.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.SetTo">func (*SIPMessage) <a href="/target/SIPMessage.go?s=40595:40644#L1164">SetTo</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetTo(to <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ToHeader">ToHeader</a>)</pre>
				
				
				
			
				
				<h3 id="SIPMessage.SetToTag">func (*SIPMessage) <a href="/target/SIPMessage.go?s=51574:51618#L1502">SetToTag</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetToTag(tag <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
/** Set the to tag.
</p>
<pre>*
*@param tag -- tag to Set.
*/
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.SetVia">func (*SIPMessage) <a href="/target/SIPMessage.go?s=35380:35435#L991">SetVia</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) SetVia(viaList *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ViaList">ViaList</a>)</pre>
				<p>
/** Set A list of via headers.
</p>
<pre>*@param - a list of via headers to add.
*/
</pre>

				
				
			
				
				<h3 id="SIPMessage.String">func (*SIPMessage) <a href="/target/SIPMessage.go?s=12966:13005#L353">String</a></h3>
				<pre>func (this *<a href="#SIPMessage">SIPMessage</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
/**
</p>
<pre>* Encode this message as a string. This is more efficient when
* the payload is a string (rather than a binary array of bytes).
* If the payload cannot be encoded as a UTF-8 string then it is
* simply ignored (will not appear in the encoded message).
* @return The Canonical String representation of the message
* (including the canonical string representation of
* the SDP payload if it exists).
*/
</pre>

				
				
			
		
			
			
			<h2 id="SIPRequest">type <a href="/target/SIPRequest.go?s=767:929#L22">SIPRequest</a></h2>
			<pre>type SIPRequest struct {
    <a href="#SIPMessage">SIPMessage</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
*
* The SIP Request structure-- this belongs to the parser who fills it up.
*  Acknowledgements: Mark Bednarek made a few fixes to this code.
*   Jeff Keyser added two methods that create responses and generate
*   cancel requests from incoming orignial  requests without
*   the additional overhead  of encoding and decoding messages.
*
*@version  JAIN-SIP-1.1
*
*@author M. Ranganathan &lt;mranga@nist.gov&gt;  &lt;br/&gt;
*
*&lt;a href=&#34;{@docRoot}/uncopyright.html&#34;&gt;This code is in the public domain.&lt;/a&gt;
*
</p>


			

			

			

			
				
				<h3 id="NewSIPRequest">func <a href="/target/SIPRequest.go?s=956:988#L33">NewSIPRequest</a></h3>
				<pre>func NewSIPRequest() *<a href="#SIPRequest">SIPRequest</a></pre>
				<p>
* Constructor.
</p>

				
			

			
				
				<h3 id="SIPRequest.CheckHeaders">func (*SIPRequest) <a href="/target/SIPRequest.go?s=3200:3261#L104">CheckHeaders</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) CheckHeaders() (ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
/**
* Check header for constraints.
* (1) Invite options and bye requests can only have SIP URIs in the
* contact headers.
* (2) Request must have cseq, to and from and via headers.
* (3) Method in request URI must match that in CSEQ.
*/
</p>

				
				
			
				
				<h3 id="SIPRequest.CreateACKRequest">func (*SIPRequest) <a href="/target/SIPRequest.go?s=27082:27136#L824">CreateACKRequest</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) CreateACKRequest() *<a href="#SIPRequest">SIPRequest</a></pre>
				<p>
* Create an ACK request from this request. This is suitable for
* generating an ACK for an INVITE  client transaction.
*
*@return an ACK request that is generated from this request.
*
</p>

				
				
			
				
				<h3 id="SIPRequest.CreateAckRequest">func (*SIPRequest) <a href="/target/SIPRequest.go?s=19954:20035#L622">CreateAckRequest</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) CreateAckRequest(responseToHeader *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#To">To</a>) *<a href="#SIPRequest">SIPRequest</a></pre>
				<p>
/** Creates a default ACK SIPRequest message for this original request.
* Note that the defaultACK SIPRequest does not include the
* content of the original SIPRequest. If responSetoHeader
* is nil then the toHeader of this request is used to
* construct the ACK.  Note that tag fields are just copied
* from the original SIP Request.  Added by Jeff Keyser.
*
*@param responSetoHeader To header to use for this request.
*
*@return A SIPRequest with an ACK method.
*/
</p>

				
				
			
				
				<h3 id="SIPRequest.CreateBYERequest">func (*SIPRequest) <a href="/target/SIPRequest.go?s=26669:26741#L812">CreateBYERequest</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) CreateBYERequest(switchHeaders <a href="/pkg/builtin/#bool">bool</a>) *<a href="#SIPRequest">SIPRequest</a></pre>
				<p>
* Create a BYE request from this request.
</p>
<pre>*
*@param switchHeaders is a boolean flag that causes from and
*	isServerTransaction to headers to be swapped. Set this
*	to true if you are the server of the dialog and are generating
*      a BYE request for the dialog.
*@return a new default BYE request.
</pre>

				
				
			
				
				<h3 id="SIPRequest.CreateCancelRequest">func (*SIPRequest) <a href="/target/SIPRequest.go?s=17978:18035#L566">CreateCancelRequest</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) CreateCancelRequest() *<a href="#SIPRequest">SIPRequest</a></pre>
				
				
				
			
				
				<h3 id="SIPRequest.CreateResponse">func (*SIPRequest) <a href="/target/SIPRequest.go?s=14249:14316#L464">CreateResponse</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) CreateResponse(statusCode <a href="/pkg/builtin/#int">int</a>) *<a href="#SIPResponse">SIPResponse</a></pre>
				
				
				
			
				
				<h3 id="SIPRequest.CreateResponse2">func (*SIPRequest) <a href="/target/SIPRequest.go?s=15453:15542#L492">CreateResponse2</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) CreateResponse2(statusCode <a href="/pkg/builtin/#int">int</a>, reasonPhrase <a href="/pkg/builtin/#string">string</a>) *<a href="#SIPResponse">SIPResponse</a></pre>
				
				
				
			
				
				<h3 id="SIPRequest.CreateSIPRequest">func (*SIPRequest) <a href="/target/SIPRequest.go?s=24233:24338#L733">CreateSIPRequest</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) CreateSIPRequest(requestLine *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#RequestLine">RequestLine</a>, switchHeaders <a href="/pkg/builtin/#bool">bool</a>) *<a href="#SIPRequest">SIPRequest</a></pre>
				<p>
/** Create a new default SIPRequest from the original request. Warning:
* the newly created SIPRequest, shares the headers of
* this request but we generate any new headers that we need to modify
* so  the original request is umodified. However, if you modify the
* shared headers after this request is created, then the newly
* created request will also be modified.
* If you want to modify the original request
* without affecting the returned Request
* make sure you clone it before calling this method.
*
* Only required headers are copied.
* &lt;ul&gt;
* &lt;li&gt;
* Contact headers are not included in the newly created request.
* Setting the appropriate sequence number is the responsibility of
* the caller. &lt;/li&gt;
* &lt;li&gt; RouteList is not copied for ACK and CANCEL &lt;/li&gt;
* &lt;li&gt; Note that we DO NOT copy the body of the
* argument into the returned header. We do not copy the content
* type header from the original request either. These have to be
* added seperately and the content length has to be correctly Set
* if necessary the content length is Set to 0 in the returned header.
* &lt;/li&gt;
* &lt;li&gt;Contact List is not copied from the original request.&lt;/li&gt;
* &lt;li&gt;RecordRoute List is not included from original request. &lt;/li&gt;
* &lt;li&gt;Via header is not included from the original request. &lt;/li&gt;
* &lt;/ul&gt;
*
*@param requestLine is the new request line.
*
*@param switchHeaders is a boolean flag that causes to and from
* 	headers to switch (Set this to true if you are the
*	server of the transaction and are generating a BYE
*	request). If the headers are switched, we generate
*	new From and To headers otherwise we just use the
*	incoming headers.
*
*@return a new Default SIP Request which has the requestLine specified.
*
*/
</p>

				
				
			
				
				<h3 id="SIPRequest.EncodeAsBytes">func (*SIPRequest) <a href="/target/SIPRequest.go?s=12788:12834#L421">EncodeAsBytes</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) EncodeAsBytes() []<a href="/pkg/builtin/#byte">byte</a></pre>
				
				
				
			
				
				<h3 id="SIPRequest.GetDialogId">func (*SIPRequest) <a href="/target/SIPRequest.go?s=10092:10149#L338">GetDialogId</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) GetDialogId(isServer <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#string">string</a></pre>
				<p>
/** Get a dialog identifier.
* Generates a string that can be used as a dialog identifier.
</p>
<pre>*
</pre>
<p>
*@param isServer is Set to true if this is the UAS
*	and Set to false if this is the UAC
*/
</p>

				
				
			
				
				<h3 id="SIPRequest.GetDialogId2">func (*SIPRequest) <a href="/target/SIPRequest.go?s=11335:11407#L377">GetDialogId2</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) GetDialogId2(isServer <a href="/pkg/builtin/#bool">bool</a>, toTag <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#string">string</a></pre>
				<p>
/** Get a dialog id given the remote tag.
*/
</p>

				
				
			
				
				<h3 id="SIPRequest.GetFirstLine">func (*SIPRequest) <a href="/target/SIPRequest.go?s=27971:28016#L861">GetFirstLine</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) GetFirstLine() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
*
* Get the first line encoded.
*
*@return a string containing the encoded request line.
</p>

				
				
			
				
				<h3 id="SIPRequest.GetMessageAsEncodedStrings">func (*SIPRequest) <a href="/target/SIPRequest.go?s=8752:8815#L301">GetMessageAsEncodedStrings</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) GetMessageAsEncodedStrings() *<a href="/pkg/container/list/">list</a>.<a href="/pkg/container/list/#List">List</a></pre>
				<p>
/**
* Get the message as a linked list of strings.
* Use this if you want to iterate through the message.
*
*@return a linked list containing the request line and
* headers encoded as strings.
*/
</p>

				
				
			
				
				<h3 id="SIPRequest.GetMethod">func (*SIPRequest) <a href="/target/SIPRequest.go?s=6979:7021#L234">GetMethod</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) GetMethod() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
/** Get the method from the request line.
*@return the method from the request line if the method exits and
* nil if the request line or the method does not exist.
*/
</p>

				
				
			
				
				<h3 id="SIPRequest.GetRequestLine">func (*SIPRequest) <a href="/target/SIPRequest.go?s=1908:1968#L66">GetRequestLine</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) GetRequestLine() *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#RequestLine">RequestLine</a></pre>
				
				
				
			
				
				<h3 id="SIPRequest.GetRequestURI">func (*SIPRequest) <a href="/target/SIPRequest.go?s=5350:5401#L187">GetRequestURI</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) GetRequestURI() <a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#URI">URI</a></pre>
				<p>
/**
* A conveniance function to access the Request URI.
*@return the requestURI if it exists.
*/
</p>

				
				
			
				
				<h3 id="SIPRequest.GetSIPVersion">func (*SIPRequest) <a href="/target/SIPRequest.go?s=28534:28580#L885">GetSIPVersion</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) GetSIPVersion() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
* Get the SIP version.
*
*@return the SIP version from the request line.
</p>

				
				
			
				
				<h3 id="SIPRequest.GetTransaction">func (*SIPRequest) <a href="/target/SIPRequest.go?s=28631:28690#L889">GetTransaction</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) GetTransaction() <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#GenericObject">GenericObject</a></pre>
				
				
				
			
				
				<h3 id="SIPRequest.GetViaHost">func (*SIPRequest) <a href="/target/SIPRequest.go?s=27409:27452#L836">GetViaHost</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) GetViaHost() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
*
* Get the host from the topmost via header.
*
*@return the string representation of the host from the topmost via
* header.
</p>

				
				
			
				
				<h3 id="SIPRequest.GetViaPort">func (*SIPRequest) <a href="/target/SIPRequest.go?s=27689:27729#L847">GetViaPort</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) GetViaPort() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
*
* Get the port from the topmost via header.
*
*@return the port from the topmost via header (5060 if there is
*  no port indicated).
</p>

				
				
			
				
				<h3 id="SIPRequest.SetDefaults">func (*SIPRequest) <a href="/target/SIPRequest.go?s=4295:4332#L143">SetDefaults</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) SetDefaults()</pre>
				<p>
/**
* Set the default values in the request URI if necessary.
*/
</p>

				
				
			
				
				<h3 id="SIPRequest.SetMethod">func (*SIPRequest) <a href="/target/SIPRequest.go?s=6431:6479#L216">SetMethod</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) SetMethod(method <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
/** Set the method.
*@param method is the method to Set.
*@throws IllegalArgumentException if the method is nil
*/
</p>

				
				
			
				
				<h3 id="SIPRequest.SetRequestLine">func (*SIPRequest) <a href="/target/SIPRequest.go?s=2132:2203#L74">SetRequestLine</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) SetRequestLine(requestLine *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#RequestLine">RequestLine</a>)</pre>
				
				
				
			
				
				<h3 id="SIPRequest.SetRequestLineDefaults">func (*SIPRequest) <a href="/target/SIPRequest.go?s=4980:5028#L172">SetRequestLineDefaults</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) SetRequestLineDefaults()</pre>
				<p>
/**
* Patch up the request line as necessary.
*/
</p>

				
				
			
				
				<h3 id="SIPRequest.SetRequestURI">func (*SIPRequest) <a href="/target/SIPRequest.go?s=6125:6179#L205">SetRequestURI</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) SetRequestURI(uri <a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#URI">URI</a>)</pre>
				<p>
/** Sets the RequestURI of Request. The Request-URI is a SIP or
</p>
<pre>* SIPS URI or a general URI. It indicates the user or service to which
* this request  is being addressed. SIP elements MAY support
* Request-URIs with schemes  other than &#34;sip&#34; and &#34;sips&#34;, for
* example the &#34;tel&#34; URI scheme. SIP  elements MAY translate
* non-SIP URIs using any mechanism at their disposal,  resulting
* in SIP URI, SIPS URI, or some other scheme.
*
* @param requestURI - the new Request URI of this request message
*/
</pre>

				
				
			
				
				<h3 id="SIPRequest.SetSIPVersion">func (*SIPRequest) <a href="/target/SIPRequest.go?s=28203:28259#L874">SetSIPVersion</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) SetSIPVersion(sipVersion <a href="/pkg/builtin/#string">string</a>)</pre>
				
				
				
			
				
				<h3 id="SIPRequest.SetTransaction">func (*SIPRequest) <a href="/target/SIPRequest.go?s=28845:28915#L895">SetTransaction</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) SetTransaction(transaction <a href="/pkg/gosip/core/">core</a>.<a href="/pkg/gosip/core/#GenericObject">GenericObject</a>)</pre>
				
				
				
			
				
				<h3 id="SIPRequest.String">func (*SIPRequest) <a href="/target/SIPRequest.go?s=7261:7300#L248">String</a></h3>
				<pre>func (this *<a href="#SIPRequest">SIPRequest</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
			
		
			
			
			<h2 id="SIPResponse">type <a href="/target/SIPResponse.go?s=349:466#L14">SIPResponse</a></h2>
			<pre>type SIPResponse struct {
    <a href="#SIPMessage">SIPMessage</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			
				
				<h3 id="NewSIPResponse">func <a href="/target/SIPResponse.go?s=493:527#L22">NewSIPResponse</a></h3>
				<pre>func NewSIPResponse() *<a href="#SIPResponse">SIPResponse</a></pre>
				<p>
* Constructor.
</p>

				
			

			
				
				<h3 id="SIPResponse.CheckHeaders">func (*SIPResponse) <a href="/target/SIPResponse.go?s=6803:6865#L295">CheckHeaders</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) CheckHeaders() (ParseException <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
/**
</p>
<pre>* Check the response structure. Must have from, to CSEQ and VIA
* headers.
*/
</pre>

				
				
			
				
				<h3 id="SIPResponse.CreateRequest">func (*SIPResponse) <a href="/target/SIPResponse.go?s=15809:15922#L561">CreateRequest</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) CreateRequest(requestURI <a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#SipURI">SipURI</a>, via *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Via">Via</a>, cseq *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#CSeq">CSeq</a>) *<a href="#SIPRequest">SIPRequest</a></pre>
				
				
				
			
				
				<h3 id="SIPResponse.EncodeAsBytes">func (*SIPResponse) <a href="/target/SIPResponse.go?s=11481:11528#L427">EncodeAsBytes</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) EncodeAsBytes() []<a href="/pkg/builtin/#byte">byte</a></pre>
				
				
				
			
				
				<h3 id="SIPResponse.GetDialogId">func (*SIPResponse) <a href="/target/SIPResponse.go?s=12933:12991#L476">GetDialogId</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) GetDialogId(isServer <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#string">string</a></pre>
				<p>
/** Get a dialog identifier.
</p>
<pre>* Generates a string that can be used as a dialog identifier.
*
* @param isServer is Set to true if this is the UAS
* and Set to false if this is the UAC
*/
</pre>

				
				
			
				
				<h3 id="SIPResponse.GetDialogId2">func (*SIPResponse) <a href="/target/SIPResponse.go?s=14122:14195#L512">GetDialogId2</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) GetDialogId2(isServer <a href="/pkg/builtin/#bool">bool</a>, toTag <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
			
				
				<h3 id="SIPResponse.GetFirstLine">func (*SIPResponse) <a href="/target/SIPResponse.go?s=17393:17439#L613">GetFirstLine</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) GetFirstLine() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
/**
</p>
<pre>* Get the encoded first line.
*
*@return the status line encoded.
*
*/
</pre>

				
				
			
				
				<h3 id="SIPResponse.GetMessageAsEncodedStrings">func (*SIPResponse) <a href="/target/SIPResponse.go?s=7863:7927#L335">GetMessageAsEncodedStrings</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) GetMessageAsEncodedStrings() *<a href="/pkg/container/list/">list</a>.<a href="/pkg/container/list/#List">List</a></pre>
				
				
				
			
				
				<h3 id="SIPResponse.GetReasonPhrase">func (*SIPResponse) <a href="/target/SIPResponse.go?s=5114:5163#L239">GetReasonPhrase</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) GetReasonPhrase() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
/** Get the reason phrase.
</p>
<pre>*@return the reason phrase.
*/
</pre>

				
				
			
				
				<h3 id="SIPResponse.GetReasonPhraseFromInt">func (*SIPResponse) <a href="/target/SIPResponse.go?s=601:663#L28">GetReasonPhraseFromInt</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) GetReasonPhraseFromInt(rc <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
			
				
				<h3 id="SIPResponse.GetSIPVersion">func (*SIPResponse) <a href="/target/SIPResponse.go?s=17651:17698#L625">GetSIPVersion</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) GetSIPVersion() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
			
				
				<h3 id="SIPResponse.GetStatusCode">func (*SIPResponse) <a href="/target/SIPResponse.go?s=4496:4540#L219">GetStatusCode</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) GetStatusCode() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
/** Get the staus code (conveniance function).
</p>
<pre>*@return the status code of the status line.
*/
</pre>

				
				
			
				
				<h3 id="SIPResponse.GetStatusLine">func (*SIPResponse) <a href="/target/SIPResponse.go?s=4285:4344#L212">GetStatusLine</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) GetStatusLine() *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#StatusLine">StatusLine</a></pre>
				<p>
/**
</p>
<pre>* Get the status line of the response.
*@return StatusLine
*/
</pre>

				
				
			
				
				<h3 id="SIPResponse.IsFinalResponse">func (*SIPResponse) <a href="/target/SIPResponse.go?s=5699:5746#L258">IsFinalResponse</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) IsFinalResponse() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
/** Is this a final response?
</p>
<pre>*@return true if this is a final response.
*/
</pre>

				
				
			
				
				<h3 id="SIPResponse.IsFinalResponseFromInt">func (*SIPResponse) <a href="/target/SIPResponse.go?s=5500:5560#L251">IsFinalResponseFromInt</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) IsFinalResponseFromInt(rc <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
/** Return true if the response is a final response.
</p>
<pre>*@param rc is the return code.
*@return true if the parameter is between the range 200 and 700.
*/
</pre>

				
				
			
				
				<h3 id="SIPResponse.SetReasonPhrase">func (*SIPResponse) <a href="/target/SIPResponse.go?s=4739:4800#L227">SetReasonPhrase</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) SetReasonPhrase(reasonPhrase <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
/** Set the reason phrase.
</p>
<pre>*@param reasonPhrase the reason phrase.
*@throws IllegalArgumentException if nil string
*/
</pre>

				
				
			
				
				<h3 id="SIPResponse.SetSIPVersion">func (*SIPResponse) <a href="/target/SIPResponse.go?s=17541:17598#L621">SetSIPVersion</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) SetSIPVersion(sipVersion <a href="/pkg/builtin/#string">string</a>)</pre>
				
				
				
			
				
				<h3 id="SIPResponse.SetStatusCode">func (*SIPResponse) <a href="/target/SIPResponse.go?s=3874:3928#L199">SetStatusCode</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) SetStatusCode(statusCode <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
/** Set the status code.
</p>
<pre>*@param statusCode is the status code to Set.
*@throws IlegalArgumentException if invalid status code.
*/
</pre>

				
				
			
				
				<h3 id="SIPResponse.SetStatusLine">func (*SIPResponse) <a href="/target/SIPResponse.go?s=5923:5984#L266">SetStatusLine</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) SetStatusLine(sl *<a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#StatusLine">StatusLine</a>)</pre>
				<p>
/**
</p>
<pre>* Set the status line field.
*@param sl Status line to Set.
*/
</pre>

				
				
			
				
				<h3 id="SIPResponse.String">func (*SIPResponse) <a href="/target/SIPResponse.go?s=7310:7350#L316">String</a></h3>
				<pre>func (this *<a href="#SIPResponse">SIPResponse</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
			
		
	

	





