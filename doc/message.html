<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "gosip/message"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				
			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
			
			
				
				<dd><a href="#Message">type Message</a></dd>
				
				
			
				
				<dd><a href="#Request">type Request</a></dd>
				
				
			
				
				<dd><a href="#Response">type Response</a></dd>
				
				
			
				
				<dd><a href="#Router">type Router</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/Message.go">Message.go</a>
			
				<a href="/target/Request.go">Request.go</a>
			
				<a href="/target/Response.go">Response.go</a>
			
				<a href="/target/Router.go">Router.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const <span id="ACCEPTED">ACCEPTED</span> = 202</pre>
				<p>
*
</p>
<pre>* The Acceptable extension response code signifies that the request has
* been accepted for processing, but the processing has not been completed.
* The request might or might not eventually be acted upon, as it might be
* disallowed when processing actually takes place. There is no facility
* for re-sending a status code from an asynchronous operation such as this.
* The 202 response is intentionally non-committal. Its purpose is to allow
* a server to accept a request for some other process (perhaps a
* batch-oriented process that is only run once per day) without requiring
* that the user agent&#39;s connection to the server persist until the process
* is completed. The entity returned with this response SHOULD include an
* indication of the request&#39;s current status and either a pointer to a
* status monitor or some estimate of when the user can expect the request
* to be fulfilled. This response code is specific to the event notification
* framework.
*
* @since v1.1
</pre>

			
				<pre>const <span id="ACK">ACK</span> = &#34;ACK&#34;</pre>
				<p>
*
</p>
<pre>* An ACK is used to acknowledge the successful receipt
* of a message in a transaction. It is also used to illustrate the
* successful setup of a dialog via the a three-way handshake between an
* UAC and an UAS for an Invite transaction.
</pre>

			
				<pre>const <span id="ADDRESS_INCOMPLETE">ADDRESS_INCOMPLETE</span> = 484</pre>
				<p>
*
</p>
<pre>* The server received a request with a Request-URI that was incomplete.
* Additional information SHOULD be provided in the reason phrase. This
* status code allows overlapped dialing. With overlapped dialing, the
* client does not know the length of the dialing string. It sends strings
* of increasing lengths, prompting the user for more input, until it no
* longer receives a 484 (Address Incomplete) status response.
</pre>

			
				<pre>const <span id="ALTERNATIVE_SERVICE">ALTERNATIVE_SERVICE</span> = 380</pre>
				<p>
*
</p>
<pre>* The call was not successful, but alternative services are possible. The
* alternative services are described in the message body of the response.
* Formats for such bodies are not defined here, and may be the subject of
* future standardization.
</pre>

			
				<pre>const <span id="AMBIGUOUS">AMBIGUOUS</span> = 485</pre>
				<p>
*
</p>
<pre>* The Request-URI was ambiguous. The response MAY contain a listing of
* possible unambiguous addresses in Contact header fields. Revealing
* alternatives can infringe on privacy of the user or the organization.
* It MUST be possible to configure a server to respond with status 404
* (Not Found) or to suppress the listing of possible choices for ambiguous
* Request-URIs. Some email and voice mail systems provide this
* functionality. A status code separate from 3xx is used since the
* semantics are different: for 300, it is assumed that the same person or
* service will be reached by the choices provided. While an automated
* choice or sequential search makes sense for a 3xx response, user
* intervention is required for a 485 (Ambiguous) response.
</pre>

			
				<pre>const <span id="BAD_EVENT">BAD_EVENT</span> = 489</pre>
				<p>
*
</p>
<pre>* The Bad Event extension response code is used to indicate that the
* server did not understand the event package specified in a &#34;Event&#34;
* header field. This response code is specific to the event notification
* framework.
*
* @since v1.1
</pre>

			
				<pre>const <span id="BAD_EXTENSION">BAD_EXTENSION</span> = 420</pre>
				<p>
*
</p>
<pre>* The server did not understand the protocol extension specified in a
* Proxy-Require or Require header field. The server MUST include a list of
 * the unsupported extensions in an Unsupported header field in the response.
</pre>

			
				<pre>const <span id="BAD_GATEWAY">BAD_GATEWAY</span> = 502</pre>
				<p>
*
</p>
<pre>* The server, while acting as a gateway or proxy, received an invalid
* response from the downstream server it accessed in attempting to
* fulfill the request.
</pre>

			
				<pre>const <span id="BAD_REQUEST">BAD_REQUEST</span> = 400</pre>
				<p>
*
</p>
<pre>* The request could not be understood due to malformed syntax. The
* Reason-Phrase SHOULD identify the syntax problem in more detail, for
* example, &#34;Missing Call-ID header field&#34;.
</pre>

			
				<pre>const <span id="BUSY_EVERYWHERE">BUSY_EVERYWHERE</span> = 600</pre>
				<p>
*
</p>
<pre>* The callee&#39;s end system was contacted successfully but the callee is
* busy and does not wish to take the call at this time. The response
* MAY indicate a better time to call in the Retry-After header field.
* If the callee does not wish to reveal the reason for declining the call,
* the callee uses status code 603 (Decline) instead. This status response
* is returned only if the client knows that no other end point (such as a
* voice mail system) will answer the request. Otherwise, 486 (Busy Here)
* should be returned.
</pre>

			
				<pre>const <span id="BUSY_HERE">BUSY_HERE</span> = 486</pre>
				<p>
*
</p>
<pre>* The callee&#39;s end system was contacted successfully, but the callee is
* currently not willing or able to take additional calls at this end
* system. The response MAY indicate a better time to call in the Retry-After
* header field. The user could also be available elsewhere, such as
* through a voice mail service. Status 600 (Busy Everywhere) SHOULD be
* used if the client knows that no other end system will be able to accept
* this call.
</pre>

			
				<pre>const <span id="BYE">BYE</span> = &#34;BYE&#34;</pre>
				<p>
*
</p>
<pre>* The BYE request is used to terminate a specific
* session or attempted session. When a BYE is received on a dialog, any
* session associated with that dialog SHOULD terminate. A User Agent MUST
* NOT send a BYE outside of a dialog. The caller&#39;s User Agent MAY send a
* BYE for either confirmed or early dialogs, and the callee&#39;s User Agent
* MAY send a BYE on confirmed dialogs, but MUST NOT send a BYE on early
* dialogs. However, the callee&#39;s User Agent MUST NOT send a BYE on a
* confirmed dialog until it has received an ACK for its 2xx response or
* until the server transaction times out. If no SIP extensions have defined
* other application layer states associated with the dialog, the BYE also
* terminates the dialog.
</pre>

			
				<pre>const <span id="CALL_IS_BEING_FORWARDED">CALL_IS_BEING_FORWARDED</span> = 181</pre>
				<p>
*
</p>
<pre>* A server MAY use this status code to indicate that the call is being
* forwarded to a different set of destinations.
</pre>

			
				<pre>const <span id="CALL_OR_TRANSACTION_DOES_NOT_EXIST">CALL_OR_TRANSACTION_DOES_NOT_EXIST</span> = 481</pre>
				<p>
*
</p>
<pre>* This status indicates that the UAS received a request that does not
* match any existing dialog or transaction.
</pre>

			
				<pre>const <span id="CANCEL">CANCEL</span> = &#34;CANCEL&#34;</pre>
				<p>
*
</p>
<pre>* The CANCEL request is used to cancel a previous
* request sent by a client. Specifically, it asks the UAS to cease
* processing the request and to generate an error response to that request.
* CANCEL has no effect on a request to which a UAS has already given a
* final response. Because of this, it is most useful to CANCEL requests to
* which it can take a server long time to respond. For this reason, CANCEL
* is best for INVITE requests, which can take a long time to generate a
* response.
</pre>

			
				<pre>const <span id="DECLINE">DECLINE</span> = 603</pre>
				<p>
*
</p>
<pre>* The callee&#39;s machine was successfully contacted but the user explicitly
* does not wish to or cannot participate. The response MAY indicate a
* better time to call in the Retry-After header field. This status
* response is returned only if the client knows that no other end point
* will answer the request.
</pre>

			
				<pre>const <span id="DOES_NOT_EXIST_ANYWHERE">DOES_NOT_EXIST_ANYWHERE</span> = 604</pre>
				<p>
*
</p>
<pre>* The server has authoritative information that the user indicated in the
* Request-URI does not exist anywhere.
</pre>

			
				<pre>const <span id="EXTENSION_REQUIRED">EXTENSION_REQUIRED</span> = 421</pre>
				<p>
*
</p>
<pre>* The UAS needs a particular extension to process the request, but this
* extension is not listed in a Supported header field in the request.
* Responses with this status code MUST contain a Require header field
* listing the required extensions.
* &lt;p&gt;
* A UAS SHOULD NOT use this response unless it truly cannot provide any
* useful service to the client. Instead, if a desirable extension is not
* listed in the Supported header field, servers SHOULD process the request
* using baseline SIP capabilities and any extensions supported by the
* client.
*
* @since v1.1
</pre>

			
				<pre>const <span id="FORBIDDEN">FORBIDDEN</span> = 403</pre>
				<p>
*
</p>
<pre>* The server understood the request, but is refusing to fulfill it.
* Authorization will not help, and the request SHOULD NOT be repeated.
</pre>

			
				<pre>const <span id="GONE">GONE</span> = 410</pre>
				<p>
*
</p>
<pre>* The requested resource is no longer available at the server and no
* forwarding address is known. This condition is expected to be considered
* permanent. If the server does not know, or has no facility to determine,
* whether or not the condition is permanent, the status code 404
* (Not Found) SHOULD be used instead.
</pre>

			
				<pre>const <span id="INFO">INFO</span> = &#34;INFO&#34;</pre>
				<p>
*
</p>
<pre>* INFO is an extension method which allows for the carrying of session
* related control information that is generated during a session. One
* example of such session control information is ISUP and ISDN signaling
* messages used to control telephony call services. The purpose of the INFO
* message is to carry application level information along the SIP signaling
* path. The signaling path for the INFO method is the signaling path
* established as a result of the call setup. This can be either direct
* signaling between the calling and called user agents or a signaling path
* involving SIP proxy servers that were involved in the call setup and added
* themselves to the Record-Route header on the initial INVITE message.
* &lt;p&gt;
* The INFO method is used for communicating mid-session signaling
* information, it is not used to change the state of SIP calls, nor does it
* change the state of sessions initiated by SIP. Rather, it provides
* additional optional information which can further enhance the application
* using SIP. The mid-session information can be communicated in either an
* INFO message header or as part of a message body. There are no specific
* semantics associated with INFO. The semantics are derived from the body
* or new headers defined for usage in INFO. JAIN SIP provides the
* facility to send {@link javax.sip.header.ExtensionHeader} in messages.
* The INFO request MAY contain a message body. Bodies which imply a change
* in the SIP call state or the sessions initiated by SIP MUST NOT be sent
* in an INFO message.
*
* @since v1.1
</pre>

			
				<pre>const <span id="INTERVAL_TOO_BRIEF">INTERVAL_TOO_BRIEF</span> = 423</pre>
				<p>
*
</p>
<pre>* The server is rejecting the request because the expiration time of the
* resource refreshed by the request is too short. This response can be
* used by a registrar to reject a registration whose Contact header field
* expiration time was too small.
*
* @since v1.1
</pre>

			
				<pre>const <span id="INVITE">INVITE</span> = &#34;INVITE&#34;</pre>
				<p>
*
</p>
<pre>* The INVITE method is used by an user agent client that desires to
* initiate a session, session examples include, audio, video, or a game. The
* INVITE request asks a server to establish a session. This request may be
* forwarded by proxies, eventually arriving at one or more UAS&#39;s that can
* potentially accept the invitation. These UAS&#39;s will frequently need to
* query the user about whether to accept the invitation. After some time,
* those UAS&#39;s can accept the invitation (meaning the session is to be
* established) by sending a 2xx response. If the invitation is not
* accepted, a 3xx, 4xx, 5xx or 6xx response is sent, depending on the
* reason for the rejection. Before sending a final response, the UAS can
* also send provisional responses (1xx) to advise the UAC of progress in
* contacting the called user.
</pre>

			
				<pre>const <span id="LOOP_DETECTED">LOOP_DETECTED</span> = 482</pre>
				<p>
*
</p>
<pre>* The server has detected a loop.
</pre>

			
				<pre>const <span id="MESSAGE">MESSAGE</span> = &#34;MESSAGE&#34;</pre>
				<p>
*
</p>
<pre>* Message is an extension method that allows the transfer of Instant Messages.
* The MESSAGE request inherits all the request routing and security
* features of SIP. MESSAGE requests carry the content in the form of MIME
* body parts. The actual communication between participants happens in the
* media sessions, not in the SIP requests themselves. The MESSAGE method
* changes this assumption.
* &lt;p&gt;
* MESSAGE requests do not themselves initiate a SIP dialog; under
* normal usage each Instant Message stands alone, much like pager
* messages, that is there are no explicit association between messages.
* MESSAGE requests may be sent in the context of a dialog initiated by some
* other SIP request. If a MESSAGE request is sent within a dialog, it is
* &#34;associated&#34; with any media session or sessions associated with that dialog.
* &lt;p&gt;
* When a user wishes to send an instant message to another, the sender
* formulates and issues a Message request. The Request-URI of this request
* will normally be the &#34;address of record&#34; for the recipient of the instant
* message, but it may be a device address in situations where the client
* has current information about the recipient&#39;s location. The body of the
* request will contain the message to be delivered.
* &lt;p&gt;
* Provisional and final responses to the request will be returned to the
* sender as with any other SIP request. Normally, a 200 OK response will be
* generated by the user agent of the request&#39;s final recipient. Note that
* this indicates that the user agent accepted the message, not that the
* user has seen it.
* &lt;p&gt;
* The UAC MAY add an Expires header field to limit the validity of the message
* content. If the UAC adds an Expires header field with a non-zero value, it
* SHOULD also add a Date header field containing the time the message is sent.
* Most SIP requests are used to setup and modify communication sessions.
*
* @since v1.1
</pre>

			
				<pre>const <span id="MESSAGE_TOO_LARGE">MESSAGE_TOO_LARGE</span> = 513</pre>
				<p>
*
</p>
<pre>* The server was unable to process the request since the message length
* exceeded its capabilities.
*
* @since v1.1
</pre>

			
				<pre>const <span id="METHOD_NOT_ALLOWED">METHOD_NOT_ALLOWED</span> = 405</pre>
				<p>
*
</p>
<pre>* The method specified in the Request-Line is understood, but not allowed
* for the address identified by the Request-URI. The response MUST include
* an Allow header field containing a list of valid methods for the
* indicated address
</pre>

			
				<pre>const <span id="MOVED_PERMANENTLY">MOVED_PERMANENTLY</span> = 301</pre>
				<p>
*
</p>
<pre>* The user can no longer be found at the address in the Request-URI, and
* the requesting client SHOULD retry at the new address given by the
* Contact header field. The requestor SHOULD update any local directories,
* address books, and user location caches with this new value and redirect
* future requests to the address(es) listed.
</pre>

			
				<pre>const <span id="MOVED_TEMPORARILY">MOVED_TEMPORARILY</span> = 302</pre>
				<p>
*
</p>
<pre>* The requesting client SHOULD retry the request at the new address(es)
* given by the Contact header field. The Request-URI of the new request
* uses the value of the Contact header field in the response.
* &lt;p&gt;
* The duration of the validity of the Contact URI can be indicated through
* an Expires header field or an expires parameter in the Contact header
* field. Both proxies and User Agents MAY cache this URI for the duration
* of the expiration time. If there is no explicit expiration time, the
* address is only valid once for recursing, and MUST NOT be cached for
* future transactions.
* &lt;p&gt;
* If the URI cached from the Contact header field fails, the Request-URI
* from the redirected request MAY be tried again a single time. The
* temporary URI may have become out-of-date sooner than the expiration
* time, and a new temporary URI may be available.
</pre>

			
				<pre>const <span id="MULTIPLE_CHOICES">MULTIPLE_CHOICES</span> = 300</pre>
				<p>
*
</p>
<pre>* The address in the request resolved to several choices, each with its
* own specific location, and the user (or UA) can select a preferred
* communication end point and redirect its request to that location.
* &lt;p&gt;
* The response MAY include a message body containing a list of resource
* characteristics and location(s) from which the user or UA can choose
* the one most appropriate, if allowed by the Accept request header field.
* However, no MIME types have been defined for this message body.
* &lt;p&gt;
* The choices SHOULD also be listed as Contact fields. Unlike HTTP, the
* SIP response MAY contain several Contact fields or a list of addresses
* in a Contact field. User Agents MAY use the Contact header field value
* for automatic redirection or MAY ask the user to confirm a choice.
* However, this specification does not define any standard for such
* automatic selection.
* &lt;p&gt;
* This status response is appropriate if the callee can be reached at
* several different locations and the server cannot or prefers not to
* proxy the request.
</pre>

			
				<pre>const <span id="NOTIFY">NOTIFY</span> = &#34;NOTIFY&#34;</pre>
				<p>
*
</p>
<pre>* Notify is an extension method that informs subscribers of changes in state
* to which the subscriber has a subscription. Subscriptions are typically
* put in place using the SUBSCRIBE method; however, it is possible that
* other means have been used.
* &lt;p&gt;
* When a SUBSCRIBE request is answered with a 200-class response, the
* notifier MUST immediately construct and send a NOTIFY request to the
* subscriber. When a change in the subscribed state occurs, the notifier
* SHOULD immediately construct and send a NOTIFY request, subject to
* authorization, local policy, and throttling considerations.
* &lt;p&gt;
* A NOTIFY does not terminate its corresponding subscription. i.e. a single
* SUBSCRIBE request may trigger several NOTIFY requests. NOTIFY requests
* MUST contain a &#34;Subscription-State&#34; header with a value of &#34;active&#34;,
* &#34;pending&#34;, or &#34;terminated&#34;. As in SUBSCRIBE requests, NOTIFY &#34;Event&#34;
* headers will contain a single event package name for which a notification
* is being generated. The package name in the &#34;Event&#34; header MUST match
* the &#34;Event&#34; header in the corresponding SUBSCRIBE message. If an &#34;id&#34;
* parameter was present in the SUBSCRIBE message, that &#34;id&#34; parameter MUST
* also be present in the corresponding NOTIFY messages.
* &lt;p&gt;
* Event packages may define semantics associated with the body of their
* NOTIFY requests; if they do so, those semantics apply. NOTIFY bodies
* are expected to provide additional details about the nature of the event
* which has occurred and the resultant resource state. When present, the
* body of the NOTIFY request MUST be formatted into one of the body formats
* specified in the &#34;Accept&#34; header of the corresponding SUBSCRIBE request.
* This body will contain either the state of the subscribed resource or a
* pointer to such state in the form of a URI
* &lt;p&gt;
* A NOTIFY request is considered failed if the response times out, or a
* non-200 class response code is received which has no &#34;Retry-After&#34;
* header and no implied further action which can be taken to retry the
* request. If a NOTIFY request receives a 481 response, the notifier MUST
* remove the corresponding subscription even if such subscription was
* installed by non-SUBSCRIBE means.
* &lt;p&gt;
* If necessary, clients may probe for the support of NOTIFY using the
* OPTIONS. The presence of the &#34;Allow-Events&#34; header in a message is
* sufficient to indicate support for NOTIFY. The &#34;methods&#34; parameter for
* Contact may also be used to specifically announce support for NOTIFY
* messages when registering.
*
* @since v1.1
</pre>

			
				<pre>const <span id="NOT_ACCEPTABLE">NOT_ACCEPTABLE</span> = 406</pre>
				<p>
*
</p>
<pre>* The resource identified by the request is only capable of generating
* response entities that have content characteristics not acceptable
* according to the Accept header field sent in the request.
</pre>

			
				<pre>const <span id="NOT_ACCEPTABLE_HERE">NOT_ACCEPTABLE_HERE</span> = 488</pre>
				<p>
*
</p>
<pre>* The response has the same meaning as 606 (Not Acceptable), but only
* applies to the specific resource addressed by the Request-URI and the
* request may succeed elsewhere. A message body containing a description
* of media capabilities MAY be present in the response, which is formatted
* according to the Accept header field in the INVITE (or application/sdp
* if not present), the same as a message body in a 200 (OK) response to
* an OPTIONS request.
*
* @since v1.1
</pre>

			
				<pre>const <span id="NOT_FOUND">NOT_FOUND</span> = 404</pre>
				<p>
*
</p>
<pre>* The server has definitive information that the user does not exist at
* the domain specified in the Request-URI.  This status is also returned
* if the domain in the Request-URI does not match any of the domains
* handled by the recipient of the request.
</pre>

			
				<pre>const <span id="NOT_IMPLEMENTED">NOT_IMPLEMENTED</span> = 501</pre>
				<p>
*
</p>
<pre>* The server does not support the functionality required to fulfill the
* request. This is the appropriate response when a UAS does not recognize
* the request method and is not capable of supporting it for any user.
* Proxies forward all requests regardless of method. Note that a 405
* (Method Not Allowed) is sent when the server recognizes the request
* method, but that method is not allowed or supported.
</pre>

			
				<pre>const <span id="OK">OK</span> = 200</pre>
				<p>
*
</p>
<pre>* The request has succeeded. The information returned with the response
* depends on the method used in the request.
</pre>

			
				<pre>const <span id="OPTIONS">OPTIONS</span> = &#34;OPTIONS&#34;</pre>
				<p>
*
</p>
<pre>* The OPTIONS method allows a User Agent to query
* another User Agent or a proxy server as to its capabilities. This allows
* a client to discover information about the supported methods, content
* types, extensions, codecs, etc. without &#34;ringing&#34; the other party. For
* example, before a client inserts a Require header field into an INVITE
* listing an option that it is not certain the destination UAS supports,
* the client can query the destination UAS with an OPTIONS to see if this
* option is returned in a Supported header field. All User Agents MUST
* support the OPTIONS method.
</pre>

			
				<pre>const <span id="PAYMENT_REQUIRED">PAYMENT_REQUIRED</span> = 402</pre>
				<p>
*
</p>
<pre>* Reserved for future use.
</pre>

			
				<pre>const <span id="PRACK">PRACK</span> = &#34;PRACK&#34;</pre>
				<p>
*
</p>
<pre>* PRACK is an extension method that plays the same role as ACK, but for
* provisional responses. PRACK is a normal SIP message, like BYE. As such,
* its own reliability is ensured hop-by-hop through each stateful
* proxy. Also like BYE, but unlike ACK, PRACK has its own response.
* In order to achieve reliability of provisional responses, in a similiar
* manner to 2xx final responses to INVITE, reliable provisional responses
* are retransmitted with an exponential backoff, which cease when a PRACK
* message is received. The PRACK messages contain an RAck header field,
* which indicates the sequence number of the provisional response that is
* being acknowledged.
* &lt;p&gt;
* PRACK is like any other request within a dialog, and is treated likewise.
* In particular, a UAC SHOULD NOT retransmit the PRACK request when it
* receives a retransmission of the provisional response being acknowledged,
* although doing so does not create a protocol error. A matching PRACK is
* defined as one within the same dialog as the response, and whose
* method, CSeq-num, and RSeq-num in the RAck header field match,
* respectively, the method and sequence number from the CSeq and the
* sequence number from the RSeq header of the reliable provisional response.
* PRACK requests MAY contain bodies, which are interpreted according to
* their type and disposition.
*
* @since v1.1
</pre>

			
				<pre>const <span id="PROXY_AUTHENTICATION_REQUIRED">PROXY_AUTHENTICATION_REQUIRED</span> = 407</pre>
				<p>
*
</p>
<pre>* This code is similar to 401 (Unauthorized), but indicates that the client
* MUST first authenticate itself with the proxy. This status code can be
* used for applications where access to the communication channel (for
* example, a telephony gateway) rather than the callee requires
* authentication.
</pre>

			
				<pre>const <span id="QUEUED">QUEUED</span> = 182</pre>
				<p>
*
</p>
<pre>* The called party is temporarily unavailable, but the server has decided
* to queue the call rather than reject it. When the callee becomes
* available, it will return the appropriate final status response. The
* reason phrase MAY give further details about the status of the call,
* for example, &#34;5 calls queued; expected waiting time is 15 minutes&#34;. The
* server MAY issue several 182 (Queued) responses to update the caller
* about the status of the queued call.
</pre>

			
				<pre>const <span id="REFER">REFER</span> = &#34;REFER&#34;</pre>
				<p>
*
</p>
<pre>* Refer is an extension method that requests that the recipient REFER to a
* resource provided in the request, this can be used to enable many
* applications such as Call Transfer. The REFER method indicates that
* the recipient (identified by the Request-URI) should contact a third
* party using the contact information provided in the request. A REFER
* request MUST contain exactly one Refer-To header field value and MAY
* contain a body. A receiving agent may choose to process the body
* according to its Content-Type.
* &lt;p&gt;
* A User Agent accepting a well-formed REFER request SHOULD request
* approval from the user to proceed. If approval is granted, the User
* Agent MUST contact the resource identified by the URI. SIP proxies do
* not require modification to support the REFER method. A proxy should
* process a REFER request the same way it processes an OPTIONS request.
* &lt;p&gt;
* A REFER request implicitly establishes a subscription to the &#34;refer&#34;
* event. The agent issuing the REFER can terminate this subscription
* prematurely by unsubscribing. A REFER request MAY be placed outside
* the scope of a dialog created with an INVITE. REFER creates a dialog,
* and MAY be Record-Routed, hence MUST contain a single Contact header
* field value. REFERs occurring inside an existing dialog MUST follow
* the Route/Record-Route logic of that dialog. The NOTIFY mechanism MUST
* be used to inform the agent sending the REFER of the status of the
* reference. The dialog identifiers of each NOTIFY must match those of
* the REFER as they would if the REFER had been a SUBSCRIBE request. If
* more than one REFER is issued in the same dialog, the dialog
* identifiers do not provide enough information to associate the
* resulting NOTIFYs with the proper REFER. Therefore it MUST include an
* &#34;id&#34; parameter in the Event header field of each NOTIFY containing the
* sequence number of the REFER this NOTIFY is associated with. A REFER
* sent within the scope of an existing dialog will not fork. A REFER
* sent outside the context of a dialog MAY fork, and if it is accepted
* by multiple agents, MAY create multiple subscriptions.
*
* @since v1.1
</pre>

			
				<pre>const <span id="REGISTER">REGISTER</span> = &#34;REGISTER&#34;</pre>
				<p>
*
</p>
<pre>* The REGISTER method requests the addition,
* removal, and query of bindings. A REGISTER request can add a new binding
* between an address-of-record and one or more contact addresses.
* Registration on behalf of a particular address-of-record can be performed
* by a suitably authorized third party. A client can also remove previous
* bindings or query to determine which bindings are currently in place for
* an address-of-record. A REGISTER request does not establish a dialog.
* Registration entails sending a REGISTER request to a special type of UAS
* known as a registrar. A registrar acts as the front end to the location
* service for a domain, reading and writing mappings based on the contents
* of REGISTER requests. This location service is then typically consulted
* by a proxy server that is responsible for routing requests for that domain.
</pre>

			
				<pre>const <span id="REQUEST_ENTITY_TOO_LARGE">REQUEST_ENTITY_TOO_LARGE</span> = 413</pre>
				<p>
*
</p>
<pre>* The server is refusing to process a request because the request
* entity-body is larger than the server is willing or able to process. The
* server MAY close the connection to prevent the client from continuing
* the request. If the condition is temporary, the server SHOULD include a
* Retry-After header field to indicate that it is temporary and after what
* time the client MAY try again.
*
* @since v1.1
</pre>

			
				<pre>const <span id="REQUEST_PENDING">REQUEST_PENDING</span> = 491</pre>
				<p>
*
</p>
<pre>* The request was received by a UAS that had a pending request within
* the same dialog.
*
* @since v1.1
</pre>

			
				<pre>const <span id="REQUEST_TERMINATED">REQUEST_TERMINATED</span> = 487</pre>
				<p>
*
</p>
<pre>* The request was terminated by a BYE or CANCEL request. This response is
* never returned for a CANCEL request itself.
*
* @since v1.1
</pre>

			
				<pre>const <span id="REQUEST_TIMEOUT">REQUEST_TIMEOUT</span> = 408</pre>
				<p>
*
</p>
<pre>* The server could not produce a response within a suitable amount of
* time, for example, if it could not determine the location of the user
* in time. The client MAY repeat the request without modifications at
* any later time.
</pre>

			
				<pre>const <span id="REQUEST_URI_TOO_LONG">REQUEST_URI_TOO_LONG</span> = 414</pre>
				<p>
*
</p>
<pre>* The server is refusing to service the request because the Request-URI
* is longer than the server is willing to interpret.
*
* @since v1.1
</pre>

			
				<pre>const <span id="RINGING">RINGING</span> = 180</pre>
				<p>
*
</p>
<pre>* The User Agent receiving the INVITE is trying to alert the user. This
* response MAY be used to initiate local ringback.
</pre>

			
				<pre>const <span id="SERVER_INTERNAL_ERROR">SERVER_INTERNAL_ERROR</span> = 500</pre>
				<p>
*
</p>
<pre>* The server encountered an unexpected condition that prevented it from
* fulfilling the request. The client MAY display the specific error
* condition and MAY retry the request after several seconds. If the
* condition is temporary, the server MAY indicate when the client may
* retry the request using the Retry-After header field.
</pre>

			
				<pre>const <span id="SERVER_TIMEOUT">SERVER_TIMEOUT</span> = 504</pre>
				<p>
*
</p>
<pre>* The server did not receive a timely response from an external server
* it accessed in attempting to process the request. 408 (Request Timeout)
* should be used instead if there was no response within the
* period specified in the Expires header field from the upstream server.
</pre>

			
				<pre>const <span id="SERVICE_UNAVAILABLE">SERVICE_UNAVAILABLE</span> = 503</pre>
				<p>
*
</p>
<pre>* The server is temporarily unable to process the request due to a
* temporary overloading or maintenance of the server. The server MAY
* indicate when the client should retry the request in a Retry-After
* header field. If no Retry-After is given, the client MUST act as if it
* had received a 500 (Server Internal Error) response.
* &lt;p&gt;
* A client (proxy or UAC) receiving a 503 (Service Unavailable) SHOULD
* attempt to forward the request to an alternate server. It SHOULD NOT
* forward any other requests to that server for the duration specified
* in the Retry-After header field, if present.
* &lt;p&gt;
* Servers MAY refuse the connection or drop the request instead of
* responding with 503 (Service Unavailable).
*
* @since v1.1
</pre>

			
				<pre>const <span id="SESSION_NOT_ACCEPTABLE">SESSION_NOT_ACCEPTABLE</span> = 606</pre>
				<p>
*
</p>
<pre>* The user&#39;s agent was contacted successfully but some aspects of the
* session description such as the requested media, bandwidth, or addressing
* style were not acceptable. A 606 (Not Acceptable) response means that
* the user wishes to communicate, but cannot adequately support the
* session described. The 606 (Not Acceptable) response MAY contain a list
* of reasons in a Warning header field describing why the session described
* cannot be supported.
* &lt;p&gt;
* A message body containing a description of media capabilities MAY be
* present in the response, which is formatted according to the Accept
* header field in the INVITE (or application/sdp if not present), the same
* as a message body in a 200 (OK) response to an OPTIONS request.
* &lt;p&gt;
* It is hoped that negotiation will not frequently be needed, and when a
* new user is being invited to join an already existing conference,
* negotiation may not be possible. It is up to the invitation initiator to
* decide whether or not to act on a 606 (Not Acceptable) response.
* &lt;p&gt;
* This status response is returned only if the client knows that no other
* end point will answer the request. This specification renames this
* status code from NOT_ACCEPTABLE as in RFC3261 to SESSION_NOT_ACCEPTABLE
* due to it conflict with 406 (Not Acceptable) defined in this interface.
</pre>

			
				<pre>const <span id="SESSION_PROGRESS">SESSION_PROGRESS</span> = 183</pre>
				<p>
*
</p>
<pre>* The 183 (Session Progress) response is used to convey information about
* the progress of the call that is not otherwise classified. The
* Reason-Phrase, header fields, or message body MAY be used to convey more
* details about the call progress.
*
* @since v1.1
</pre>

			
				<pre>const <span id="SUBSCRIBE">SUBSCRIBE</span> = &#34;SUBSCRIBE&#34;</pre>
				<p>
*
</p>
<pre>* Subscribe is an extension method that is used to request current state
* and state updates from a remote node. SUBSCRIBE requests SHOULD contain
* an &#34;Expires&#34; header, which indicates the duration of the subscription.
* In order to keep subscriptions effective beyond the duration communicated
* in the &#34;Expires&#34; header, subscribers need to refresh subscriptions on a
* periodic basis using a new SUBSCRIBE message on the same dialog. If no
* &#34;Expires&#34; header is present in a SUBSCRIBE request, the implied default
* is defined by the event package being used.
* &lt;p&gt;
* 200-class responses to a SUBSCRIBE request indicate that the subscription
* has been accepted, and that a NOTIFY will be sent immediately. If the
* subscription resource has no meaningful state at the time that the SUBSCRIBE
* message is processed, this NOTIFY message MAY contain an empty or neutral body.
* 200-class responses to SUBSCRIBE requests also MUST contain an &#34;Expires&#34;
* header. The period of time in the response MAY be shorter but MUST NOT be
* longer than specified in the request. The period of time in the response
* is the one which defines the duration of the subscription. An &#34;expires&#34;
* parameter on the &#34;Contact&#34; header has no semantics for SUBSCRIBE and is
* explicitly not equivalent to an &#34;Expires&#34; header in a SUBSCRIBE request
* or response.
* &lt;p&gt;
* The Request URI of a SUBSCRIBE request, contains enough information to
* route the request to the appropriate entity. It also contains enough
* information to identify the resource for which event notification is
* desired, but not necessarily enough information to uniquely identify the
* nature of the event. Therefore Subscribers MUST include exactly one
* &#34;Event&#34; header in SUBSCRIBE requests, indicating to which event or class
* of events they are subscribing. The &#34;Event&#34; header will contain a token
* which indicates the type of state for which a subscription is being
* requested.
* &lt;p&gt;
* As SUBSCRIBE requests create a dialog, they MAY contain an &#34;Accept&#34;
* header. This header, if present, indicates the body formats allowed in
* subsequent NOTIFY requests. Event packages MUST define the behavior for
* SUBSCRIBE requests without &#34;Accept&#34; headers. If an initial SUBSCRIBE is
* sent on a pre-existing dialog, a matching 200-class response or successful
* NOTIFY request merely creates a new subscription associated with that
* dialog. Multiple subscriptions can be associated with a single dialog.
* &lt;p&gt;
* Unsubscribing is handled in the same way as refreshing of a subscription,
* with the &#34;Expires&#34; header set to &#34;0&#34;. Note that a successful unsubscription
* will also trigger a final NOTIFY message.
* &lt;p&gt;
* If necessary, clients may probe for the support of SUBSCRIBE using the
* OPTIONS. The presence of the &#34;Allow-Events&#34; header in a message is
* sufficient to indicate support for SUBSCRIBE. The &#34;methods&#34; parameter for
* Contact may also be used to specifically announce support for SUBSCRIBE
* messages when registering.
*
* @since v1.1
</pre>

			
				<pre>const <span id="TEMPORARILY_UNAVAILABLE">TEMPORARILY_UNAVAILABLE</span> = 480</pre>
				<p>
*
</p>
<pre>* The callee&#39;s end system was contacted successfully but the callee is
* currently unavailable (for example, is not logged in, logged in but in a
* state that precludes communication with the callee, or has activated the
* &#34;do not disturb&#34; feature). The response MAY indicate a better time to
* call in the Retry-After header field. The user could also be available
* elsewhere (unbeknownst to this server). The reason phrase SHOULD indicate
* a more precise cause as to why the callee is unavailable. This value
* SHOULD be settable by the UA. Status 486 (Busy Here) MAY be used to more
* precisely indicate a particular reason for the call failure.
* &lt;p&gt;
* This status is also returned by a redirect or proxy server that
* recognizes the user identified by the Request-URI, but does not currently
* have a valid forwarding location for that user.
*
* @since v1.1
</pre>

			
				<pre>const <span id="TOO_MANY_HOPS">TOO_MANY_HOPS</span> = 483</pre>
				<p>
*
</p>
<pre>* The server received a request that contains a Max-Forwards header field
* with the value zero.
</pre>

			
				<pre>const <span id="TRYING">TRYING</span> = 100</pre>
				<p>
*
</p>
<pre>* This response indicates that the request has been received by the
* next-hop server and that some unspecified action is being taken on
* behalf of this call (for example, a database is being consulted). This
* response, like all other provisional responses, stops retransmissions of
* an INVITE by a UAC. The 100 (Trying) response is different from other
* provisional responses, in that it is never forwarded upstream by a
* stateful proxy.
</pre>

			
				<pre>const <span id="UNAUTHORIZED">UNAUTHORIZED</span> = 401</pre>
				<p>
*
</p>
<pre>* The request requires user authentication. This response is issued by
* UASs and registrars, while 407 (Proxy Authentication Required) is used
* by proxy servers.
</pre>

			
				<pre>const <span id="UNDECIPHERABLE">UNDECIPHERABLE</span> = 493</pre>
				<p>
*
</p>
<pre>* The request was received by a UAS that contained an encrypted MIME body
* for which the recipient does not possess or will not provide an
* appropriate decryption key. This response MAY have a single body
* containing an appropriate public key that should be used to encrypt MIME
* bodies sent to this UA.
*
* @since v1.1
</pre>

			
				<pre>const <span id="UNSUPPORTED_MEDIA_TYPE">UNSUPPORTED_MEDIA_TYPE</span> = 415</pre>
				<p>
*
</p>
<pre>* The server is refusing to service the request because the message body
* of the request is in a format not supported by the server for the
* requested method. The server MUST return a list of acceptable formats
* using the Accept, Accept-Encoding, or Accept-Language header field,
* depending on the specific problem with the content.
</pre>

			
				<pre>const <span id="UNSUPPORTED_URI_SCHEME">UNSUPPORTED_URI_SCHEME</span> = 416</pre>
				<p>
*
</p>
<pre>* The server cannot process the request because the scheme of the URI in
* the Request-URI is unknown to the server.
*
* @since v1.1
</pre>

			
				<pre>const <span id="UPDATE">UPDATE</span> = &#34;UPDATE&#34;</pre>
				<p>
*
</p>
<pre>* UPDATE is an extension method that allows a client to update parameters
* of a session (such as the set of media streams and their codecs) but has
* no impact on the state of a dialog. In that sense, it is like a re-INVITE,
* but unlike re-INVITE, it can be sent before the initial INVITE has been
* completed. This makes it very useful for updating session parameters
* within early dialogs. Operation of this extension is straightforward, the
* caller begins with an INVITE transaction, which proceeds normally. Once a
* dialog is established, the caller can generate an UPDATE method that
* contains an SDP offer for the purposes of updating the session. The
* response to the UPDATE method contains the answer. The Allow header
* field is used to indicate support for the UPDATE method. There are
* additional constraints on when UPDATE can be used, based on the
* restrictions of the offer/answer model. Although UPDATE can be used on
* confirmed dialogs, it is RECOMMENDED that a re-INVITE be used instead.
* This is because an UPDATE needs to be answered immediately, ruling out
* the possibility of user approval. Such approval will frequently be needed,
* and is possible with a re-INVITE.
*
* @since v1.1
</pre>

			
				<pre>const <span id="USE_PROXY">USE_PROXY</span> = 305</pre>
				<p>
*
</p>
<pre>* The requested resource MUST be accessed through the proxy given by the
* Contact field.  The Contact field gives the URI of the proxy. The
* recipient is expected to repeat this single request via the proxy.
* 305 (Use Proxy) responses MUST only be generated by UASs.
</pre>

			
				<pre>const <span id="VERSION_NOT_SUPPORTED">VERSION_NOT_SUPPORTED</span> = 505</pre>
				<p>
*
</p>
<pre>* The server does not support, or refuses to support, the SIP protocol
* version that was used in the request. The server is indicating that
* it is unable or unwilling to complete the request using the same major
* version as the client, other than with this error message.
</pre>

			
		
		
		
		
			
			
			<h2 id="Message">type <a href="/target/Message.go?s=1578:13589#L34">Message</a></h2>
			<pre>type Message interface {

    <span class="comment">/**
     * Adds the new Header to the existing list of Headers contained in this
     * Message. The Header is added to the end of the List and will appear in
     * that order in the SIP Message.
     * &lt;p&gt;
     * Required Headers that are singletons should not be added to the message
     * as they already exist in the message and therefore should be changed using
     * the {@link Message#setHeader(Header)} method.
     * &lt;p&gt;
     * This method should be used to support the special case of adding
     * required ViaHeaders to a message. When adding a ViaHeader using this
     * method the implementation will add the ViaHeader to the top of the
     * ViaHeader list, and not the end like all other Headers.
     *
     * @param header the new Header to be added to the existing Headers List.
     */</span>
    AddHeader(h <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>)

    <span class="comment">/**
     * Removes the Header of the supplied name from the list of headers in
     * this Message. If multiple headers exist then they are all removed from
     * the header list. If no headers exist then this method returns silently.
     * This method should not be used to remove required Headers, required
     * Headers should be replaced using the {@link Message#setHeader(Header)}.
     *
     * @param headername the new string value name of the Header to be
     * removed.
     */</span>
    RemoveHeader(headerName <a href="/pkg/builtin/#string">string</a>)

    <span class="comment">/**
     * Gets a ListIterator over all the header names in this Message. Note
     * that the order of the Header Names in the ListIterator is same as the
     * order in which they appear in the SIP Message.
     *
     * @return the ListIterator over all the Header Names in the Message.
     */</span>
    GetHeaderNames() *<a href="/pkg/container/list/">list</a>.<a href="/pkg/container/list/#List">List</a> <span class="comment">//ListIterator;</span>

    <span class="comment">/**
     * Gets a ListIterator over all the Headers of the newly specified name
     * in this Message. Note that order of the Headers in ListIterator is the
     * same as the order in which they appear in the SIP Message.
     *
     * @param headerName the new string name of Header types requested.
     * @return the ListIterator over all the Headers of the specified name in
     * the Message, this method returns an empty ListIterator if no Headers
     * exist of this header type.
     */</span>
    GetHeaders(headerName <a href="/pkg/builtin/#string">string</a>) *<a href="/pkg/container/list/">list</a>.<a href="/pkg/container/list/#List">List</a> <span class="comment">//ListIterator;</span>

    <span class="comment">/**
     * Gets the Header of the specified name in this Message. If multiple
     * Headers of this header name exist in the message, the first header
     * in the message is returned.
     *
     * @param headerName the new string name of Header type requested.
     * @return the Header of the specified name in the Message, this method
     * returns null if the Header does not exist.
     */</span>
    GetHeader(headerName <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>

    <span class="comment">/**
     * Gets a ListIterator over all the UnrecognizedHeaders in this
     * Message. Note the order of the UnrecognizedHeaders in the ListIterator is
     * the same as order in which they appeared in the SIP Message.
     * UnrecognizedHeaders are headers that the underlying implementation does
     * not recognize, if a header is recognized but is badly formatted it will
     * be dropped by the underlying implementation and will not be included in
     * this list. A Proxy should not delete UnrecognizedHeaders and should
     * add these Headers to the end of the header list of the Message that is
     * being forwarded. A User Agent may display these unrecognized headers to
     * the user.
     *
     * @return the ListIterator over all the UnrecognizedHeaders in the Message
     * represented as Strings, this method returns an empty ListIterator if no
     * UnrecognizedHeaders exist.
     */</span>
    GetUnrecognizedHeaders() *<a href="/pkg/container/list/">list</a>.<a href="/pkg/container/list/#List">List</a> <span class="comment">//ListIterator;</span>

    <span class="comment">/**
     * Sets the new Header to replace existings Header of that type in
     * the message. If the SIP message contains more than one Header of
     * the new Header type it should replace the first occurance of this
     * Header and removes all other Headers of this type. If no Header of this
     * type exists this header is added to the end of the SIP Message.
     * This method should be used to change required Headers and overwrite
     * optional Headers.
     *
     * @param header the new Header to replace any existing Headers of that
     * type.
     */</span>
    SetHeader(h <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#Header">Header</a>)

    <span class="comment">/**
     * Set the ContentLengthHeader of this Message.
     * The actual content length for the outgoing message will be computed from
     * the content assigned. If the content is speficied as an object it will
     * be converted to a String before the message is sent out and the content
     * length computed from the length of the string. If the message content is
     * specified in bytes, the length of the byte array specified will be used
     * to determine the content length header, that is in both cases, the length
     * of the content overrides any value specified in the content-length
     * header.
     *
     * @param contentLength the new ContentLengthHeader object containing the
     * content length value of this Message.
     *
     */</span>
    SetContentLength(contentLength <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentLengthHeader">ContentLengthHeader</a>)

    <span class="comment">/**
     * Gets the ContentLengthHeader of the body content of this Message. This is
     * the same as &lt;code&gt;this.getHeader(Content-Length);&lt;/code&gt;
     *
     * @return the ContentLengthHeader of the message body.
     */</span>
    GetContentLength() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentLengthHeader">ContentLengthHeader</a>

    <span class="comment">/**
     * Sets the ContentLanguageHeader of this Message. This overrides the
     * ContentLanguageHeader set using the setHeaders method. If no
     * ContentLanguageHeader exists in this message this ContentLanguageHeader
     * is added to the end of the Header List.
     *
     * @param contentLanguage the new ContentLanguageHeader object containing the
     * content language value of this Message.
     */</span>
    SetContentLanguage(contentLanguage <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentLanguageHeader">ContentLanguageHeader</a>)

    <span class="comment">/**
     * Gets the ContentLanguageHeader of this Message. This is the same as
     * &lt;code&gt;this.getHeader(Content-Langauge);&lt;/code&gt;
     *
     * @return the ContentLanguageHeader of the message body.
     */</span>
    GetContentLanguage() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentLanguageHeader">ContentLanguageHeader</a>

    <span class="comment">/**
     * Sets the ContentEncodingHeader of this Message. This overrides the
     * ContentEncodingHeader set using the setHeaders method. If no
     * ContentEncodingHeader exists in this message this ContentEncodingHeader
     * is added to the end of the Header List.
     *
     * @param contentEncoding the new ContentEncodingHeader object containing the
     * content encoding values of this Message.
     */</span>
    SetContentEncoding(contentEncoding <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentEncodingHeader">ContentEncodingHeader</a>)

    <span class="comment">/**
     * Gets the ContentEncodingHeader of this Message. This is the same as
     * &lt;code&gt;this.getHeader(Content-Encoding);&lt;/code&gt;
     *
     * @return the ContentEncodingHeader of the message body.
     */</span>
    GetContentEncoding() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentEncodingHeader">ContentEncodingHeader</a>

    <span class="comment">/**
     * Sets the ContentDispositionHeader of this Message. This overrides the
     * ContentDispositionHeader set using the setHeaders method. If no
     * ContentDispositionHeader exists in this message this ContentDispositionHeader
     * is added to the end of the Header List.
     *
     * @param contentDisposition the new ContentDispositionHeader object
     * containing the content disposition value of this Message.
     */</span>
    SetContentDisposition(contentDisposition <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentDispositionHeader">ContentDispositionHeader</a>)

    <span class="comment">/**
     * Gets the ContentDispositionHeader of this Message. This is the same as
     * &lt;code&gt;this.getHeader(Content-Disposition);&lt;/code&gt;
     *
     * @return the ContentDispositionHeader of the message body.
     */</span>
    GetContentDisposition() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentDispositionHeader">ContentDispositionHeader</a>

    <span class="comment">/**
       * Sets the body of this Message, with the ContentType defined by the new
       * ContentTypeHeader object and the string value of the content.
       *
      * @param content the new Object value of the content of the Message.
       * @param contentTypeHeader the new ContentTypeHeader object that defines
       * the content type value.
       * @throws ParseException which signals that an error has been reached
       * unexpectedly while parsing the body.
    */</span>
    SetContent(content interface{}, contentTypeHeader <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ContentTypeHeader">ContentTypeHeader</a>) (ParseException <a href="/pkg/builtin/#error">error</a>)

    <span class="comment">/**
     * Gets the body content of the Message as a byte array.
     *
     * @return the body content of the Message as a byte array, this method
     * returns null if a body does not exist.
     */</span>
    GetRawContent() []<a href="/pkg/builtin/#byte">byte</a>

    <span class="comment">/**
     * Gets the body content of the Message as an Object.
     *
     * @return the body content of the Message as an Object, this method
     * returns null if a body does not exist.
     */</span>
    GetContent() interface{}

    <span class="comment">/**
     * Removes the body content from this Message and all associated entity
     * headers, if a body exists, this method returns sliently if no body exists.
     */</span>
    RemoveContent()

    <span class="comment">/**
     * Sets the ExpiresHeader of this Message. This overrides the ExpiresHeader
     * set using the setHeaders method. If no ExpiresHeader exists in this
     * message this ExpiresHeader is added to the end of the Header List.
     *
     * @param expires the new ExpiresHeader object containing the expires
     * values of this Message.
     */</span>
    SetExpires(expires <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ExpiresHeader">ExpiresHeader</a>)

    <span class="comment">/**
     * Gets the ExpiresHeader of this Message. This is the same as
     * &lt;code&gt;this.getHeader(Expires);&lt;/code&gt;
     *
     * @return the ExpiresHeader of the message body.
     */</span>
    GetExpires() <a href="/pkg/gosip/header/">header</a>.<a href="/pkg/gosip/header/#ExpiresHeader">ExpiresHeader</a>

    <span class="comment">/**
     * Sets the protocol version of SIP being used by this Message.
     *
     * @param version the new String object containing the version of the SIP
     * Protocol of this Message.
     * @throws ParseException which signals that an error has been reached
     * unexpectedly while parsing the version argument.
     */</span>
    SetSIPVersion(version <a href="/pkg/builtin/#string">string</a>) (ParseException <a href="/pkg/builtin/#error">error</a>)

    <span class="comment">/**
     * Gets the protocol version of SIP being used by this Message.
     *
     * @return the protocol version of the SIP protocol of this message.
     */</span>
    GetSIPVersion() <a href="/pkg/builtin/#string">string</a>

    <span class="comment">/**
     * Creates and returns a deep copy of the Message. This methods must ensure a
     * deep copy of the message, so that it can be modified without effecting
     * the original message. This provides useful functionality for proxying
     * Requests and Responses, for example:
     * &lt;ul&gt;
     * &lt;li&gt;Recieve a message.
     * &lt;li&gt;Create a deep clone of the message.
     * &lt;li&gt;Modify necessary headers.
     * &lt;li&gt;Proxy the message using the send methods on the SipProvider.
     * &lt;/ul&gt;
     *
     * @return a deep copy of Message
     */</span>
    Clone() interface{}

    <span class="comment">/**
     * Gets string representation of Message
     * @return string representation of Message
     */</span>
    ToString() <a href="/pkg/builtin/#string">string</a>
    <span class="comment">/**
     * Compare this SIP Message for equality with another.
     *
     * @param obj the object to compare this Message with.
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;obj&lt;/code&gt; is an instance of this class
     * representing the same SIP Message as this, &lt;code&gt;false&lt;/code&gt; otherwise.
     */</span>
    Equals(object interface{}) <a href="/pkg/builtin/#bool">bool</a>
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Request">type <a href="/target/Request.go?s=3452:5109#L59">Request</a></h2>
			<pre>type Request interface {
    <a href="#Message">Message</a>

    <span class="comment">/**
     * Gets method string of this Request message.
     *
     * @return the method of this Request message.
     */</span>
    GetMethod() <a href="/pkg/builtin/#string">string</a>

    <span class="comment">/**
     * Sets the method of Request to the newly supplied value. The standard
     * RFC3261 methods are REGISTER for registering contact information, INVITE,
     * ACK, and CANCEL for setting up sessions, BYE for terminating sessions, and
     * OPTIONS for querying servers about their capabilities.
     *
     * @param method - the new string value of the method of Request
     * @throws ParseException which signals that an error has been reached
     * unexpectedly while parsing the method value.
     */</span>
    SetMethod(method <a href="/pkg/builtin/#string">string</a>) (ParseException <a href="/pkg/builtin/#error">error</a>)

    <span class="comment">/**
     * Gets the URI Object identifying the request URI of this Request, which
     * indicates the user or service to which this request is addressed.
     *
     * @return Request URI of Request
     */</span>
    GetRequestURI() <a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#URI">URI</a>

    <span class="comment">/**
     * Sets the RequestURI of Request. The Request-URI is a SIP or SIPS URI
     * or a general URI. It indicates the user or service to which this request
     * is being addressed. SIP elements MAY support Request-URIs with schemes
     * other than &#34;sip&#34; and &#34;sips&#34;, for example the &#34;tel&#34; URI scheme. SIP
     * elements MAY translate non-SIP URIs using any mechanism at their disposal,
     * resulting in SIP URI, SIPS URI, or some other scheme.
     *
     * @param requestURI - the new Request URI of this request message
     */</span>
    SetRequestURI(requestURI <a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#URI">URI</a>)
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Response">type <a href="/target/Response.go?s=8448:10177#L186">Response</a></h2>
			<pre>type Response interface {
    <a href="#Message">Message</a>

    <span class="comment">/**
     * Sets the status-code of Response. The status-code is a 3-digit integer
     * result code that indicates the outcome of an attempt to understand and
     * satisfy a request.  The Status-Code is intended for use by automata.
     *
     * @param statusCode the new integer value of the status code.
     * @throws ParseException which signals that an error has been reached
     * unexpectedly while parsing the statusCode value.
     */</span>
    SetStatusCode(statusCode <a href="/pkg/builtin/#int">int</a>) (ParseException <a href="/pkg/builtin/#error">error</a>)

    <span class="comment">/**
     * Gets the integer value of the status code of Response, which identifies
     * the outcome of the request to which this response is related.
     *
     * @return the integer status-code of this Response message.
     */</span>
    GetStatusCode() <a href="/pkg/builtin/#int">int</a>

    <span class="comment">/**
     * Sets reason phrase of Response. The reason-phrase is intended to give a
     * short textual description of the status-code. The reason-phrase is
     * intended for the human user. A client is not required to examine or
     * display the reason-phrase. While RFC3261 suggests specific wording for
     * the reason phrase, implementations MAY choose other text.
     *
     * @param reasonPhrase the new string value of the reason phrase.
     * @throws ParseException which signals that an error has been reached
     * unexpectedly while parsing the reasonPhrase value.
     */</span>
    SetReasonPhrase(reasonPhrase <a href="/pkg/builtin/#string">string</a>) (ParseException <a href="/pkg/builtin/#error">error</a>)

    <span class="comment">/**
     * Gets the reason phrase of this Response message.
     *
     * @return the string value of the reason phrase of this Response message.
     */</span>
    GetReasonPhrase() <a href="/pkg/builtin/#string">string</a>
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Router">type <a href="/target/Router.go?s=1507:2196#L29">Router</a></h2>
			<pre>type Router interface {

    <span class="comment">/**
     * Gets the Outbound Proxy parameter of this Router, this method may return
     * null if no outbound proxy is defined.
     *
     * @return the Outbound Proxy of this Router.
     * @see Hop
     */</span>
    GetOutboundProxy() <a href="/pkg/gosip/address/">address</a>.<a href="/pkg/gosip/address/#Hop">Hop</a>

    <span class="comment">/**
     * Gets the ListIterator of the hops of the default Route. This method may
     * return null if a default route is not defined.
     *
     * @param request - the Request message that determines the default route.
     * @return the ListIterator over all the hops of this Router.
     * @see Hop
     */</span>
    GetNextHops(request <a href="#Request">Request</a>) *<a href="/pkg/container/list/">list</a>.<a href="/pkg/container/list/#List">List</a> <span class="comment">//ListIterator</span>

}</pre>
			

			

			

			

			

			
		
	

	





